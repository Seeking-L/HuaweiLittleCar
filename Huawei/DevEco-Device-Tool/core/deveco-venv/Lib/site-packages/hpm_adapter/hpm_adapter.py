import subprocess
import sys
import os
import json
import shutil
import threading
from packaging import version
from hpm_adapter.helpers import get_hpm, get_node_path


class Hpm:

    def __exec(self, cmd, **kwargs):
        # returns a tuple: (error code, stdout string, stderr string)
        if self.__log:
            cmd_line = ' '.join(cmd)
            print(f'[HPM] \033[36mhpm {cmd_line}\033[0m')

        hpm_executable = self._executable_ if self._executable_ else shutil.which('hpm')
        if not hpm_executable:
            if self.__log:
                print('HPM executable is not found')
            return -1, '', 'HPM executable is not found'

        cmd = [hpm_executable] + cmd
        env = os.environ
        env["PATH"] = os.pathsep.join([get_node_path(),
                                       os.path.dirname(hpm_executable),
                                       env.get("PATH", "")])

        default = dict(stdout=self.__stdout,
                       stderr=self.__stderr,
                       shell=False,
                       env=env)
        default.update(kwargs)
        kwargs = default

        p = subprocess.Popen(cmd, **kwargs)

        base_thread_id = getattr(threading.current_thread(), 'base_thread', threading.get_ident())
        base_thread = next(x for x in threading.enumerate() if x.ident == base_thread_id)
        setattr(base_thread, 'active_pipe', p)
        try:
            out, err = p.communicate()
        finally:
            setattr(base_thread, 'active_pipe', None)

        if isinstance(out, bytes):
            out = out.decode()
        if isinstance(err, bytes):
            err = err.decode()

        if self.__log:
            if out is not None:
                print(out)
            if err is not None:
                print(err)

        return p.returncode, out if out is not None else '', err if err is not None else ''

    def __init__(self, stdout=subprocess.PIPE, stderr=subprocess.PIPE, log=False):
        self.__config = {}
        self.__log = log
        self.__stdout = subprocess.PIPE
        self.__stderr = subprocess.PIPE
        self._executable_ = get_hpm()
        self.get_config()
        code, out, _ = self.__exec(cmd=['--version'])
        self.__version = out.strip() if code == 0 else None
        self.__stdout = stdout
        self.__stderr = stderr

    def __del__(self):
        if hasattr(self.__stdout, 'close') and callable(self.__stdout.close):
            self.__stdout.close()
        if hasattr(self.__stderr, 'close') and callable(self.__stderr.close):
            self.__stderr.close()

    @property
    def version(self):
        return self.__version

    @property
    def config(self):
        return self.__config

    def get_config(self):
        self.__config = {}
        code, out, _ = self.__exec(cmd=['config', 'list'], cwd=None)
        if code != 0:
            return False

        for line in out.splitlines():
            if '=' in line and not line.lstrip().startswith('#'):
                key, value = line.split('=')
                self.__config[key.strip()] = value.strip()
        return True

    def __search_data_fetch(self, name, page, per_page, bundle_type):
        arguments = ['search', '--json', '--currentPage', str(page)]
        if per_page is not None:
            arguments.extend(['--pageSize', str(per_page)])
        if bundle_type is not None:
            arguments.extend(['-t', bundle_type])
        if name is not None:
            arguments.append(name)
        code, out, _ = self.__exec(cmd=arguments, cwd=None)
        if code != 0:
            return None
        try:
            return json.loads(out[out.find('['):])
        except json.decoder.JSONDecodeError:
            return []

    def search(self, name=None, page=None, per_page=100, bundle_type=None):
        if page is None:
            result = []
            for page in range(1, sys.maxsize):
                sub = self.__search_data_fetch(name=name, page=page, per_page=per_page, bundle_type=bundle_type)
                if sub is None:
                    return None
                if len(sub) == 0:
                    return result
                elif len(sub) != per_page:
                    return result + sub
                else:
                    result.extend(sub)
            return result
        else:
            if page < 1:
                raise ValueError('Page index should be positive integer')
            return self.__search_data_fetch(name=name, page=page, per_page=per_page, bundle_type=bundle_type)

    def install(self, name, target, dev_dependencies=False):
        arguments = ['install']
        if target is None:
            arguments.append('--global')
        if dev_dependencies:
            arguments.append('--save-dev')
        if name is not None:
            arguments.append(name)
        code, _, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

    def init(self, name=None, dirname=None, template=None):
        arguments = ['init']
        if dirname is not None:
            arguments.extend(['--dirname', dirname])
        if template is not None:
            arguments.extend(['--template', template])
        if name is not None:
            arguments.append(name)
        if name is None and template is None:
            raise ValueError('Invalid arguments: both name and template '
                             'arguments are missing (at least one should '
                             'be specified)')
        code, _, _ = self.__exec(cmd=arguments, cwd=None)
        return code == 0

    def uninstall(self, name, target):
        arguments = ['uninstall']
        if target is None:
            arguments.append('--global')
        code, _, _ = self.__exec(cmd=arguments + [name], cwd=target)
        return code == 0

    def list(self, target, json_output=True, max_deps_level=1):
        # returns a dictionary of {name: version} in success, and None on error
        if target is None:
            target = self.__config.get('globalRepo')
        if target is None:
            return None

        json_support = version.parse(self.version) >= version.parse('1.0.2')
        code, out, _ = self.__exec(cmd=['list', '--json'] if json_support and json_output else ['list'],
                                   cwd=target)

        if code != 0:
            return None

        json_out = {}
        if not json_output or not out:
            return json_out

        if not json_support:  # parse text output
            for line in out.splitlines():
                parts = line.split('@')
                if len(parts) == 3:
                    json_out['@' + parts[1].strip()] = parts[2].strip()
        else:  # parse json output
            def parse(dictionary, level=0):
                if level <= max_deps_level:
                    if 'name' in dictionary and 'version' in dictionary and level != 0:
                        json_out[dictionary['name']] = dictionary['version']
                    if 'dependencies' in dictionary:
                        for i in dictionary['dependencies']:
                            parse(i, level + 1)

            json_start_index = out.find('{')
            if json_start_index >= 0:
                parse(json.loads(out[json_start_index:]))

        return json_out

    def update(self, name, target):
        arguments = ['update']
        if target is None:
            arguments.append('--global')
        if name is not None:
            arguments.append(name)
        code, _, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

    def check_update(self, target):
        arguments = ['check-update', '--json']
        if target is None:
            arguments.append('--global')
        code, out, _ = self.__exec(cmd=arguments, cwd=target)
        if code != 0:
            return None
        try:
            no_need = out and "No dependency needs to be updated" in out
            return [] if no_need else json.loads(out[out.find('['):])
        except json.decoder.JSONDecodeError:
            def handle_invalid_json(string):
                result = []
                for rec in string[string.find('[') + 1:-1].split('}'):
                    j_rec = {}
                    for item in rec.replace('{', '').split(','):
                        key_val = item.split(':')
                        if len(key_val) == 2:
                            j_rec[key_val[0].strip()] = key_val[1].replace("'", "").strip()
                    if j_rec and 'name' in j_rec:
                        result.append(j_rec)
                return result

            return handle_invalid_json(out)

    def dist(self, target, debug=False):
        arguments = ['dist', '-b', 'debug'] if debug else ['dist']
        code, _, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

    def run(self, target, cmd):
        arguments = ['run', cmd]
        code, _, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

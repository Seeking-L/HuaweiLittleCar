#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
Description: hb adapt module
Create: 2021-5-31
"""
import subprocess
import sys
import os
import threading
import json
import platform
import re
from packaging import version


class Hb:
    def __exec(self, cmd, **kwargs):
        if not os.path.isdir(self.__executable):
            return -1, '', 'can not find hb scripts in dir: build/lite'

        cmd = ['python' if 'windows' in platform.system().lower() else 'python3', self.__executable] + cmd
        env = os.environ.copy()
        sys_path = os.environ.get('PATH', '').split(os.pathsep)
        bin_path = os.path.dirname(sys.executable)
        sys_path = [path for path in sys_path if path != bin_path]
        env['PATH'] = os.pathsep.join(sys_path)

        default = dict(stdout=self.__stdout,
                       stderr=self.__stderr,
                       shell=False,
                       env=env)

        kwargs.update(default)
        p = subprocess.Popen(cmd, **kwargs)

        base_thread_id = getattr(threading.current_thread(),
                                 'base_thread', threading.get_ident())
        base_thread = next(x for x in threading.enumerate()
                           if x.ident == base_thread_id)
        setattr(base_thread, 'active_pipe', p)
        try:
            out, err = p.communicate()
        finally:
            setattr(base_thread, 'active_pipe', None)

        if isinstance(out, bytes):
            out = out.decode()
        if isinstance(err, bytes):
            err = err.decode()

        return p.returncode, out if out is not None else '', \
               err if err is not None else ''

    def __init__(self, project_dir, stdout=subprocess.PIPE,
                 stderr=subprocess.PIPE):
        self.__stdout = stdout
        self.__stderr = stderr
        self.__project_dir = project_dir
        self.__executable = self.hb_executable()

    def __del__(self):
        if hasattr(self.__stdout, 'close') and callable(self.__stdout.close):
            self.__stdout.close()
        if hasattr(self.__stderr, 'close') and callable(self.__stderr.close):
            self.__stderr.close()

    def hb_executable(self):
        return os.path.join(self.__project_dir, 'build', 'lite', 'hb')

    def get_environments(self):
        arguments = ['env']
        code, out, _ = self.__exec(cmd=arguments)
        return code == 0

    def setting(self, root_path):
        config_path = os.path.join(root_path, 'ohos_config.json')
        root_info = {'root_path': os.path.realpath(root_path)}
        try:
            data = json.load(open(config_path, 'r'))
        except (json.JSONDecodeError, FileNotFoundError):
            data = {}
        data.update(root_info)
        flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        with os.fdopen(os.open(config_path, flags, 0o640), "w") as fp:
            json.dump(data, fp)

    def build(self, target, product=None, debug=False, patch=False, *args):
        arguments = ['build', '-b', 'debug' if debug else 'release']
        if product:
            arguments += ['-p', product]
        if patch:
            arguments += ['--patch']
        arguments.extend(args)
        code, out, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

    def rebuild(self, target, product=None, debug=False, patch=False, *args, **kwargs):
        arguments = ['build', '-b', 'debug' if debug else 'release']
        if product:
            arguments += ['-p', product]
        arguments += ['-f']
        if patch:
            arguments += ['--patch']
        if 'part' in kwargs.keys():
            arguments += ['-T', kwargs.get('part')]
        arguments.extend(args)
        code, out, _ = self.__exec(cmd=arguments, cwd=target)
        return code == 0

    def clean(self, out_path=None):
        arguments = ['clean']
        if out_path:
            arguments += [out_path]
        code, out, _ = self.__exec(cmd=arguments, cwd=self.__project_dir)
        return code == 0

    def list_products(self):
        product_list = [
            f'{product.get("name")}@{item.get("vendor")}' \
                for item in self.list_products_detail().get("products", []) for product in item.get('product', [])
        ]
        return product_list

    def setting_product(self, product_name=None, company=None): # pylint: disable=no-self-use
        try:
            out = subprocess.check_output(['python', 'build/lite/hb', '--version'],
                                          cwd=self.__project_dir, stderr=subprocess.DEVNULL)
            if isinstance(out, bytes):
                out = out.decode()
            pattern = r'\d{1,3}\.\d{1,3}\.{0,1}\d{0,3}'
            vision_list = re.findall(pattern, out)
            if vision_list:
                if version.parse(vision_list[0]) < version.parse('0.4.6'):
                    sys.path.append(self.hb_executable())
                    from hb.set.set import set_product # pylint: disable=import-error, no-name-in-module
                    code = set_product(product_name, company)
                    return code
                else:
                    cp = subprocess.run(['python', 'build/lite/hb', 'set', '-p', product_name],
                                        cwd=self.__project_dir)
                    return cp.returncode
            return 1
        except subprocess.SubprocessError:
            return 1
        except Exception:
            return 1

    def list_products_detail(self):
        vendor_path = os.path.join(self.__project_dir, 'vendor')
        built_in_product_path = os.path.join(self.__project_dir, 'productdefine', 'common', 'products')
        correct, configed_product = self._get_configed_product()
        config_name, config_vendor = configed_product.split('@') if correct else ('', '')
        products_info = []
        products_vendor_info, default_vendor_product = Hb._get_vendor_products(
            vendor_path, config_name, config_vendor)

        products_info.extend(products_vendor_info)

        products_builtin_info, default_builtin_product = Hb._get_builtin_products(
            built_in_product_path, config_name, config_vendor)

        products_info.extend(products_builtin_info)

        return {
            'products': products_info,
            'default': default_vendor_product or default_builtin_product or {}
        }

    @staticmethod
    def _get_vendor_products(vendor_path, config_name, config_vendor):
        if os.path.isdir(vendor_path):
            return Hb._handle_vendor_product_info(
                vendor_path,
                config_name,
                config_vendor)
        return [], {}

    @staticmethod
    def _handle_vendor_product_info(
            vendor_path,
            config_name,
            config_vendor):
        configed_product_info = {}
        products_vendor_info = []
        for company in os.listdir(vendor_path):
            company_path = os.path.join(vendor_path, company)
            if not os.path.isdir(company_path):
                continue
            products_info_company = {'vendor': company, 'product': []}

            for product in os.listdir(company_path):
                product_path = os.path.join(company_path, product)
                config_path = os.path.join(product_path, 'config.json')
                if not os.path.isfile(config_path):
                    continue
                info = Hb._read_json_file(config_path)
                products_info_product = {'name': info.get('product_name'), 'board': info.get('board', ''),
                                         'type': info.get('type', 'mini'), 'company': company,
                                         'kernel': info.get('kernel_type',
                                                            'linux' if info.get('type', 'mini') == 'standard' else ''),
                                         'product_path': product_path}
                if config_name == info.get('product_name') and config_vendor == company:
                    configed_product_info = {
                        'vendor': config_vendor,
                        'product': [products_info_product]
                    }

                if products_info_product['name'] != "ipcamera_hispark_aries":
                    products_info_company['product'].append(products_info_product)

            if products_info_company['product']:
                products_vendor_info.append(products_info_company)
        return products_vendor_info, configed_product_info

    @staticmethod
    def _get_builtin_products(built_in_product_path, config_name, config_vendor):
        configed_product_info = {}
        products_builtin_info = []
        products_info_company = {'vendor': 'built-in', 'product': []}
        if os.path.isdir(built_in_product_path):
            for item in os.listdir(built_in_product_path):
                product_name = item[0:-len('.json')] if item.endswith('.json') else item
                config_path = os.path.join(built_in_product_path, item)
                if not os.path.isfile(config_path):
                    continue
                info = Hb._read_json_file(config_path)
                products_info_product = {}
                products_info_product['name'] = product_name
                products_info_product['board'] = info.get('product_device', '')
                products_info_product['type'] = info.get('type', 'standard')
                products_info_product['company'] = info.get('product_company', '')
                products_info_product['kernel'] = 'linux'
                products_info_product['product_path'] = built_in_product_path
                if config_name == product_name and config_vendor == 'built-in':
                    configed_product_info = {
                            'vendor': config_vendor,
                            'product': [products_info_product]
                    }
                products_info_company['product'].append(products_info_product)

        if products_info_company['product']:
            products_builtin_info.append(products_info_company)

        return products_builtin_info, configed_product_info

    def _get_configed_product(self):
        config_file = os.path.join(self.__project_dir, 'ohos_config.json')
        if os.path.isfile(config_file):
            info = Hb._read_json_file(config_file)
            root_path = info.get('root_path', '')
            product_path = info.get('product_path', '')
            device_path = info.get('device_path', '')
            product_name = info.get('product', '')
            device_company = info.get('device_company', '')

            if not (root_path and product_path and device_path):
                return False, ''

            root_path_is_valid = os.path.isdir(root_path)
            product_path_is_valid = os.path.isdir(product_path)
            device_path_is_valid = os.path.isdir(device_path)
            root_path_is_correct = \
                root_path[0:min(len(config_file), len(root_path))] == \
                config_file[0:min(len(config_file), len(root_path))]

            root_path_is_ok = root_path_is_valid and root_path_is_correct
            if root_path_is_ok and product_path_is_valid and device_path_is_valid:
                if product_path.endswith(os.sep.join(['productdefine', 'common', 'products'])):
                    product = f'{product_name}@built-in'
                else:
                    vendor = product_path.split(os.sep)[-2]
                    product = f'{product_name}@{device_company if device_company else vendor}'
                return True, product
        return False, ''

    @staticmethod
    def _read_json_file(input_file):
        if not os.path.isfile(input_file):
            raise FileNotFoundError(f'{input_file} not found')
        with open(input_file, 'rb') as input_f:
            try:
                data = json.load(input_f)
                return data
            except json.JSONDecodeError as e:
                raise Exception(f'{input_file} parsing error!') from e

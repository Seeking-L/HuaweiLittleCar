class FuncStack:
    # Method Stack Instance Count
    funcstack_count = 0
    # Dictionary, key is address, and value is method stack instance
    addr_funcstack_dict = {}

    def __init__(self, func_addr, func_name):
        # function address
        self.func_addr = func_addr
        # function name
        self.func_name = func_name
        # Statistics on local variables and stacking in the function
        self.local_size = 0
        # Maximum stack size statistics, including the call function stack
        self.max_size = 0
        # 0: not called; 1: called
        self.is_called = 0
        #0: not recursive ; 1: recursive
        self.is_rec = 0
        # function called Depth
        self.depth = 0
        # call Submethod Collection
        self.callee_func_addr = set()
        # Code segment and line number corresponding to the function
        self.src_location = ""
        # Function Pointer Variable
        self.ptr_var_list = list()
        # Source code location corresponding to function pointer invocation
        self.ptr_src_location = list()
        FuncStack.funcstack_count += 1
        FuncStack.addr_funcstack_dict[func_addr] = self

    def __del__(self):
        self.funcstack_count -= 1
        if self.func_addr in self.addr_funcstack_dict:
            del self.addr_funcstack_dict[self.func_addr]

    def display_funcstack_count(self):
        print("Total FuncStack %d" % self.funcstack_count)

    def display_funcstack(self):
        print("func_name : %s, func_addr: %s, local_size: %d, \
            max_size: %d, is_called: %d, is_rec: %d" \
              % (self.func_name, self.func_addr, self.local_size, \
                 self.max_size, self.is_called, self.is_rec))

    @classmethod
    def add_callee_func_addr_by_addr(cls, caller_addr, callee_addr):
        if caller_addr in cls.addr_funcstack_dict and callee_addr in cls.addr_funcstack_dict:
            cls.addr_funcstack_dict[caller_addr].callee_func_addr.add(callee_addr)

    @classmethod
    def find_funcstack_by_name(cls, func_name):
        ret = list()
        func_symbol = "<" + func_name + ">:"
        for _, funcstack in cls.addr_funcstack_dict.items():
            if funcstack.func_name == func_symbol:
                ret.append(funcstack.func_addr)
        return ret

    @classmethod
    def display_all_funcstack(cls):
        for addr, funcstack in cls.addr_funcstack_dict.items():
            if funcstack.is_called == 0:
                print("func_name : %s, func_addr: %s, \
                    funcLocalSize: %d, funcMaxSize: %d, \
                    funcIsCalled: %d, funcIsRec: %d" \
                      % (funcstack.func_name, addr, \
                         funcstack.local_size, funcstack.max_size, \
                         funcstack.is_called, funcstack.is_rec))
        print("Total function count: %d" % cls.funcstack_count)

    @classmethod
    def display_all_funcstack_callee(cls):
        for func_addr, funcstack in cls.addr_funcstack_dict.items():
            if funcstack.is_called == 0:
                print("function : %s, func_addr: %s callee_func:" \
                      % (funcstack.func_name, func_addr))
            for addr in funcstack.callee_func_addr:
                callee_func = cls.addr_funcstack_dict[addr]
                print("    %s, %s ;" % (addr, callee_func.func_name))

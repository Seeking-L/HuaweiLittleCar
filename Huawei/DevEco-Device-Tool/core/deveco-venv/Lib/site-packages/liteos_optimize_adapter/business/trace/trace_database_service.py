#!/user/bin/env python3
#coding=utf-8

import json
import sqlite3
import os
import shutil

from enum import Enum
OUT_PATH = os.path.join('traceData', 'trace_event_lite.db')
OUT_PATH_TMP = os.path.join('traceData', 'trace_event_lite_tmp.db')


class DataType(Enum):
    Timeline = 0
    TraceLiteEvent = 1
    CpuUsage = 2
    MemoryUsage = 3
    TaskList = 4
    CpuId = 5
    MemPool = 6


class TraceDatabaseService():

    def __init__(self):
        self.database_path = ''
        self.database_path_tmp = ''
        self.database = None
        self.database_cursor = None
        self.database_tmp = None
        self.database_cursor_tmp = None
        self.out_path = ''

    def reset_database(self, db_path=None):
        """Initializing the Database"""
        if db_path is None:
            self.database_path = os.path.join(os.path.abspath('.'), OUT_PATH)
            self.database_path_tmp = os.path.join(os.path.abspath('.'), OUT_PATH_TMP)
        else:
            self.database_path = db_path
            dir_path = os.path.dirname(db_path)
            self.database_path_tmp = os.path.join(dir_path, 'trace_event_lite_tmp.db')

        folder = os.path.abspath(os.path.dirname(self.database_path))
        if not os.path.exists(folder):
            os.makedirs(folder)
        self.close_database()
        self.create_database()
        self.database = sqlite3.connect(self.database_path)
        self.database_cursor = self.database.cursor()
        self.create_tables()

    def close_database(self):
        if self.database is not None:
            try:
                self.database.close()
                self.database = None
            except Exception as e:
                print('close database failed')
                raise Exception() from e

    def close_tmp_database(self):
        if self.database_tmp is not None:
            try:
                self.database_tmp.close()
            except Exception:
                return False
            else:
                self.database_tmp = None
                return True
        return True

    def create_database(self):
        if os.path.exists(self.database_path):
            self.close_database()
            try:
                os.remove(self.database_path)
            except Exception as e:
                print(f'The file is occupied {self.database_path}')
                raise Exception() from e

        open(self.database_path, mode='w', encoding='utf-8')
        print('the database file is created successfully')

    def create_tmp_database(self):
        ret = True
        try:
            with open(os.path.join(self.database_path_tmp), mode='w+', encoding='utf-8') as ff:
                ret = True
        except FileNotFoundError:
            ret = False
        return ret

    def init(self):
        self.database_tmp = sqlite3.connect(self.database_path_tmp)
        self.database_cursor_tmp = self.database_tmp.cursor()
        self.create_tables(True)

    def create_tables(self, is_tmp=False):
        if is_tmp:
            database = self.database_tmp
            cursor = self.database_cursor_tmp
        else:
            database = self.database
            cursor = self.database_cursor
        sql_table = 'create table if not exists TraceLiteEvent(timestamp double, timestampOri double,' \
                    'cpuid integer,datatype integer, eventCount integer,eventType text,identity text,itemstring text)'
        sql_table_line = 'create table if not exists Timeline(timestamp double, cpuid integer,datatype integer,' \
                        'itemstring text)'
        sql_table_cpu = 'create table if not exists CpuUsage(timestamp double, cpuid integer,datatype integer,' \
                        ' itemstring text)'
        sql_table_heap = 'create table if not exists MemoryUsage(timestamp double, datatype integer, pool text,' \
                         'itemstring text)'
        sql_table_tasklist = 'create table if not exists TaskList(timestamp double, cpuid integer,datatype integer,' \
                             'itemstring text)'
        sql_table_cpuid = 'create table if not exists CpuId(timestamp double, datatype integer, cpuid integer,' \
                          'itemstring text)'
        sql_table_memPool = 'create table if not exists MemPool(timestamp double, datatype integer, memPool text,' \
                            'itemstring text)'
        sql_list = [sql_table, sql_table_line, sql_table_cpu, sql_table_heap, sql_table_tasklist, 
                    sql_table_cpuid, sql_table_memPool]
        for sql in sql_list:
            cursor.execute(sql)
        database.commit()

    def get_data_by_index(self, data_type, start_index, end_index, condition):
        """Return data by line number range"""
        table_name = DataType(data_type).name
        if start_index == 0 and end_index == 0:
            data_count = self.get_table_size(data_type, condition)
            end_index = data_count.get("count")
        if condition:
            count = end_index - start_index
            sql = f'select * from {table_name} {condition.get("cond", "")} limit ?,?'
            parames = condition.get("parames", [])
            parameters = parames + [start_index, count]
            if self.database is None:
                raise Exception("database id not opened!")
            ret = {
                'type': data_type,
                'startTime': 0,
                'endTime': 0,
                'items': []
            }
            self.database_cursor.execute(sql, parameters)
            row = self.database_cursor.fetchall()
            for r in row:
                ret["items"].append(json.loads(r[-1]))
            return ret

        sql = f'select * from {table_name} where rowid > ? and rowid <= ?'
        parameters = [start_index, end_index]
        return self.get_data_from_table(sql, parameters, data_type)

    def get_table_size(self, data_type, condition=None):
        """Returns the size of the data table."""
        table_name = DataType(data_type).name
        sql = 'SELECT MIN(rowid) as min_row, MAX(rowid) as max_row, MAX(timestamp) as max_timestamp,' \
            f'MIN(timestamp) as min_timestamp,COUNT(*) as count FROM {table_name}'
        if not self.database:
            raise Exception("database is not opened!")
        if condition:
            sql = f'{sql} where {condition.get("cond", "")}'
            parames = condition.get("parames", [])
            self.database_cursor.execute(sql, parames)
        else:
            self.database_cursor.execute(sql)

        res_list = self.database_cursor.fetchall()
        res = {}
        for idx, tuple_data in enumerate(self.database_cursor.description):
            res[tuple_data[0]] = res_list[0][idx]
        return res
 
    def get_data_from_table(self, sql, parameters, data_type):
        ret = {
            'type': data_type,
            'start_time': 0,
            'end_time': 0,
            'items': []
        }
        if self.database is None:
            raise Exception("database is not opened!")
        self.database_cursor.execute(sql, parameters)
        row = self.database_cursor.fetchall()
        for r in row:
            ret["items"].append(json.loads(r[-1]))
        ret["start_time"] = ret.get("items")[0].get('timestamp')
        ret["end_time"] = ret.get("items")[len(row) - 1].get('timestamp')
        return ret

    def insert_trace_data_to_database(self, sql_insert):
        if self.database_tmp is None:
            return False
        database_tmp_cursor = self.database_tmp.cursor()
        for item in sql_insert:
            database_tmp_cursor.execute(item.get('sql'), item.get('data'))
        self.database_tmp.commit()
        return True

    def save_data(self, from_path, to_path):
        if not from_path:
            from_path = self.database_path
        self.close_database()
        if to_path == self.database_path:
            with open(os.path.join(self.database_path), mode='w', encoding='utf-8') as ff:
                shutil.copy(from_path, to_path)
                if os.path.isfile(to_path):
                    return True
                else:
                    return False
        return False

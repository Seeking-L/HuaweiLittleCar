import re

from liteos_optimize_adapter.business.stack.stackusage.src.func_stack import FuncStack

HEX_2BYTE_RULE = re.compile("([0-9a-fA-F]{4})")
HEX_COLON_RULE = re.compile("[0-9a-fA-F]+")
SYMBOL_RULE = re.compile("<([\._@a-zA-Z]+[\._0-9a-zA-Z]*)>:")
JUMP_SYMBOL_RULE = re.compile("<([\._@a-zA-Z][\._0-9a-zA-Z]*)>")
INS_RULE = re.compile("([a-zA-Z][\.a-zA-Z]*)")
SRC_LINE_RULE = re.compile(".+/(.+)$")
REG_RULE = re.compile("[a-zA-Z][0-9a-zA-Z][0-9]?")


def arm_read_asm_file(filename, analyze_mode):
    """Parse the source code file and line number in the asm file. If the function is enabled, 
    add the -g option during compilation and add the -Sld option during disassembly.
    analyze_mode 0: disabled; 1: enabled
    """
    with open(filename, 'r', encoding='utf8', errors='ignore') as asmfile:
        count = 0
        is_first_match = True
        record_src_location_flag = False
        is_text_section = False
        prevline = ''
        cur_funcstack = None
        for line in asmfile.readlines():
            str_list = line.strip().split()
            if len(str_list) == 0:
                continue

            is_src = analyze_mode > 0 and record_src_location_flag and cur_funcstack
            match = SRC_LINE_RULE.match(str_list[0])
            if len(str_list) == 1 and is_src and match:
                cur_funcstack.src_location = re.split(r'/|\\', match.group(0))[-1]
                record_src_location_flag = False
            if len(str_list) == 1:
                prevline = line
                continue

            if line.startswith("Disassembly of section"):
                is_text_section = "text" in str_list[-1]
            if not is_text_section:
                continue

            match = HEX_COLON_RULE.match(str_list[0])
            if not match:
                continue

            cur_func_address = int(match.group(0), 16)
            # see if this is a symbol declaration
            match = SYMBOL_RULE.match(str_list[1])
            if match:
                is_first_match = set_local_size(is_first_match, cur_funcstack, count)
                count = 0
                cur_funcstack = FuncStack(hex(cur_func_address), str_list[1])
                record_src_location_flag = True
                continue

            match = HEX_2BYTE_RULE.match(str_list[1])
            if not match:
                continue
            record_src_location_flag = False
            stack_info = dict(line=line, str_list=str_list, cur_funcstack=cur_funcstack,
                count=count, analyze_mode=analyze_mode, prevline=prevline)
            count = set_func_stack(stack_info)

        if count > 0:
            cur_funcstack.local_size = count


def set_local_size(first_match, cur_funcstack, count):
    if first_match:
        first_match = False
    else:
        cur_funcstack.local_size = count
    return first_match


def set_func_stack(stack_info):
    line = stack_info.get('line')
    str_list = stack_info.get('str_list')
    cur_funcstack = stack_info.get('cur_funcstack')
    count = stack_info.get('count')
    analyze_mode = stack_info.get('analyze_mode')
    prevline = stack_info.get('prevline')
    try:
        str_index = 3 if HEX_2BYTE_RULE.match(str_list[2]) else 2

        # match the instruction string
        ins_match = INS_RULE.match(str_list[str_index])
        if not ins_match:
            return count
        ins = ins_match.group(1)

        # look for a few special instructions
        if ins == "push":
            length = len(line.split(";")[0].split())
            c_byte = (length - 1 - str_index) * 4
            count += c_byte

        if "stm" in ins:
            c_byte = (len(str_list) - 2 - str_index) * 4
            count += c_byte

        if ins == "sub":
            dest = str_list[str_index + 1]
            src = str_list[str_index + 2]
            const_str = str_list[-1]
            if src == "sp," or dest == "sp,":
                c_byte = int(const_str, 16) if "0x" in const_str else int(const_str.strip('#'))
                count += c_byte

        if ins in ["bl", "b", "beq", "bne"]:
            callee_func_addr = str_list[str_index + 1]
            jump_symbol = str_list[str_index + 2]
            match = JUMP_SYMBOL_RULE.match(jump_symbol)
            if match:
                callee_func_addr = "0x%s" % callee_func_addr
                cur_funcstack.callee_func_addr.add(callee_func_addr)

        if ins == "blx":
            match = REG_RULE.match(str_list[str_index + 1])
            if len(str_list) == str_index + 2 and match:
                set_analyze_data(analyze_mode, cur_funcstack, prevline)

    except IndexError:
        print('arm read asm indexError')
    except Exception as e:
        print('arm read asm file error')
        raise Exception() from e

    return count


def set_analyze_data(analyze_mode, cur_funcstack, prevline):
    if analyze_mode == 0:
        cur_funcstack.ptr_src_location.append('...')
    else:
        match = SRC_LINE_RULE.match(prevline)
        if match:
            cur_funcstack.ptr_src_location.append(re.split(r'/|\\', prevline)[-1])
        else:
            cur_funcstack.ptr_src_location.append('...')

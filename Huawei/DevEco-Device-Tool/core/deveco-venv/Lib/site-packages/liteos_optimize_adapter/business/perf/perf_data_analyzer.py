#!/usr/bin/env python3
# coding=utf-8
import os
import re
from enum import Enum
from os.path import join, isdir, abspath, exists, normpath

import click
from liteos_optimize_adapter.business.perf.perf_handle_data import PerfHandleData
from liteos_optimize_adapter.util.common_utils import CommonUtils

ELF_SYMBOL_RULE = r'^[0-9a-zA-Z]{8}'
ASSEMBLE_SYMBOL_RULE = r'<([._@a-zA-Z]+[._0-9a-zA-Z]*)>:'
HEAD_MAGIC = 0xefefef00


class PerSampleType(Enum):
    PERF_RECORD_CPU = 1 << 0
    PERF_RECORD_TID = 1 << 1
    PERF_RECORD_TYPE = 1 << 2
    PERF_RECORD_PERIOD = 1 << 3
    PERF_RECORD_TIMESTAMP = 1 << 4
    PERF_RECORD_IP = 1 << 5
    PERF_RECORD_CALLCHAIN = 1 << 6
    PERF_RECORD_PID = 1 << 7


class PerfDataAnalyzer:
    _rootfs_path = ''
    _elf_path = ''
    _perf_path = ''
    _compiler_path = ''
    _prefix = 'arm-none-eabi'
    _environment = ''
    _addr2line_path = ''
    _obj_dump_path = ''
    is_head = False
    per_data = {}
    func_dic = {}
    file_paths = set()
    sample_count = 0
    event_count = {}
    head_info = {
        'magic': 0,
        'eventType': 0,
        'len': 0,
        'sampleType': 0,
        'sectionId': 0
    }

    def __init__(self):
        self._root_dir = join(abspath('.'), 'analyzerJson')
        if not isdir(self._root_dir):
            os.mkdir(self._root_dir)
        self._json_path = join(self._root_dir, 'perf.json')

    def do_perf_analysis(self, paths):
        try:
            click.echo('++++++++++start perfAnalyzer++++++++++')
            data = CommonUtils.get_prefix(paths['compiler_path'])
            paths.update(data)
            click.echo(paths)
            if paths['elf_path']:
                self._elf_path = paths['elf_path']
            if paths['perf_path']:
                self._perf_path = paths['perf_path']
            if paths['compiler_path']:
                self._compiler_path = paths['compiler_path']
            if paths['rootfs_path']:
                self._rootfs_path = paths['rootfs_path']

            self._prefix = paths['prefix']
            self._environment = paths['environment']

            addr2line_suffix = self._prefix + '-addr2line.exe'
            obj_dump_suffix = self._prefix + '-objdump.exe'
            if self._environment == 'linux':
                addr2line_suffix = self._prefix + '-addr2line'
                obj_dump_suffix = self._prefix + '-objdump'

            self._addr2line_path = join(self._compiler_path, addr2line_suffix)
            self._obj_dump_path = join(self._compiler_path, obj_dump_suffix)
            CommonUtils.get_symbol_data(self._obj_dump_path, self._elf_path)
            json_obj = self._read_perf_data(self._perf_path)
            PerfHandleData(self._json_path, json_obj)
            click.echo('++++++++++end perfAnalyzer++++++++++')
        except Exception as e:
            raise Exception('perfAnalyzer error') from e

    def _parse_func_dic(self, elf_file_path):
        if elf_file_path in self.file_paths:
            return
        else:
            self.file_paths.add(elf_file_path)
        if not self._obj_dump_path or not exists(self._obj_dump_path):
            print(f'objdump path not find: {self._obj_dump_path}')
            raise FileExistsError()
        try:
            data = CommonUtils.get_obj_dump_info(self._obj_dump_path, '-d', elf_file_path, False)
            result = data[0].split('\n')
            for _, item in enumerate(result):
                line = re.sub(r'\s+', ' ', item)
                if re.search(ASSEMBLE_SYMBOL_RULE, line):
                    index1 = line.find('<')
                    index2 = line.find('>')
                    func_name = line[index1 + 1:index2]
                    func_addr = line[0: index1 - 1]
                    self.func_dic[func_name] = func_addr
        except SystemError as e:
            print('parse elf file error')
            raise SystemError() from e

    def _read_perf_data(self, perf_path):
        with open(perf_path, 'rb') as f:
            temp_buf = f.read().strip().replace(b'\r\n', b'')
            string_buf = temp_buf.decode(errors='ignore').replace(' ', '')
            if string_buf[0:2].isdigit():
                strs = ''.join(string_buf).replace(' ', '')
                try:
                    temp_buf = bytes.fromhex(strs)
                except Exception as e:
                    print('The format of the perf data file content is incorrect')
                    raise Exception() from e
            self._read_buf_data(temp_buf)
            json_obj = {
                'sampleCount': self.sample_count,
                'eventCount': self.event_count,
                'eventData': self.per_data
            }
            return json_obj

    def _read_buf_data(self, temp_buf):
        while len(temp_buf) > 3:
            if not self.is_head:
                init_event = CommonUtils.read_uint32_le(temp_buf)
                if init_event == HEAD_MAGIC:
                    self.is_head = True
                    head_buf = temp_buf[0: 20]
                    self._parse_head(head_buf)
                    temp_buf = temp_buf[20:]
                else:
                    temp_buf = temp_buf[1:]
            else:
                init_event = CommonUtils.read_uint32_le(temp_buf)
                if init_event == HEAD_MAGIC:
                    head_buf = temp_buf[0: 20]
                    self._parse_head(head_buf)
                    temp_buf = temp_buf[20:]
                else:
                    temp_buf = self._parse_event_data(temp_buf)

    def _parse_event_data(self, buf):
        buf_slice = buf[0:]
        section_id = self.head_info['sectionId']
        cur_cpu = '0'
        pc_addr = ''
        if not (section_id in self.per_data):
            self.per_data[section_id] = {}

        if (PerSampleType['PERF_RECORD_CPU'].value & self.head_info['sampleType']) > 0:
            cpu = buf_slice[0:4]
            cur_cpu = hex(CommonUtils.read_uint32_le(cpu))
            buf_slice = buf_slice[4:]

        if not (cur_cpu in self.per_data[section_id]):
            self.per_data[section_id][cur_cpu] = {}

        if (PerSampleType['PERF_RECORD_TID'].value & self.head_info['sampleType']) > 0:
            buf_slice = buf_slice[4:]

        if (PerSampleType['PERF_RECORD_PID'].value & self.head_info['sampleType']) > 0:
            buf_slice = buf_slice[4:]

        if (PerSampleType['PERF_RECORD_TYPE'].value & self.head_info['sampleType']) > 0:
            buf_slice = buf_slice[4:]

        if (PerSampleType['PERF_RECORD_PERIOD'].value & self.head_info['sampleType']) > 0:
            buf_slice = buf_slice[4:]

        if (PerSampleType['PERF_RECORD_TIMESTAMP'].value & self.head_info['sampleType']) > 0:
            buf_slice = buf_slice[8:]

        if (PerSampleType['PERF_RECORD_IP'].value & self.head_info['sampleType']) > 0:
            buf_slice, pc_addr = self._get_recor_ip_data(buf_slice, section_id, cur_cpu)

        if (PerSampleType['PERF_RECORD_CALLCHAIN'].value & self.head_info['sampleType']) > 0:
            if len(buf_slice) != 0:
                buf_slice = self._get_recor_callchain_data(buf_slice, pc_addr, section_id, cur_cpu)

        self.event_count[self.head_info['sectionId']] += 1
        return buf_slice

    def _get_recor_ip_data(self, buf_slice, section_id, cur_cpu):
        pc = buf_slice[0:4]
        value = hex(CommonUtils.read_uint32_le(pc))
        path_len = CommonUtils.read_uint32_le(buf_slice[4:8])
        if path_len > len(buf_slice):
            print('The perf data contains incorrect data')
            raise Exception()
        file_name = buf_slice[8: 8 + path_len].replace(b'\x00', b' ').strip().decode(errors='ignore')
        fun_information = {}

        if file_name == 'kernel':
            file_path = self._elf_path
            fun_information = CommonUtils.get_function_name(value)
        else:
            file_path = normpath(self._rootfs_path + normpath(file_name))
            self._parse_func_dic(file_path)
            fun_information = self._get_function_name(value, file_path)

        func_name = fun_information['funcname']
        pc_addr = fun_information['funcaddr']
        if pc_addr in self.per_data[section_id][cur_cpu]:
            self.per_data[section_id][cur_cpu][pc_addr]['calledTimes'] += 1
            self.per_data[section_id][cur_cpu][pc_addr]['backTraceTimes'] += 1
        else:
            self.per_data[section_id][cur_cpu][pc_addr] = {
                'funcaddr': pc_addr,
                'funcname': func_name,
                'filepath': file_name,
                'calledTimes': 1,
                'isCalled': 0,
                'called': {},
                'backTraceTimes': 1,
                'level': 0
            }
        buf_slice = buf_slice[8 + path_len:]
        return buf_slice, pc_addr

    def _get_recor_callchain_data(self, buf_slice, pc_addr, section_id, cur_cpu):
        level = CommonUtils.read_uint32_le(buf_slice[0:4])
        buf_slice = buf_slice[4:]
        last_called_addr = pc_addr
        for i in range(level):
            value = hex(CommonUtils.read_uint32_le(buf_slice[0:4]))
            path_len = CommonUtils.read_uint32_le(buf_slice[4:8])
            if path_len > len(buf_slice):
                print('The perf data contains incorrect data')
                raise Exception()
            file_name = buf_slice[8: 8 + path_len].replace(b'\x00', b' ').strip().decode(errors='ignore')
            fun_information = {}

            if file_name == 'kernel':
                file_path = self._elf_path
                fun_information = CommonUtils.get_function_name(value)
            else:
                file_path = normpath(self._rootfs_path + normpath(file_name))
                self._parse_func_dic(file_path)
                fun_information = self._get_function_name(value, file_path)

            func_name = fun_information['funcname']
            addr = fun_information['funcaddr']

            if addr not in self.per_data[section_id][cur_cpu]:
                self.per_data[section_id][cur_cpu][addr] = {
                    'funcaddr': addr,
                    'funcname': func_name,
                    'filepath': file_name,
                    'calledTimes': 0,
                    'isCalled': 0,
                    'called': {},
                    'backTraceTimes': 0,
                    'level': i + 1
                }
            if addr != last_called_addr:
                self.per_data[section_id][cur_cpu][last_called_addr]['isCalled'] = 1
                self.per_data[section_id][cur_cpu][addr]['backTraceTimes'] += 1
                if addr in self.per_data[section_id][cur_cpu][last_called_addr]['called']:
                    self.per_data[section_id][cur_cpu][last_called_addr]['called'][addr] += 1
                else:
                    self.per_data[section_id][cur_cpu][last_called_addr]['called'][addr] = 1
            last_called_addr = addr
            buf_slice = buf_slice[8 + path_len:]
        return buf_slice

    def _get_function_name(self, addr, file_path):
        if not self._addr2line_path or not exists(self._addr2line_path):
            return {
                'funcname': '',
                'funcaddr': ''
            }
        cmd = []
        if file_path != self._elf_path:
            cmd = [self._addr2line_path, '-C', '-f', '-e', file_path, addr]
        else:
            cmd = [self._addr2line_path, '-f', addr, '-e', file_path]
        result = CommonUtils.exec_cmd(cmd).strip().split('\n')
        if not self.func_dic.get(result[0], False):
            return {
                'funcname': '',
                'funcaddr': ''
            }
        return {
            'funcname': result[0],
            'funcaddr': '0x%08x' % int(self.func_dic.get(result[0], ''), 16)
        }

    def _parse_head(self, buf):
        self.head_info['magic'] = CommonUtils.read_uint32_le(buf)
        self.head_info['eventType'] = CommonUtils.read_uint32_le(buf, 4)
        self.head_info['len'] = CommonUtils.read_uint32_le(buf, 8)
        self.head_info['sampleType'] = CommonUtils.read_uint32_le(buf, 12)
        self.head_info['sectionId'] = CommonUtils.read_uint32_le(buf, 16)
        self.sample_count += 1
        self.event_count[self.head_info['sectionId']] = 0

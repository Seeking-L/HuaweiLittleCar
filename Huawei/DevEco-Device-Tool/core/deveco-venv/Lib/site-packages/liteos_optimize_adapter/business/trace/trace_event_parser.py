#!/user/bin/env python3
# coding=utf-8

from enum import Enum

from liteos_optimize_adapter.business.trace.event_codes_config_parser import LOS_TRACE_TYPE
from liteos_optimize_adapter.util.trace_utils import (read_uint32_le)

LOS_WAITMODE_AND = 4
LOS_WAITMODE_OR = 2
LOS_WAITMODE_CLR = 1

OS_TASK_STATUS_SUSPEND = 0x0002
OS_TASK_STATUS_READY = 0x0004
OS_TASK_STATUS_PEND = 0x0008
OS_TASK_STATUS_RUNNING = 0x0010
OS_TASK_STATUS_DELAY = 0x0020
OS_TASK_STATUS_PEND_TIME = 0x0080

LOS_WAIT_FOREVER_VALUE = 4294967295


class En_Sw_Tmr_Type(Enum):
    LOS_SWTMR_MODE_ONCE = 0
    LOS_SWTMR_MODE_PERIOD = 1
    LOS_SWTMR_MODE_NO_SELFDELETE = 2
    LOS_SWTMR_MODE_OPP = 3


class TraceEventParser():

    def __init__(self, trace_header, data_writer, code_parser):
        self.__muem_used = {}
        self.trace_header = trace_header
        self.trace_data_writer = data_writer
        self.trace_code_parser = code_parser

    def parse_trace_events(self, trace_events):
        while (len(trace_events) > 0):
            trace_event = trace_events.pop(0)
            if trace_event is not None:
                event_log_dict = self.parse_default(trace_event)
                self.trace_data_writer.insert_trace_event_data([event_log_dict])

    def parse_default(self, trace_event):
        # Reads the configuration file based on the event code, parses the event data into user-readable data, 
        # and saves the data to the database.
        event_log_dict = {
            'code': '',
            'cpuid': '',
            'timestamp': '',
            'eventCount': '',
            'eventType': '',
            'Actor': '',
            'EventText': '',
            'ActorAddr': '',
            'ActorPrio': '',
            'heapUsed': '',
            'heapFree': '',
            'identity': ''
        }
        code_config_dict = self.trace_code_parser.get_by_event_code(trace_event['event_code'])
        if code_config_dict is None:
            code_config_dict = {
                'Param': [],
                'code': trace_event['event_code'],
                'service': 'Unknown/Unknown event',
                'template': 'Unknown event, Event Code ' + trace_event['event_code'] + ':'
            }
        elif len(code_config_dict['Param']) == 0:
            code_config_dict['template'] = 'User-defined event, ' + 'Event Code ' + trace_event['event_code'] + ':'

        event_log_dict['code'] = trace_event['event_code']
        event_log_dict['cpuid'] = trace_event['cpuId']
        event_log_dict['eventCount'] = trace_event['event_count']
        event_log_dict['timestampOri'] = str(trace_event['event_ts'])
        if self.trace_header.timestamp_frequency is not None:
            try:
                event_log_dict['timestampOri'] = str(
                    trace_event['event_ts'] * 1000000 / self.trace_header.timestamp_frequency
                )
            except ZeroDivisionError:
                pass
        event_log_dict['timestamp'] = str(float(event_log_dict['timestampOri']) / 1000000.0)
        event_log_dict['timestampOri'] = trace_event['time']
        event_log_dict['Actor'] = self.get_object_name(trace_event['event_curTask'])
        if trace_event['hwiActive'] != '0' and trace_event['hwiActive']:
            event_log_dict['Actor'] = 'Interrupt'
        event_log_dict['eventType'] = code_config_dict['service'].split('/')[0]
        self.parse_param(trace_event, code_config_dict, event_log_dict)
        event_log_dict['ActorAddr'] = '0xfffffff' if event_log_dict['Actor'] == 'Interrupt' else trace_event[
            'event_curTask']
        event_log_dict['ActorPrio'] = self.get_object_pri(trace_event['event_curTask'])
        return event_log_dict

    def parse_param(self, trace_event, code_config_dict, event_log_dict):
        template = code_config_dict["template"]
        param_list = code_config_dict["Param"]
        param0_len = len(trace_event['param0'])
        param_count = int(trace_event.get('param_count', '0'))
        if param_list and param_count != 0:
            param_array = []
            param_res = []
            if isinstance(param_list, list):
                param_array = param_array + param_list
                template = self.set_param_array(param_list, param_array, param_count, template)
            else:
                if param_count < 1:
                    print("ERROR param_count<1")
                    event_log_dict['EventText'] = template
                    return
                param_array.append(param_list)

            param_bytes = trace_event['param_bytes']
            event_code = trace_event['event_code']
            param_event = dict(param_bytes=param_bytes, param0_len=param0_len,
                               event_code=event_code, event_curTask=trace_event['event_curTask'])
            self.set_param_res(param_res, param_array, event_log_dict, param_event)

            self.set_event_log_dict(param_res, event_log_dict, param_event)
            event_log_dict['EventText'] = self.format(template, param_res)

    def set_param_array(self, param_list, param_array, param_count, template):
        if len(param_list) != param_count:
            if param_count < len(param_list):
                param_array = param_array[0: param_count]
            elif len(param_list) == 0:
                for i in range(param_count):
                    param = {
                        'description': "param " + str(i),
                        'index': str(i),
                        'type': "Hex"
                    }
                    param_array.append(param)
                    template += " " + param['description'] + "={}"

        return template

    def set_param_res(self, param_res, param_array, event_log_dict, param_event):
        param_bytes = param_event.get('param_bytes')
        param0_len = param_event.get('param0_len')
        event_code = param_event.get('event_code')
        for param_obj in param_array:
            param_value = ""
            index = int(param_obj["index"])
            param_type = param_obj["type"]
            if index == 0:
                tmpBuf = param_bytes[(index * 4): (index * 4 + 4)]
                addr_hex = self.handle_bytes_address(tmpBuf)
                event_log_dict['identity'] = addr_hex

            param_read_vlaue = read_uint32_le(param_bytes, index * 4 + param0_len - 4)

            if param_type == 'addr_hex':
                param_value = hex(param_read_vlaue)

            elif param_type == 'Int32':
                intNum = param_read_vlaue
                if param_obj["description"] == "nodeSize" and \
                        event_code != hex(LOS_TRACE_TYPE.TRACE_QUEUE_CREATE.value):
                    intNum = intNum - 4
                param_value = str(intNum)

            elif param_type == "UInt32":
                param_value = str(param_read_vlaue)

            elif param_type == "Hex":
                tmpBuf = param_bytes[(index * 4 + param0_len - 4): (index * 4 + param0_len)]
                param_value = self.handle_bytes_address(tmpBuf)
                if event_code == hex(LOS_TRACE_TYPE.TRACE_EVENT_CLEAR.value) and \
                        param_obj["description"] == "events":
                    param_value = hex((0xffffffff ^ int(param_value, base=16)))[-8:]

            elif param_type == "TaskAddr":
                tmpBuf = param_bytes[(index * 4 + param0_len - 4): (index * 4 + param0_len)]
                addr_hex = self.handle_bytes_address(tmpBuf)
                param_value = self.get_object_name(addr_hex)

            elif param_type == "TimeoutInOsTicks":
                param_value = "LOS_WAIT_FOREVER" if param_read_vlaue == LOS_WAIT_FOREVER_VALUE else \
                    str(param_value) + " ticks"
            else:
                param_value = self.get_param_value(param_type, param_read_vlaue)

            param_res.append(param_value)

    def get_param_value(self, param_type, param_read_vlaue):
        param_value = ""
        param_table = {
            "IPCState": lambda x : "not in use" if x == 0 else "used",
            "HwiMode": lambda x : "no shared" if x & 0x8000 == 0 else "shared",
            "QueueOperateType": lambda x : "read" if x & 0x1 == 0 else "write",
            "TaskStatus": self.convert_tsk_status,
            "TimerMode": self.convert_timer_mode,
            "EventReadMode": self.convert_evt_read_mode
        }
        if param_type in param_table:
            param_value = param_table[param_type](param_read_vlaue)

        return param_value

    def set_event_log_dict(self, param_res, event_log_dict, param_event):
        param_bytes = param_event.get('param_bytes')
        event_code = param_event.get('event_code')
        event_curTask = param_event.get('event_code')
        if event_code == hex(LOS_TRACE_TYPE.TRACE_TASK_PRIOSET.value):
            addr_hex = param_res[0]
            if addr_hex in self.trace_header.trace_obj_data and len(param_bytes) >= 16:
                self.trace_header.trace_obj_data[addr_hex]['prio'] = param_res[3]

        elif event_code == hex(LOS_TRACE_TYPE.TRACE_MEM_ALLOC.value) or \
                event_code == hex(LOS_TRACE_TYPE.TRACE_MEM_ALLOC_ALIGN.value) or \
                event_code == hex(LOS_TRACE_TYPE.TRACE_MEM_REALLOC.value):
            if len(param_bytes) >= 8 and param_res[1] not in self.__muem_used:
                res = param_res[2] if len(param_res) >= 3 else 0
                event_log_dict['heapUsed'] = res
                used_actor = "0xfffffff" if event_log_dict['Actor'] == "Interrupt" else \
                    event_curTask + ":" + event_log_dict['Actor']
                self.__muem_used[param_res[1]] = {
                    'size': res,
                    'Actor': used_actor
                }
            else:
                event_log_dict['heapUsed'] = "0"

        elif event_code == hex(LOS_TRACE_TYPE.TRACE_MEM_FREE.value):
            if len(param_bytes) >= 8 and param_res[1] in self.__muem_used:
                event_log_dict['heapUsed'] = str(self.__muem_used[param_res[1]]['size'] * -1) + \
                                                "/" + self.__muem_used[param_res[1]]['Actor']
                del self.__muem_used[param_res[1]]
            else:
                event_log_dict['heapUsed'] = "0"

        elif event_code == hex(LOS_TRACE_TYPE.TRACE_MEM_INFO.value):
            if len(param_bytes) >= 8:
                event_log_dict['heapUsed'] = param_res[1]
                event_log_dict['heapFree'] = param_res[2]

    def get_object_name(self, key_value):
        symbol = self.trace_header.trace_obj_data.get(key_value)
        symbol_name = ''
        if symbol is None:
            symbol_name = key_value
        else:
            symbol_name = symbol.get('name')
        return symbol_name

    def get_object_pri(self, key_value):
        symbol = self.trace_header.trace_obj_data.get(key_value)
        symbol_prio = ''
        if symbol is None:
            symbol_prio = 'unknown'
        else:
            symbol_prio = symbol.get('prio')
        return symbol_prio

    @staticmethod
    def handle_bytes_address(param_bytes):
        addr_hex = str(int.from_bytes(param_bytes[::-1], byteorder='big'))
        for _ in range(8 - len(addr_hex)):
            addr_hex = '0' + addr_hex
        addr_hex = "0x" + addr_hex
        return addr_hex

    @staticmethod
    def format(template, arg):
        s = template
        index = s.find('{}', 0)
        for arg_val in arg:
            s = s[0: index] + arg_val + s[index + 2:]
            index = s.find('{}', index + 1)
        return s

    @staticmethod
    def convert_tsk_status(task_status):
        if task_status & OS_TASK_STATUS_RUNNING:
            return "Running"
        elif task_status & OS_TASK_STATUS_READY:
            return "Ready"
        else:
            if task_status & OS_TASK_STATUS_DELAY:
                return "Delay"
            elif task_status & OS_TASK_STATUS_PEND_TIME:
                if task_status & OS_TASK_STATUS_SUSPEND:
                    return "SuspendTime"
                elif task_status & OS_TASK_STATUS_PEND:
                    return "PendTime"
            elif task_status & OS_TASK_STATUS_PEND:
                return "Pend"
            elif task_status & OS_TASK_STATUS_SUSPEND:
                return "Suspend"
        return "Invalid"

    @staticmethod
    def convert_timer_mode(mode):
        time_mode = 'unknown'
        if mode == En_Sw_Tmr_Type.LOS_SWTMR_MODE_ONCE:
            time_mode = 'One-off'
        elif mode == En_Sw_Tmr_Type.LOS_SWTMR_MODE_PERIOD:
            time_mode = 'Periodic'
        elif mode == En_Sw_Tmr_Type.LOS_SWTMR_MODE_NO_SELFDELETE:
            time_mode = 'One-off but not self-delete'
        elif mode == En_Sw_Tmr_Type.LOS_SWTMR_MODE_OPP:
            time_mode = 'LOS_SWTMR_MODE_OPP'
        return time_mode

    @staticmethod
    def convert_evt_read_mode(mode):
        read_mode = 'unkonwn'
        if mode == LOS_WAITMODE_AND:
            read_mode = 'LOS_WAITMODE_AND'
        elif mode == LOS_WAITMODE_OR:
            read_mode = 'LOS_WAITMODE_OR'
        elif mode == LOS_WAITMODE_CLR:
            read_mode = 'LOS_WAITMODE_CLR'
        return read_mode

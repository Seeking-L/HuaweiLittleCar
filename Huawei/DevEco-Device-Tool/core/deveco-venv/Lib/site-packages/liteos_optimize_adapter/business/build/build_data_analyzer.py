#!/usr/bin/env python3
# coding=utf-8

import json
import os
from os.path import join, isdir, abspath, exists, isabs, sep, normpath
import re

import click

from liteos_optimize_adapter.util.common_utils import CommonUtils
from liteos_optimize_adapter.business.build.build_handle_data import BuildHandleData

map_start_rule = r'Memory Configuration'
map_end_rule = r'Linker script and memory map'
elf_setion_rule = r'^\s[0-9]'
elf_symbol_rule = r'^[0-9]+'
file_size_content_rule = r'^(\s*\.[a-zA-Z]+)'

MODULE_MAP = {
    'los_task.o': 'task',
    'task.o': 'task',
    'los_sched.o': 'task',
    'los_priqueue.o': 'task',
    'canary.o': 'task',
    'los_stackinfo.o': 'task',
    'los_hwi.o': 'hwi',
    'los_tick.o': 'tick',
    'los_memory.o': 'mem',
    'los_multipledlinkhead.o': 'mem',
    'los_memstat.o': 'mem',
    'los_heap.o': 'mem',
    'fault.o': 'exc',
    'exception.o': 'exc',
    'los_exc.o': 'exc',
    'cache.o': 'init',
    'los_init.o': 'init',
    'dispatch.o': 'init',
    'los_bitmap.o': 'misc',
    'los_misc.o': 'misc',
    'los_printf.o': 'printf',
    'los_sortlink.o': 'sftmr',
    'los_percpu.o': 'misc',
    'los_cpup.o': 'cpup',
    'los_queue.o': 'queue',
    'los_sem.o': 'sem',
    'los_swtmr.o': 'timer',
    'strlen.o': 'libc',
    'memcpy.o': 'libc',
    'memset.o': 'libc',
    'rand.o': 'libc',
    'memcpy_s.o': 'libsec',
    'vsnprintf_s.o': 'libsec',
    'secureprintoutput_a.o': 'libsec',
    'memset_s.o': 'libsec',
    'cmsis_liteos.o': 'compat',
    'pthread_mutex.o': 'huawei_libc',
    'wctomb.o': 'huawei_libc',
    'wcrtomb.o': 'huawei_libc',
    'frexpl.o': 'libc',
    'frexp.o': 'libc',
    'unknownFile': 'pad',
    'los_event.o': 'event',
    'los_sys.o': 'misc',
    'los_hw_tick.o': 'tick',
    'los_hw.o': 'tick',
    'los_dispatch_gcc.o': 'sched',
}

COMPONENT_MAP = {
    'unknownFile': 'pad',
    'libarm_pl011.a': 'driver-uart',
    'libbase.a': 'kernel-base',
    'libbcache.a': 'fs-vfs-bcache',
    'libbch.a': 'fs-vfs-bch',
    'libc.a': 'lib-libc',
    'libconsole.a': 'kernel-ext-console',
    'libcortex-a7.a': 'arch',
    'libcppsupport.a': 'kernel-ext-cpp',
    'libcpup.a': 'kernel-ext-cpup',
    'libcsysdeps.a': 'lib-huaweilib',
    'libdisk.a': 'fs-vfs-disk',
    'libdriverbase.a': 'driver-base',
    'libdynload.a': 'kernel-ext-dynload',
    'libfat.a': 'fs-fat-base',
    'libfsck.a': 'fs-fat-fsck',
    'libvirpart.a': 'fs-fat-virpart',
    'libhieth-sf.a': 'driver-hieth_sf',
    'libinit.a': 'kernel-init',
    'libinterrupt.a': 'kernel-interrupt',
    'libjffs2.a': 'fs-jiffs2',
    'liblinux.a': 'compat-linux',
    'libcmsis.a': 'compat-cmsis',
    'liblittlefs.a': 'fs-littlefs',
    'liblowpower.a': 'kernel-ext-lpw-base',
    'liblwip.a': 'net-lwip',
    'libm.a': 'lib-libm',
    'libmmc.a': 'driver-mmc',
    'libmtd_common.a': 'driver-mtd-common',
    'libmulti_partition.a': 'fs-vfs-multi_partition',
    'libnand_flash.a': 'driver-mtd-nand',
    'libspinor_flash.a': 'driver-mtd-spinor',
    'libposix.a': 'lib-huaweilib',
    'libpowermgr.a': 'kernel-ext-lpw-powermgr',
    'libproc.a': 'fs-proc',
    'libramfs.a': 'fs-ramfs',
    'libromfs.a': 'fs-romfs',
    'librunstop.a': 'kernel-ext-lpw-runstop',
    'libscatter.a': 'kernel-ext-scatter',
    'libsec.a': 'lib-libsec',
    'libshell.a': 'shell',
    'libtargets.a': 'targets',
    'libtickless.a': 'kernel-ext-tickless',
    'libtimer.a': 'kernel-timer',
    'libuart.a': 'driver-uart',
    'libusb_base.a': 'driver-usb-base',
    'libusb_device.a': 'dirver-usb-device',
    'libusb_phy.a': 'dirver-usb-phy',
    'libvfs.a': 'fs-vfs',
    'libyaffs2.a': 'fs-yaffs2',
    'libz.a': 'lib-libz',
    'libgcc.a': 'lib-gcc',
    'libtelnet.a': 'net-telnet',
    'libiperf2.a': 'net-iperf2'
}


class BuildDataAnalyzer:
    _elf_path = ''
    _map_path = ''
    _build_config_path = ''
    _module_config = {}
    _compiler_path = ''
    _prefix = 'arm-none-eabi'
    _section_keys = []
    _environment = ''

    section_data = {}
    region_data = []
    size_data = {}
    elf_size_data = {}
    module_data = {}
    folder_data = {}
    rom_addr = {
        'start': 0,
        'end': 0
    }
    is_rom = True
    last_symbol = []
    last_line = ''
    is_unknown = False
    cur_section = ''
    cur_section_size = ''

    def __init__(self):
        self._root_dir = join(abspath('.'), 'analyzerJson')
        if not isdir(self._root_dir):
            os.mkdir(self._root_dir)
        self._json_path = join(self._root_dir, 'memoryDetails.json')


    def do_build_analysis(self, paths):
        try:
            click.echo('++++++++++start buildAnalyzer++++++++++')
            data = CommonUtils.get_prefix(paths['compiler_path'])
            paths.update(data)
            click.echo(paths)

            self._elf_path = paths['elf_path']
            self._map_path = paths['map_path']
            self._prefix = paths['prefix']
            self._compiler_path = paths['compiler_path']
            self._environment = paths['environment']
            if self._build_config_path:
                self._module_config = self._get_build_json(self._build_config_path)
            json_obj = self._parse_map_file()
            build_handle = BuildHandleData(json_obj, self._json_path, self._section_keys)
            build_handle.assemble_build_data()
            click.echo('++++++++++end buildAnalyzer++++++++++')
        except Exception as e:
            raise Exception('buildAnalyzer error') from e


    @staticmethod
    def _get_build_json(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                res = f.read()
                json_data = json.loads(s=res)
                return json_data
        except FileExistsError as e:
            click.echo('file exists error')
            raise FileExistsError() from e


    def _parse_map_file(self):
        try:
            suffix = self._prefix + '-size.exe'
            if self._environment == 'linux':
                suffix = self._prefix + '-size'
            file_size_path = join(self._compiler_path, suffix)
            if not exists(file_size_path):
                click.echo(f'size path not find: {file_size_path}')
                raise FileExistsError()
            size_arr = self.get_file_size(file_size_path, '-A', self._elf_path)
            size_arr.pop()
            size_arr.pop(0)
            self._set_elf_size_data(size_arr)
            json_obj = self._read_file()
            return json_obj
        except SystemError as e:
            click.echo('map parse error')
            raise SystemError() from e


    def _set_elf_size_data(self, size_arr):
        for item in size_arr:
            elf_size = re.sub(r'\s+', ' ', item).split(' ')
            if elf_size[0].startswith('.') and (elf_size[2] != '0' or elf_size[1] != '0'):
                self.elf_size_data[elf_size[0]] = {
                    'addr': int(elf_size[2]),
                    'size': int(elf_size[1])
                }
                self._section_keys.append(elf_size[0])


    def _read_file(self):
        try:
            self._read_file_to_arr(self._map_path)
            json_obj = self._parse_elf_file(self._elf_path)
            return json_obj
        except Exception as e:
            click.echo('elf parse error')
            raise Exception() from e


    def _parse_elf_file(self, elf_path):
        suffix = self._prefix + '-objdump.exe'
        if self._environment == 'linux':
            suffix = self._prefix + '-objdump'
        obj_dump_path = join(self._compiler_path, suffix)
        if not obj_dump_path or not exists(obj_dump_path):
            click.echo('Please configure the correct compiler type and compiler path')
            raise FileExistsError()
        try:
            data = CommonUtils.get_obj_dump_info(obj_dump_path, '-h', elf_path)
            for key, value in enumerate(data):
                line = re.sub(r'\s+', ' ', value)
                if re.search(elf_setion_rule, line):
                    data_arr = line.split(' ')
                    next_line = data[key + 1]
                    self._set_section_data(data_arr, next_line)
            json_obj = self._get_symbol_data(obj_dump_path, elf_path)
            return json_obj
        except SystemError as e:
            click.echo('elf parse error')
            raise SystemError() from e


    def _set_section_data(self, data_arr, next_line):
        size = int('0x' + data_arr[3], 16)
        vma = int('0x' + data_arr[4], 16)
        lma = 0 if next_line.find('LOAD') < 0 else int('0x' + data_arr[5], 16)
        if vma > 0 or size != 0:
            region_name = []
            for region_item in self.region_data:
                start_addr = int(region_item['startAddr'], 16)
                end_addr = int(region_item['endAddr'], 16)
                if (start_addr <= vma < end_addr) or (lma != 0 and start_addr <= lma < end_addr):
                    region_name.append(region_item['name'])
                    region_item['used'] += size
            section = {
                'regionName': region_name,
                'runAddr': '0x' + data_arr[4],
                'loadAddr': '' if lma == 0 else '0x' + data_arr[5],
                'size': self._addr_to_size('0x' + data_arr[3]),
                'sizeOri': '0x' + data_arr[3],
                'children': []
            }
            self.section_data[data_arr[2]] = section


    def _get_symbol_data(self, obj_dump_path, elf_path):
        try:
            data = CommonUtils.get_obj_dump_info(obj_dump_path, '-t', elf_path)
            for item in data:
                line = re.sub(r'\s+', ' ', item)
                if re.search(elf_symbol_rule, line):
                    self._set_section_symbol_data(line)
        except SystemError as e:
            click.echo('data parse error')
            raise SystemError() from e

        for region in self.region_data:
            used = self._addr_to_size(hex(region['used']))
            try:
                usage = region['used'] / region['size']
                region['usage'] = '%.2f' % (usage * 100) + '%'
            except ZeroDivisionError:
                region['usage'] = '0.00%'
            region['free'] = self._addr_to_size(hex(region['size'] - region['used']))
            region['used'] = used
            region['size'] = self._addr_to_size(hex(region['size']))
        json_obj = {
            'region': self.region_data,
            'details': self.section_data,
            'sizeData': self.size_data,
            'moduleData': self.module_data,
            'folderData': self.folder_data
        }
        return json_obj


    def _set_section_symbol_data(self, line):
        data_arr = line.split(' ')
        section_name = data_arr[3]
        symbol_name = data_arr[-2]
        type_name = data_arr[2]
        if len(data_arr[-1]) != 0:
            symbol_name = data_arr[-1]
        if section_name != symbol_name and section_name in self.section_data:
            section = self.section_data[section_name]
            vma = int('0x' + data_arr[0], 16)
            lma = 0
            if section['loadAddr']:
                lma = int(section['loadAddr'], 16) - int(section['runAddr'], 16) + vma
            symbol = {
                'name': symbol_name,
                'runAddr': '0x' + data_arr[0],
                'loadAddr': hex(lma) if lma else '',
                'size': self._addr_to_size('0x' + data_arr[4]),
                'sizeOri': '0x' + data_arr[4],
                'location': '',
                'type': type_name
            }
            self.section_data[section_name]['children'].append(symbol)


    @staticmethod
    def _addr_to_size(addr):
        size = int(addr, 16)
        if size < 1024:
            return f'{size} B'
        else:
            return '%.2f' % (size / 1024) + 'KB'


    @staticmethod
    def get_file_size(file_size_path, arg, elf_file_path):
        cmd = [file_size_path, arg, elf_file_path]
        data = CommonUtils.exec_cmd(cmd)
        return data.strip().split('\n')


    def _read_file_to_arr(self, map_path):
        is_start = False
        is_end = False
        with open(map_path, 'r') as f:
            line = f.readline()
            while line:
                line = line.strip()
                if re.match(map_start_rule, line):
                    is_start = True
                elif re.match(map_end_rule, line):
                    is_end = True
                elif is_start and not is_end:
                    self._set_region_data(line)
                elif is_end:
                    self._parse_size_data(line)
                line = f.readline()


    def _set_region_data(self, line):
        if len(line) > 0 and not line.startswith('Name') and not line.startswith('*default*'):
            line_arr = re.sub(r'\s+', ' ', line).split(' ')
            end_addr = '0x%08x' % (int(line_arr[1], 16) + int(line_arr[2], 16))
            if len(line_arr) >= 3:
                region = {
                    'name': line_arr[0],
                    'startAddr': line_arr[1],
                    'endAddr': end_addr,
                    'size': int(line_arr[2], 16),
                    'sizeOri': line_arr[2],
                    'used': 0,
                    'usage': 0
                }
                self.region_data.append(region)
                if line_arr[0] == 'FLASH':
                    self.rom_addr['start'] = int(region['startAddr'], 16)
                    self.rom_addr['end'] = int(region['endAddr'], 16)


    def _parse_size_data(self, line):
        is_need_parse = False
        file_size_content_end_rule = re.compile(r'0x[0-9a-fA-F]{8,16}\s+0x[0-9a-fA-F]{1,16}\s+')
        file_size_symbol_rule = re.compile(r'^(\s*0x[0-9a-fA-F]{8,16})\s*\w+')
        file_rule = re.compile(r'^(\s+\*fill\*)\s+0x[0-9a-fA-F]{8,16}\s+0x[0-9a-fA-F]{1,16}')
        is_content_rule = len(line) > 0 and re.search(file_size_content_rule, line) is not None
        is_end_rule = line.find('.o') > 0 and re.search(file_size_content_end_rule, line) is not None
        if is_content_rule and is_end_rule:
            is_need_parse = True
        elif is_content_rule:
            self.last_line = line
            is_need_parse = False
        elif len(line) > 0 and is_end_rule:
            line = self.last_line + ' ' + line
            self.last_line = ''
            is_need_parse = True
        elif re.search(file_rule, line) is not None:
            self.last_line = ''
            is_need_parse = True
        else:
            self.last_line = ''
        if is_need_parse:
            if self.is_unknown and len(self.last_symbol) > 1 and self.last_symbol[0]['addr'] in self.size_data:
                self._reset_symbol_size_data()
            self.is_unknown = False
            line = line.strip()
            line_arr = re.sub(r'\s+', ' ', line).split(' ')
            addr = line_arr[1]
            self._get_cur_section(addr)
            if self.cur_section:
                self._calculate_size_data(line_arr, addr)
        elif self.is_unknown and re.search(file_size_symbol_rule, line):
            line_arr = re.sub(r'\s+', ' ', line).split(' ')
            addr = line_arr[0]
            name = line_arr[1]
            if len(self.last_symbol) == 1 and self.last_symbol[0]['addr'] != addr:
                self.is_unknown = False
                self.last_symbol = []
            else:
                self.last_symbol.append({
                    'addr': addr,
                    'name': name
                })


    def _calculate_size_data(self, line_arr, addr):
        is_check = any([
            self.cur_section == '.text',
            self.cur_section == '.rodata',
            self.cur_section == '.data',
            self.cur_section == '.bss',
            self.cur_section == '.ARM'
        ])
        if line_arr[0].find(self.cur_section) >= 0 and is_check:
            cur_size = int(line_arr[2], 16)
            symbol_index = line_arr[0].find(self.cur_section) + len(self.cur_section)
        else:
            cur_size = int(line_arr[2], 16)
            symbol_index = -100
        obj_name = line_arr[3]
        parent = child = obj_path = parent_path = ''
        if line_arr[0][symbol_index: symbol_index + 1] == '.':
            child = line_arr[0][symbol_index + 1:] + ':' + addr
        else:
            child = 'unknown' + ':' + addr
            self.is_unknown = True
            self.last_symbol = [{
                'addr': addr,
                'name': 'unknown'
            }]
        if obj_name and obj_name.find('.a') > 0:
            index = obj_name.find('.a')
            parent_data = re.sub(r'\\', '/', obj_name[0: index + 2])
            parent = parent_data[parent_data.rfind('/') + 1:]
            parent_path = normpath(parent_data[:parent_data.rfind('/')])
            obj_name = obj_name[index + 3: len(obj_name) - 1]
        obj_name_data = re.sub(r'\\', '/', obj_name)
        obj_name = obj_name_data[obj_name_data.rfind('/') + 1:]
        if parent == '':
            obj_path = normpath(obj_name_data[:obj_name_data.rfind('/')])
        param_size = dict(name=obj_name, parent=parent, path=obj_path,
                          obj_name=obj_name, lib_name=parent, cur_size=cur_size)
        if obj_name == '' and child.split(':')[0] == 'unknown':
            obj_name = 'unknownFile'
        self._set_size_data(param_size)
        if parent:
            param_size.update({'name': parent, 'parent': '', 'path': parent_path})
            self._set_size_data(param_size)
        if child:
            self._set_addr_data(addr)
            if child.split(':')[0] != 'unknown' or cur_size != 0:
                param_size.update({'name': child, 'parent': obj_name, 'path': ''})
                self._set_size_data(param_size, True)


    def _set_addr_data(self, addr):
        if addr in self.size_data:
            old_size = self.size_data[addr][self.cur_section_size]
            old_lib = self.size_data[addr]['lib']
            old_parent = self.size_data[addr]['parent']
            old_module_name = self.size_data[addr]['moduleName']
            old_component_name = self.size_data[addr]['componentName']
            if old_lib in self.size_data:
                self.size_data[old_lib][self.cur_section_size] = self.size_data[
                    old_lib][self.cur_section_size] - old_size

            if old_parent in self.size_data:
                self.size_data[old_parent][self.cur_section_size] = self.size_data[
                    old_parent][self.cur_section_size] - old_size
                self._set_old_parent_size(old_parent, old_size)

            if old_module_name in self.module_data:
                self.module_data[old_module_name][self.cur_section_size] = self.module_data[
                    old_module_name][self.cur_section_size] - old_size

            if old_component_name in self.module_data:
                self.module_data[old_component_name][self.cur_section_size] = self.module_data[
                    old_component_name][self.cur_section_size] - old_size


    def _set_old_parent_size(self, cur_parent, cur_size):
        if self.size_data[cur_parent]['parent'] == '' and 'path' in self.size_data[cur_parent]:
            path_list = self.size_data[cur_parent]['path'].split(sep)
            temp_folder = self.folder_data
            for path in path_list:
                if path in temp_folder and self.cur_section_size in temp_folder[path]:
                    temp_folder[path][self.cur_section_size] = temp_folder[path][self.cur_section_size] - cur_size
                temp_folder = temp_folder[path]


    def _set_size_data(self, param_size, is_symbol=False):
        name = param_size.get('name')
        parent = param_size.get('parent')
        obj_name = param_size.get('obj_name')
        lib_name = param_size.get('lib_name')
        cur_size = param_size.get('cur_size')
        path = param_size.get('path')
        if name in self.size_data and not is_symbol:
            if not self.size_data[name][self.cur_section_size]:
                self.size_data[name][self.cur_section_size] = cur_size
            else:
                self.size_data[name][self.cur_section_size] = self.size_data[name][self.cur_section_size] + cur_size
        elif name:
            symbol_name = name
            if is_symbol and len(name.split(':')) > 1:
                symbol_name = name.split(':')[1] if name.split(':')[0] == 'unknown' else name.split(':')[0]
                name = name.split(':')[1]
            self.size_data[name] = {
                'objName': symbol_name,
                'parent': parent,
                'path': path,
                'romSize': 0,
                'moduleName': self._get_module_name(obj_name),
                'componentName': self._get_component_name(lib_name)
            }
            if self.size_data[name]['componentName'] == '' and lib_name:
                self.size_data[name]['moduleName'] = lib_name
                self.size_data[name]['componentName'] = 'unknown'
            if is_symbol:
                self.size_data[name]['isSymbol'] = True
                self.size_data[name]['lib'] = lib_name
                self._set_module_data(self.size_data[name]['moduleName'], self.size_data[name]['componentName'],
                                      cur_size)
                self._set_module_data(self.size_data[name]['componentName'], '', cur_size)
                if self.size_data[name]['moduleName'] == '' and self.size_data[name]['componentName']:
                    self.size_data[name]['moduleName'] = self.size_data[name]['componentName']
            for item in self._section_keys:
                self.size_data[name][item] = 0
            self.size_data[name][self.cur_section_size] = cur_size
        if self.is_rom and name:
            self.size_data[name]['romSize'] = self.size_data[name]['romSize'] + cur_size

        if path and not isabs(path):
            self._set_folder_data(path, name, cur_size, obj_name)


    def _set_folder_data(self, cur_path, cur_name, cur_size, child_name):
        """
        Split paths and assemble them into dict
        Example: "build/libs/main.o" assemble to {"build":{"child":[], "size":1, "libs"{"child":[main.o], "size":1}}}
        """
        path_list = cur_path.split(sep)
        temp_folder = self.folder_data

        for path in path_list:
            self._set_child_size(path, temp_folder, cur_size, [])
            temp_folder = temp_folder[path]

        if cur_name not in temp_folder['child']:
            if cur_name != child_name:
                self._set_child_size(cur_name, temp_folder, cur_size, [child_name])
                if cur_name in temp_folder and child_name not in temp_folder[cur_name]['child']:
                    temp_folder[cur_name]['child'].append(child_name)
            else:    
                temp_folder['child'].append(cur_name)


    def _set_child_size(self, cur, folder, size, child_list):
        if cur not in folder:
            folder[cur] = {"child":child_list}
            for item in self._section_keys:
                folder[cur][item] = 0
            folder[cur][self.cur_section_size] = size
        else:
            if self.cur_section_size in folder[cur]:
                folder[cur][self.cur_section_size] = folder[cur][self.cur_section_size] + size
            else:
                folder[cur][self.cur_section_size] = size


    def _set_module_data(self, name, parent, cur_size):
        if name == '':
            return
        if name in self.module_data:
            if not self.module_data[name][self.cur_section_size]:
                self.module_data[name][self.cur_section_size] = cur_size
            else:
                self.module_data[name][self.cur_section_size] = self.module_data[name][self.cur_section_size] + cur_size
        elif name:
            self.module_data[name] = {
                'objName': name,
                'parent': parent,
                'romSize': 0
            }
            for item in self._section_keys:
                self.module_data[name][item] = 0
            self.module_data[name][self.cur_section_size] = cur_size
        if self.is_rom and name:
            self.module_data[name]['romSize'] = self.module_data[name]['romSize'] + cur_size


    def _get_module_name(self, obj_name):
        if obj_name in self._module_config and type(self._module_config[obj_name]) == str:
            return self._module_config[obj_name]
        else:
            return MODULE_MAP.get(obj_name, obj_name)


    def _get_component_name(self, lib_name):
        if lib_name in self._module_config and type(self._module_config[lib_name]) == str:
            return self._module_config[lib_name]
        else:
            return COMPONENT_MAP.get(lib_name, '')


    def _get_cur_section(self, addr):
        self.cur_section = ''
        self.cur_section_size = ''

        for section_key in self.elf_size_data:
            section_size = self.elf_size_data[section_key]['size']
            section_addr = self.elf_size_data[section_key]['addr']
            if section_addr <= int(addr, 16) <= section_addr + section_size:
                self.cur_section = section_key
                self.cur_section_size = self.cur_section
            if self.rom_addr['start'] <= int(addr, 16) <= self.rom_addr['end']:
                self.is_rom = True
            elif self.cur_section == '.text' or self.cur_section == '.rodata' or self.cur_section == '.data':
                self.is_rom = True
            else:
                self.is_rom = False


    def _reset_symbol_size_data(self):
        length = len(self.last_symbol)
        tmp_parent = self.last_symbol[0]['addr']
        all_size = int(self.size_data[tmp_parent][self.cur_section_size])

        for key, val in enumerate(self.last_symbol):
            if key != 0:
                tmp = val['addr']
                size = 0
                if key == length - 1:
                    size = all_size
                else:
                    size = int(self.last_symbol[key + 1]['addr'], 16) - int(self.last_symbol[key]['addr'], 16)
                    all_size = all_size - size
                tmp_size = {
                    'objName': self.last_symbol[key]['name'],
                    'parent': self.size_data[tmp_parent]['parent'],
                    'isSymbol': True,
                    'lib': self.size_data[tmp_parent]['lib'],
                    'moduleName': self.size_data[tmp_parent]['moduleName'],
                    'componentName': self.size_data[tmp_parent]['componentName']
                }
                for item in self._section_keys:
                    tmp_size[item] = 0
                self.size_data[tmp] = tmp_size
                self.size_data[tmp][self.cur_section_size] = size

#!/user/bin/env python3
# coding=utf-8

from enum import Enum

from liteos_optimize_adapter.util.trace_utils import (read_uint16_le, read_uint32_le)


class Trace_Head_Sub_Type(Enum):
    ENDIAN = 0x1
    VERSION = 0x2
    OBJ_SIZE = 0x3
    OBJ_COUNT = 0x4
    CUR_INDEX = 0x5
    MAX_RECODE = 0x6
    CUR_OBJ_INDEX = 0x7
    CLOCL_FREQ = 0x8


class Trace_Obj_Sub_Type(Enum):
    ADDR = 0x1
    PRIO = 0x2
    NAME = 0x3


class Trace_Header():

    def __init__(self):
        self.endian = None
        self.trace_mode = None
        self.obj_size = None
        self.obj_count = None
        self.cur_index = -1
        self.max_record_count = 0
        self.cur_obj_inbdex = -1
        self.clock_freq = None
        self.timestamp_frequency = None
        self.trace_obj_data = {}

    def parse_trace_header(self, buf):
        if buf is None:
            print("parse_header error, headerDataBuf is null")
            return
        temp_buf = buf
        while len(temp_buf) > 1:
            msg_type = temp_buf[0]
            msg_length = temp_buf[1]
            if len(temp_buf) < msg_length + 2:
                return
            msg_buf = temp_buf[2: (msg_length + 2)]
            if msg_type == Trace_Head_Sub_Type.ENDIAN.value:
                self.endian = read_uint32_le(msg_buf)

            elif msg_type == Trace_Head_Sub_Type.VERSION.value:
                input_mode = self.trace_mode
                self.trace_mode = read_uint16_le(msg_buf)
                if input_mode == 'record' and self.trace_mode == 1:
                    print("errorMode")
                elif input_mode == 'start' and self.trace_mode == 0:
                    print("errorMode")
                elif input_mode == 'open':
                    self.trace_mode = 0

            elif msg_buf == Trace_Head_Sub_Type.OBJ_SIZE.value:
                self.obj_size = read_uint16_le(msg_buf)

            elif msg_buf == Trace_Head_Sub_Type.OBJ_COUNT.value:
                self.obj_count = read_uint16_le(msg_buf)

            elif msg_buf == Trace_Head_Sub_Type.CUR_INDEX.value:
                self.cur_index = read_uint16_le(msg_buf)

            elif msg_buf == Trace_Head_Sub_Type.MAX_RECODE.value:
                self.max_record_count = read_uint16_le(msg_buf)

            elif msg_buf == Trace_Head_Sub_Type.CUR_OBJ_INDEX.value:
                self.cur_obj_inbdex = read_uint16_le(msg_buf)

            elif msg_buf == Trace_Head_Sub_Type.CLOCL_FREQ.value:
                self.clock_freq = read_uint32_le(msg_buf)
                if (self.clock_freq != 0):
                    self.timestamp_frequency = self.clock_freq

            temp_buf = temp_buf[(msg_length + 2):]

    def parse_trace_object_data(self, object_data):
        if object_data is None:
            print("parse_objectData error, objectData is null")
            return
        temp_buf = object_data
        obj_prio = ''
        obj_name = ''
        addr_hex = ''
        while len(temp_buf) > 1:
            msg_type = temp_buf[0]
            msg_length = temp_buf[1]
            if len(temp_buf) < msg_length + 2:
                return
            msg_buf = temp_buf[2: (msg_length + 2)]

            if msg_type == Trace_Obj_Sub_Type.ADDR.value:
                addr_hex = read_uint32_le(msg_buf)
                for _ in range(8 - len(str(addr_hex))):
                    addr_hex = '0' + str(addr_hex)
                addr_hex = "0x" + addr_hex

            elif msg_type == Trace_Obj_Sub_Type.PRIO.value:
                obj_prio = str(read_uint32_le(msg_buf))

            elif msg_type == Trace_Obj_Sub_Type.NAME.value:
                if len(temp_buf) >= 16:
                    obj_name = self.set_obj_name(obj_name, msg_buf)
            temp_buf = temp_buf[(msg_length + 2):]

        obj = {
            "prio": obj_prio,
            "name": obj_name
        }
        self.trace_obj_data[addr_hex] = obj

    @staticmethod
    def set_obj_name(obj_name, msg_buf):
        for i in range(16):
            name_bytes = msg_buf[i]
            if name_bytes == 0:
                break
            obj_name += chr(name_bytes)
        return obj_name

#!/usr/bin/env python3
# coding=utf-8

import json
import os


class PerfHandleData:
    _perf_data = {
        'sampleCount': 0,
        'eventCount': None,
        'eventData': None
    }

    def __init__(self, json_path, data):
        self._perf_data = data
        table_tree = {}
        selections = list(data['eventData'].keys())

        for selection_id in selections:
            cpus = list(data['eventData'][selection_id].keys())
            for cpu_id in cpus:
                s_data = self._handle_data(data, selection_id, cpu_id)
                table_tree[selection_id] = table_tree[selection_id] if table_tree.get(selection_id, None) else {}
                table_tree[selection_id][cpu_id] = s_data
        obj = {
            'perfDataJson': data,
            'tableTree': table_tree
        }
        json_string = json.dumps(obj, indent=4)
        try:
            flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
            with os.fdopen(os.open(json_path, flags, 0o640), 'w') as fp:
                fp.write(json_string)
        except SystemError:
            print('file write error')

    def _handle_data(self, perf_data, selection, cpu):
        data = []
        if perf_data['eventData'] and len(perf_data['eventData'].keys()) > 0:
            selection_id = selection
            if not selection_id:
                selection_id = list(perf_data['eventData'].keys())[0]
            event_data = perf_data['eventData'][selection_id]
            cpu_id = cpu
            if not cpu_id:
                cpu_id = list(event_data.keys())[0]
            event_data = event_data[cpu_id]
            for key in event_data:
                item = event_data[key]
                temp_item = self._create_node(item, item['isCalled'], selection_id)
                if temp_item:
                    data.append(temp_item)
            data.sort(key=lambda x: (-x['backTraceTimes'], -x['backTraceLevel']))
        return data

    def _create_node(self, node, is_called, selection_id, hot_path_per=''):
        if self._perf_data and self._perf_data['eventCount']:
            event_count = self._perf_data['eventCount'][selection_id]
            if self._perf_data and event_count:
                return {
                    'id': node['funcaddr'],
                    'name': node['funcname'],
                    'childPer': self._get_child_per(event_count, node) if hot_path_per else
                        self._get_back_times(node['backTraceTimes'], event_count),
                    'selfPer': '%.2f' % ((node['calledTimes'] / event_count) * 100) + '%',
                    'symbol': node['funcname'],
                    'isCalled': is_called,
                    'backTraceTimes': node['backTraceTimes'],
                    'backTraceLevel': node['level'],
                    'hotPathPer': hot_path_per,
                    'filepath': node['filepath']
                }
        return None

    @staticmethod
    def _get_child_per(event_count, item):
        percentage = 0
        for key in item['called']:
            try:
                percentage += item['called'][key] / event_count
            except ZeroDivisionError:
                percentage += item['called'][key]
        return '%.2f' % (percentage * 100) + '%'

    @staticmethod
    def _get_back_times(back_times, event_count):
        back = back_times
        try:
            back = back_times / event_count
        except ZeroDivisionError:
            pass
        return '%.2f' % (back * 100) + '%'

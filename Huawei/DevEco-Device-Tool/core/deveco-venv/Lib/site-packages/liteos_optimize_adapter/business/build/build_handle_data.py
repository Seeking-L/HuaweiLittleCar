#!/usr/bin/env python3
# coding=utf-8

import copy
import json
import os
from os.path import sep

OTHER_KEY_COUNT = 2
TREE_NAME_DELIMITER = '-'


class BuildHandleData:
    def __init__(self, json_data, json_path, section_keys):
        self._json_data = json_data
        self._json_path = json_path
        self._section_keys = section_keys
        self._sum_section_names = []
        self._file_size_tree = {}
        self._tree_key_list = []


    def assemble_build_data(self):
        self._sum_section_names = self._get_section_name()
        list_data, table_tree = self._get_region_details_data()
        self._file_size_tree, module_size_tree = self._get_file_module_data()
        folder_data_tree = self._get_folder_data()
        build_data = {
            'listData': list_data,
            'tableTree': table_tree,
            'fileSizeTree': self._file_size_tree,
            'moduleSizeTree': module_size_tree,
            'sumSectionNames': self._sum_section_names,
            'sectionKeys': self._section_keys,
            'folderTree': folder_data_tree,
            'folderTreeNames': self._tree_key_list
        }
        json_string = json.dumps(build_data, indent=4)
        flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        with os.fdopen(os.open(self._json_path, flags, 0o640), 'w') as fp:
            fp.write(json_string)


    def _get_section_name(self):
        sum_section_names = []
        for item in self._section_keys:
            if item.find('text') > -1 or item.find('data') > -1:
                sum_section_names.append(item)
        return sum_section_names


    def _get_file_module_data(self):
        file_size_tree = {}
        module_size_tree = {}
        if 'sizeData' in self._json_data:
            file_size_tree = self._json_data['sizeData']
            self._set_file_tree(file_size_tree)
        if 'moduleData' in self._json_data:
            module_size_tree = self._json_data['moduleData']
            self._set_module_tree(module_size_tree)
        return file_size_tree, module_size_tree


    def _set_file_tree(self, file_size_tree):
        for key in file_size_tree:
            item = file_size_tree[key]
            if item:
                item['runAddr'] = key
                item['id'] = item['objName']
                item['dec'] = item.get('textSize', 0) + item.get('dataSize', 0) + item.get('rodotatSize', 0)
                item['romSize'] = item.get('romSize', 0)
                item['sumSize'] = 0
                for s_item in self._sum_section_names:
                    item['sumSize'] += item[s_item]


    def _set_module_tree(self, module_size_tree):
        for key in module_size_tree:
            item = module_size_tree[key]
            if item:
                item['id'] = item['objName']
                item['sumSize'] = 0
                for name in self._sum_section_names:
                    item['sumSize'] += item[name]


    def _get_region_details_data(self):
        list_data = []
        table_tree = {}
        if 'region' in self._json_data:
            list_data = self._json_data['region']
        if 'details' in self._json_data:
            table_tree = self._json_data['details']
        table_tree_arr = self.handle_data(list_data, table_tree)
        return list_data, table_tree_arr


    def handle_data(self, list_data, table_tree):
        tree_arr = []
        list_temp = copy.deepcopy(list_data)
        for key in table_tree:
            value = table_tree[key]
            if value.get('regionName', False):
                self._set_handle_data(key, value, list_temp, tree_arr)
            else:
                tree_arr.append(self._get_symbol(key, value))
        return tree_arr


    def _set_handle_data(self, key, value, list_temp, tree_arr):
        for itm in value['regionName']:
            arr_item = [item for item in list_temp if item.get('name') == itm][0]
            parent = [item for item in tree_arr if item.get('name') == itm]
            if parent:
                parent[0]['children'].append(self._get_symbol(key, value, None))
            else:
                arr_item['level'] = 0
                arr_item['open'] = True
                arr_item['id'] = arr_item['name']
                arr_item['sort'] = 0
                if 'children' in arr_item and type(arr_item['children'] == list):
                    arr_item['children'].append(self._get_symbol(key, value, arr_item['name']))
                else:
                    arr_item['children'] = [self._get_symbol(key, value, arr_item['name'])]
                tree_arr.append(arr_item)


    def _get_folder_data(self):
        folder_data = {}
        folder_tree = []

        if 'folderData' in self._json_data:
            folder_data_tree = self._json_data['folderData']
            for folder, data in folder_data_tree.items():
                self._compress_path(folder, data, folder_data)

            for folder, data in folder_data.items():
                self._convert_folder_tree(folder, data, '', folder_tree)

        return folder_tree


    def _compress_path(self, folder_key, folder_data, target_dict):
        """
        Combine a directory whose level is 1 and whose child is empty with a lower-level directory.
        Example: {"src":{"child":[],"size":20,"libs":{"child":[],"size":20}}} Combine to
        {"src/libs":{"child":[],"size":20}}
        """
        if len(folder_data) > len(self._section_keys) + OTHER_KEY_COUNT or len(folder_data["child"]) > 0:
            for folder, data in folder_data.items():
                if folder_key not in target_dict:
                    target_dict[folder_key] = {}
                if isinstance(data, dict):
                    self._compress_path(folder, data, target_dict[folder_key])  
                elif folder != 'child' or len(data) > 0:
                    target_dict[folder_key][folder] = data
        else:
            for folder, data in folder_data.items():
                if isinstance(data, dict):
                    self._compress_path(folder_key + sep + folder, data, target_dict)


    def _convert_folder_tree(self, folder_key, folder_data, tree_key, target_list):
        """
        Encapsulates data into front-end renderable data.
        [{'key': folder_key, 'treeName': tree_name, 'objName': folder_key, 'sumSize': 0,
        'children':[{'key': children_key, 'objName': children_key, 'sumSize': 0}]}]
        """
        tree_name = f'{tree_key}{TREE_NAME_DELIMITER}{folder_key}'
        self._tree_key_list.append(tree_name)
        folder_dict = {'key': folder_key, 'treeName': tree_name, 'objName': folder_key, 'sumSize': 0}
        for folder, data in folder_data.items():
            if isinstance(data, dict):
                if 'children' not in folder_dict:
                    folder_dict['children'] = []
                self._convert_folder_tree(folder, data, tree_name, folder_dict['children'])
            else:
                self._set_folder_data(folder, data, tree_name, folder_dict)
        target_list.append(folder_dict)


    def _set_folder_data(self, folder_key, folder_data, tree_key, folder_dict):
        if folder_key == 'child':
            if 'children' not in folder_dict:
                folder_dict['children'] = []
            self._convert_child(folder_data, tree_key, folder_dict['children'])
        else:
            if folder_key in self._sum_section_names:
                folder_dict['sumSize'] += folder_data
            folder_dict[folder_key] = folder_data


    def _convert_child(self, child_data, tree_key, target_list):
        """
        Obtain the corresponding attribute value from file_size_tree and encapsulate it.
        [{'key': key, 'treeName': tree_name, 'objName': key, 'sumSize': 0,
        'children': [key': children_key, 'objName': children_key, 'sumSize': 0]}]
        """
        if self._file_size_tree:
            for child in child_data:
                tree_name = f'{tree_key}{TREE_NAME_DELIMITER}{child}'
                self._tree_key_list.append(tree_name)
                folder_dict = {'key': child, 'treeName': tree_name}
                folder_dict['objName'] = self._file_size_tree[child].get('objName') if self._file_size_tree[child].get('objName') else \
                    self._file_size_tree[child].get('runAddr', '')
                folder_dict['sumSize'] = self._file_size_tree[child].get('sumSize', 0)
                child_children = []
                self._set_folder_children(child, child_children, tree_name)
                if child_children:
                    folder_dict['children'] = child_children
                for item in self._section_keys:
                    folder_dict[item] = self._file_size_tree[child].get(item, 0)
                target_list.append(folder_dict)


    def _set_folder_children(self, child_name, children_list, tree_key):
        for key, vlaue in self._file_size_tree.items():
            if vlaue.get('parent', '') == child_name:
                tree_name = f'{tree_key}{TREE_NAME_DELIMITER}{key}'
                self._tree_key_list.append(tree_name)
                child_dict = {'key': key, 'treeName': tree_name}
                child_dict['objName'] = vlaue.get('objName') if vlaue.get('objName') else vlaue.get('runAddr', '')
                child_dict['sumSize'] = vlaue.get('sumSize', 0)
                for s_item in self._section_keys:
                    child_dict[s_item] = vlaue.get(s_item, 0)
                children_list.append(child_dict)


    @staticmethod
    def _get_symbol(key, item, IPARENTID=None):
        new_obj = {
            'name': key,
            'id': key,
            'level': 1,
            'IPARENTID': IPARENTID,
            'open': False,
            'sort': 0,
            'children': []
        }

        def handle(x):
            obj = x
            obj['level'] = 2
            obj['id'] = x['name']
            obj['IPARENTID'] = key
            obj['sort'] = 0
            return obj

        new_children = list(map(handle, item['children']))
        new_obj['children'] = new_children
        new_obj.update(item)

        return new_obj


import argparse
import json
import os
import sys
from os.path import join, abspath, exists

from liteos_optimize_adapter.business.stack.stackusage.src.arm_read_asm import arm_read_asm_file
from liteos_optimize_adapter.business.stack.stackusage.src.func_stack import FuncStack
from liteos_optimize_adapter.business.stack.stackusage.src.read_manual_funcptr import read_manual_func_ptr_cfg
from liteos_optimize_adapter.business.stack.stackusage.src.riscv_read_asm import riscv_read_asm_file

# Manual Function Pointer Configuration File
MANUAL_FUNC_PTR_CFG_FILE = "funcptr.txt"

OUT_PATH = "analyzerJson"

CFG_PATH = "cfg"

OUT_JSON_FILE = "funcstack.json"


def find_recursive_func_dfs(address, depth, caller_addr, dfs_dump_list):
    if address not in FuncStack.addr_funcstack_dict:
        return
    funcstack = FuncStack.addr_funcstack_dict[address]
    if funcstack.is_rec == 1:
        return
    if address == caller_addr and depth != 0:
        funcstack.is_rec = 1
    if depth == 0:
        dfs_dump_list = []
    else:
        funcstack.is_called = 1

    if address in dfs_dump_list:
        return

    dfs_dump_list.append(address)
    for func_addr in funcstack.callee_func_addr:
        find_recursive_func_dfs(func_addr, depth + 1, caller_addr, dfs_dump_list)
    dfs_dump_list.remove(address)


def find_recursive_func():
    dfs_dump_list = list()
    for addr, funcstack in FuncStack.addr_funcstack_dict.items():
        if funcstack.is_called == 0:
            find_recursive_func_dfs(addr, 0, addr, dfs_dump_list)


def stack_max_cost_dfs(address, depth, stats_rec, dfs_dump_set):
    if address not in FuncStack.addr_funcstack_dict:
        return 0, 0
    funcstack = FuncStack.addr_funcstack_dict[address]
    if depth == 0:
        dfs_dump_set.clear()
    if address in dfs_dump_set:
        funcstack.depth = sys.maxsize
        return funcstack.local_size, funcstack.depth
    if funcstack.is_rec == 1 and stats_rec == 0:
        funcstack.depth = sys.maxsize
        return funcstack.local_size, funcstack.depth
    if len(funcstack.ptr_src_location):
        cfg_path = join(abspath('.'), OUT_PATH, CFG_PATH, MANUAL_FUNC_PTR_CFG_FILE)
        flags = os.O_RDWR | os.O_CREAT
        with os.fdopen(os.open(cfg_path, flags, 0o640), 'a') as fp:
            for srcline in funcstack.ptr_src_location:
                fp.write(f"\nMiss_funcptr: {funcstack.func_name} {srcline} \n")
                fp.write(f"Remarks_here: {funcstack.func_addr} {funcstack.func_name} \n")
            funcstack.ptr_src_location = []

    dfs_dump_set.add(address)
    max_callee_func_cost = 0
    maxdepth = -1
    for func_addr in funcstack.callee_func_addr:
        size, depth = stack_max_cost_dfs(func_addr, depth + 1, stats_rec, dfs_dump_set)
        max_callee_func_cost = max(max_callee_func_cost, size)
        maxdepth = max(maxdepth, depth)
    dfs_dump_set.remove(address)

    if stats_rec > 1 and funcstack.is_rec == 1:
        funcstack.max_size = stats_rec * funcstack.local_size + max_callee_func_cost
    else:
        funcstack.max_size = funcstack.local_size + max_callee_func_cost
    if maxdepth != sys.maxsize:
        funcstack.depth = maxdepth + 1
    else:
        funcstack.depth = sys.maxsize
    return funcstack.max_size, funcstack.depth


def stack_max_cost(stats_rec):
    task_entry_count = 0
    dfs_dump_set = set()
    for addr, funcstack in FuncStack.addr_funcstack_dict.items():
        if funcstack.is_called == 0:
            stack_max_cost_dfs(addr, 0, stats_rec, dfs_dump_set)
            task_entry_count = task_entry_count + 1


def stack_analyze_all(is_output_json, stats_rec):
    find_recursive_func()
    stack_max_cost(stats_rec)
    if is_output_json:
        funcstack2json()


def funcstack2json():
    jsondict = {}
    for funcaddr, funcstack in FuncStack.addr_funcstack_dict.items():
        funcstackdict = {}
        funcstackdict["funcname"] = funcstack.func_name
        funcstackdict["funcaddr"] = funcaddr
        funcstackdict["LocalCost"] = funcstack.local_size
        funcstackdict["MaxCost"] = funcstack.max_size
        funcstackdict["called"] = list(funcstack.callee_func_addr)
        funcstackdict["Location"] = funcstack.src_location
        funcstackdict["IsCalled"] = funcstack.is_called
        funcstackdict["IsRec"] = funcstack.is_rec
        funcstackdict["depth"] = funcstack.depth
        funcstackdict["ptrVarName"] = funcstack.ptr_var_list
        jsondict[funcaddr] = funcstackdict

    output_path = join(abspath('.'), OUT_PATH)
    if not exists(output_path):
        os.mkdir(output_path)
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    with os.fdopen(os.open(join(output_path, OUT_JSON_FILE), flags, 0o640), "w") as fp:
        json.dump(jsondict, fp, sort_keys=True, indent=4)


def get_platform_from_asm(asm_file_path):
    with open(asm_file_path, 'r', encoding='utf8', errors='ignore') as asm_file:
        for asm_line in asm_file.readlines():
            line = asm_line.strip()
            if 'file format' in line:
                return line.split('file format')[-1]
        print("Asm file format failed, please check the asm file input.")
        return ''


def main(args):
    parser = argparse.ArgumentParser(description='StackUsage tools. \
                                                \nEstimate task stack size by disassembly file. \
                                                \nAlready support Arm and Risc-V platform')
    parser.add_argument('asm_file_path', metavar='HuaweiLiteOS.asm', nargs=1,
                        help='Disassembly file path'
                        )
    parser.add_argument('-m', '--analyze_mode', metavar='N', nargs=1, type=int,
                        default=[0], choices=[0, 1, 2],
                        help='analyze_mode. 0:Only analyze assembly code; \
                            1:Analyze source code line number. 2:Analyze source code in disassembly file.'
                        )
    parser.add_argument('-t', '--taskname', metavar='taskEntyName', nargs='+',
                        type=str, default=["OsIdleTask"],
                        help='Specified task entry name. Can be omitted if analyze all.'
                        )
    parser.add_argument('-j', '--outputjson', action='store_true', default=False,
                        help='Output result to json file.'
                        )
    parser.add_argument('-r', '--rec-stats', metavar='N', nargs=1, type=int, default=[1],
                        help='Recursive function loop cycles.'
                        )
    args = parser.parse_args(args)

    asm_file_path = args.asm_file_path[0]
    analyze_mode = args.analyze_mode[0]
    is_output_json = args.outputjson
    stats_rec = args.rec_stats[0]

    if not exists(asm_file_path):
        print("asm_file_path input:%s doesnt exit !" % asm_file_path)
        raise FileExistsError()
    platform_str = get_platform_from_asm(asm_file_path)
    if 'arm' in platform_str:
        arm_read_asm_file(asm_file_path, analyze_mode)
    elif 'riscv' in platform_str:
        riscv_read_asm_file(asm_file_path, analyze_mode)
    else:
        if platform_str:
            print("platform %s is not support yet !" % platform_str)
        raise Exception()

    cfg_path = join(abspath('.'), OUT_PATH, CFG_PATH)
    if not exists(cfg_path):
        os.mkdir(cfg_path)
    func_ptr_manual_cfg_file = join(cfg_path, MANUAL_FUNC_PTR_CFG_FILE)
    if exists(func_ptr_manual_cfg_file):
        read_manual_func_ptr_cfg(func_ptr_manual_cfg_file)

    stack_analyze_all(is_output_json, stats_rec)


if __name__ == '__main__':
    main(sys.argv[1:])

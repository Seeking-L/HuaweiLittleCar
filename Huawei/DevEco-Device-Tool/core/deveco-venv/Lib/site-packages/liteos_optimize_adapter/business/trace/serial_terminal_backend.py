#!/user/bin/env python3
#coding=utf-8

import time
import serial
import math

from enum import Enum, auto

from liteos_optimize_adapter.business.trace.event_codes_config_parser import EventCodesConfigParser
from liteos_optimize_adapter.business.trace.trace_database_writer import TraceDataBaseWriter
from liteos_optimize_adapter.business.trace.trace_header import Trace_Header
from liteos_optimize_adapter.business.trace.trace_event_parser import TraceEventParser
from liteos_optimize_adapter.util.trace_utils import (read_uint16_le, read_uint32_le)

FRAME_LEN = 4
CRC_LEN = 2
CRC_WIDTH = 8
CRC_POLY = 0x1021

TRACE_START_TYPE = 0x01
TRACE_START = 0x00000009
TRACE_TYPE = [0x00, 0x01, 0x02, 0x03]
TRACE_START_BIT = 0xff


class TraceEvtSubType(Enum):
    CORE = 0x1
    EVENT_CODE = auto()
    CUR_TIME = auto()
    EVENT_COUNT = auto()
    CUR_TASK = auto()
    IDENTITY = auto()
    EVENT_PARAMS = auto()


class SerialTerminalBackend():

    def __init__(self):
        self.trace_data = []
        self.trace_start_label = False
        self.trace_serial = serial.Serial()
        self.trace_header = Trace_Header()
        self.trace_data_writer = TraceDataBaseWriter(self.trace_header)
        self.trace_code_parser = EventCodesConfigParser()
        self.trace_event_parser = TraceEventParser(
            self.trace_header, self.trace_data_writer, self.trace_code_parser)

    def init_config(self, path):
        self.trace_code_parser.init_trace_code()
        self.trace_data_writer.init(path)

    def get_trace_data(self, port_setting):
        # Send the start trace message to the board and obtain the trace data.
        port = port_setting.get('port')
        if not port or self.trace_serial is None:
            print('please set the serial port information')
            raise Exception()
        baud_rate = int(port_setting.get('baud_rate'))
        try:
            print("open serial")
            self.open(port, baud_rate)
            # Start the STM command on the board.
            start_session_command_stm = [0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0a]
            # Start the trace command on the board.
            start_sesstion_command = [0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0d, 0x0a]
            print("start write data")
            self.writeData(bytes(start_session_command_stm))
            time.sleep(1)
            self.writeData(bytes(start_sesstion_command))
            self.receiveData()
        except Exception as e:
            print("get trace data error")
            raise Exception() from e
        finally:
            self.close()
            self.trace_data_writer.close_database()

    def stop_trace(self, port_setting):
        port = port_setting.get('port')
        if not port or self.trace_serial is None:
            print('please set the serial port information')
            raise Exception()
        baud_rate = int(port_setting.get('baud_rate'))
        self.open(port, baud_rate)
        stop_session_command_stm = [0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0a]
        stop_session_command = [0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x70, 0x0d, 0x0a]
        self.writeData(bytes(stop_session_command_stm))
        time.sleep(1)
        self.writeData(bytes(stop_session_command))
        self.trace_data_writer.insert_trace_data_to_database([], False)
        self.close()
        self.trace_data = []
        self.trace_start_label = False

    def open(self, port, baud_rate):
        self.trace_serial.port = port
        self.trace_serial.baudrate = baud_rate
        self.trace_serial.open()
        if not self.trace_serial.is_open:
            print(f"could not open port {port}")
            raise Exception()

    def close(self):
        self.trace_serial.close()

    def writeData(self, data):
        self.trace_serial.write(data)

    def receiveData(self):
        try:
            while True:
                date = self.trace_serial.readline()
                self.parse_data(date)

        except Exception as e:
            print("receiveData error")
            raise Exception() from e

    def parse_data(self, trace_data, is_open_file=False):
        """After the command is sent to the board, the serial port starts to receive data.
        The data is transmitted in the TLV format.
        """
        temp_buf = trace_data
        self.trace_data.extend(temp_buf)
        while len(temp_buf) >= FRAME_LEN + CRC_LEN:
            trace_type_buf = temp_buf[0: FRAME_LEN]
            my_type1 = trace_type_buf[0]
            my_type2 = trace_type_buf[1]
            m_length = read_uint16_le(trace_type_buf, 2)
            crc = read_uint16_le(temp_buf[FRAME_LEN : FRAME_LEN + CRC_LEN])
            res = []
            for t in TRACE_TYPE:
                if t == my_type2:
                    res = [t]
                    break
            is_my_type1_valid = my_type1 != TRACE_START_BIT or not res
            is_temp_buf_valid = len(temp_buf) < FRAME_LEN + CRC_LEN + m_length and is_open_file
            if is_my_type1_valid or is_temp_buf_valid:
                temp_buf = temp_buf[1:]
                self.trace_data = []
                self.trace_data.extend(temp_buf)
                continue
            elif len(temp_buf) >= FRAME_LEN + CRC_LEN + m_length:
                trace_data_buf = temp_buf[FRAME_LEN + CRC_LEN : FRAME_LEN + CRC_LEN + m_length]
                crc_calc = self.calc_crc(trace_data_buf, m_length)
                if crc_calc == crc:
                    self.set_parse_trace_data(my_type2, trace_data_buf)
                temp_buf = temp_buf[(FRAME_LEN + CRC_LEN + m_length):]
                self.trace_data = []
                self.trace_data.extend(temp_buf)
                continue
            else:
                if is_open_file:
                    print("parsing the data is complete!")
                    self.trace_data_writer.init_trace_data()
                return
        else:
            if is_open_file:
                print("parsing the data is complete!")
                self.trace_data_writer.init_trace_data()

    def set_parse_trace_data(self, data_type, data_buf):
        parse_trace_table = {
            TRACE_TYPE[0]: self.parse_trace_notify,
            TRACE_TYPE[1]: self.parse_trace_header,
            TRACE_TYPE[2]: self.parse_trace_obj,
            TRACE_TYPE[3]: self.parse_trace_event
        }
        if data_type in parse_trace_table:
            parse_trace_table[data_type](data_buf)

    @staticmethod
    def calc_crc(buf, lens):
        crc = 0
        for idx in range(lens):
            crc = crc ^ (buf[idx] << CRC_WIDTH)
            for _ in range(CRC_WIDTH):
                if crc & 0x8000:
                    crc = (crc << 1) ^ CRC_POLY
                else:
                    crc <<= 1
            crc &= 0xffff
        return crc

    def parse_trace_notify(self, buf):
        if self.trace_start_label == False:
            temp_buf = buf
            while len(temp_buf) > 1:
                msg_length = temp_buf[1]
                if len(temp_buf) < msg_length + 2:
                    return
                self.set_trace_start_label(temp_buf)
                temp_buf = temp_buf[(msg_length + 2):]

    def set_trace_start_label(self, buf):
        msg_type = buf[0]
        msg_length = buf[1]
        msg_buf = buf[2 : msg_length + 2]
        if msg_type == TRACE_START_TYPE:
            init_event_id = read_uint32_le(msg_buf)
            if init_event_id == TRACE_START:
                self.trace_start_label = True

    def parse_trace_header(self, buf):
        self.trace_header.parse_trace_header(buf)

    def parse_trace_obj(self, buf):
        self.trace_header.parse_trace_object_data(buf)

    def parse_trace_event(self, buf):
        """Each event is transmitted in the TLV format. 
        Event-related information is parsed based on the data type and length.
        """
        temp_buf = buf
        trace_event = {
            "event_code": "",
            "event_count": "",
            "event_ts": 0,
            "param_count": 0,
            "event_curTask": "",
            "hwiActive": "",
            "param_bytes": None,
            "cpuId": "0",
            "param0": None,
            "time": "",
            "isTaskLock": ""
        }
        self.set_trace_event_data(temp_buf, trace_event)

        if trace_event["event_ts"] == 0:
            return

        tmp = trace_event["param0"] + trace_event["param_bytes"]
        trace_event["param_bytes"] = tmp
        self.trace_event_parser.parse_trace_events([trace_event])


    @staticmethod
    def set_trace_event_data(buf, trace_event):
        count_is_receivd = False
        while len(buf) > 1:
            msg_type = buf[0]
            msg_length = buf[1]
            if len(buf) < msg_length + 2:
                return
            msg_buf = buf[2: msg_length + 2]
            if msg_type == TraceEvtSubType.CORE.value:
                core = hex(read_uint32_le(msg_buf))[2:]
                core_hex = ("00000000" + core)[-8:]
                trace_event["param_count"] = int(core_hex[3], 16)
                trace_event["isTaskLock"] = core_hex[4]
                trace_event["hwiActive"] = core_hex[5]
                trace_event["cpuId"] = core_hex[6:]
                count_is_receivd = True

            if msg_type == TraceEvtSubType.EVENT_CODE.value:
                trace_event["event_code"] = hex(read_uint32_le(msg_buf))

            if msg_type == TraceEvtSubType.CUR_TIME.value:
                ts_low = read_uint32_le(msg_buf)
                ts_high = read_uint32_le(msg_buf, 4)
                trace_event["time"] = hex(ts_high)[2:] + hex(ts_low)[2:]
                constValue = int(math.pow(2, 32))
                trace_event["event_ts"] = ts_low + ts_high * constValue

            if msg_type == TraceEvtSubType.EVENT_COUNT.value:
                trace_event["event_count"] = read_uint32_le(msg_buf)

            if msg_type == TraceEvtSubType.CUR_TASK.value:
                addr = hex(read_uint32_le(msg_buf))[2:]
                addr_hex = ("00000000" + addr)[-8:]
                trace_event["event_curTask"] = "0x" + addr_hex

            if msg_type == TraceEvtSubType.IDENTITY.value:
                trace_event["param0"] = msg_buf
                trace_event["param_count"] += 1

            if msg_type == TraceEvtSubType.EVENT_PARAMS.value:
                trace_event["param_bytes"] = msg_buf[0 : msg_length]
                if not count_is_receivd:
                    trace_event["param_count"] += len(trace_event["param_bytes"]) / 4

            buf = buf[(msg_length + 2):]

import keyword
import re

from liteos_optimize_adapter.business.stack.stackusage.src.func_stack import FuncStack

HEX_2BYTE_RULE = re.compile("([0-9a-fA-F]{4})")
HEX_COLON_RULE = re.compile("[0-9a-fA-F]+")
SYMBOL_RULE = re.compile("<([\._@a-zA-Z]+[\._0-9a-zA-Z]*)>:")
JUMP_SYMBOL_RULE = re.compile("<([\._@a-zA-Z][\._0-9a-zA-Z]*)>")
INS_RULE = re.compile("([a-zA-Z][\.a-zA-Z]*)")
SRC_LINE_RULE = re.compile(".+/(.+)$")
VAR_FUNC_PTR_RULE = re.compile("[0-9a-zA-Z\>\-\._\[\]]{1,}\(")
VAR_FUNC_PTR_RULE1 = re.compile("\)[0-9a-zA-Z\>\-\._\[\]]{1,}\)")
RISCV_SAVE_DICT = {'<__riscv_save_0>': 16, '<__riscv_save_4>': 64, '<__riscv_save_10>': 64, '<__riscv_save_12>': 64}
RISCV_RESTORE_BEGIN = '<__riscv_restore'


def riscv_read_asm_file(filename, analyze_mode):
    """Parse the source code file and line number in the asm file. If the function is enabled, 
    add the -g option during compilation and add the -Sld option during disassembly.
    analyze_mode 0: disabled; 1: enabled
    """
    with open(filename, 'r', encoding='utf8', errors='ignore') as asmfile:
        count = 0
        is_first_match = True
        record_src_location_flag = False
        is_text_section = False
        prevline = ''
        prev_src_line = ''
        cur_funcstack = None
        for line in asmfile.readlines():
            str_list = line.strip().split()
            if len(str_list) == 0:
                continue

            is_src = analyze_mode > 0 and record_src_location_flag and cur_funcstack
            match = SRC_LINE_RULE.match(str_list[0])
            if len(str_list) == 1 and is_src and match:
                cur_funcstack.src_location = re.split(r'/|\\', match.group(0))[-1]
                record_src_location_flag = False
            if len(str_list) == 1:
                prevline = line
                continue

            if line.startswith("Disassembly of section"):
                is_text_section = "text" in str_list[-1]
            if not is_text_section:
                continue

            match = HEX_COLON_RULE.match(str_list[0])
            if not match:
                prev_src_line = line
                continue

            cur_func_address = int(match.group(0), 16)
            # see if this is a symbol declaration
            match = SYMBOL_RULE.match(str_list[1])
            if match:
                is_first_match = set_local_size(is_first_match, cur_funcstack, count)
                count = 0
                cur_funcstack = FuncStack(hex(cur_func_address), str_list[1])
                record_src_location_flag = True
                continue

            match = HEX_2BYTE_RULE.match(str_list[1])
            if not match:
                continue
            record_src_location_flag = False
            stack_info = dict(str_list=str_list, cur_funcstack=cur_funcstack, count=count,
                analyze_mode=analyze_mode, prevline=prevline, prev_src_line=prev_src_line)
            count = set_func_stack(stack_info)

        if count > 0:
            cur_funcstack.local_size = count


def set_local_size(first_match, cur_funcstack, count):
    if first_match:
        first_match = False
    else:
        cur_funcstack.local_size = count
    return first_match
 

def set_func_stack(stack_info):
    str_list = stack_info.get('str_list')
    cur_funcstack = stack_info.get('cur_funcstack')
    count = stack_info.get('count')
    analyze_mode = stack_info.get('analyze_mode')
    prevline = stack_info.get('prevline')
    prev_src_line = stack_info.get('prev_src_line')
    try:
        # see if it's a one or two byte opcode
        str_index = 3 if HEX_2BYTE_RULE.match(str_list[2]) else 2

        # match the instruction string
        ins_match = INS_RULE.match(str_list[str_index])
        if not ins_match:
            return count
        ins = ins_match.group(1)

        # look for a few special instructions
        # match stmdb but not exist
        if "stmdb" in ins:
            c_byte = (len(str_list) - 2 - str_index) * 4
            count += c_byte

        # match push {ra,s0-s2},-16
        if ins == "push":
            param = str_list[str_index + 1]
            c_byte = int(param.split(',')[-1])
            count -= c_byte

        # match addi	sp,sp,-64
        if ins == "addi":
            param = str_list[str_index + 1]
            dest = param.split(',')[0]
            src = param.split(',')[1]
            c_byte = int(param.split(',')[2])

            if src == "sp" and dest == "sp" and c_byte < 0:
                count -= c_byte

        if ins == "jal" or ins == "j":
            count, is_ret_flag = set_jal_callee_data(str_list, count, cur_funcstack)
            if is_ret_flag:
                return count

        if ins == "jalr" or ins == "jr":
            count, is_ret_flag = set_jalr_jr_data(str_list, str_index, count, cur_funcstack)
            if is_ret_flag:
                return count
            set_analyze_data(analyze_mode, cur_funcstack, prevline, prev_src_line)

    except IndexError:
        print('riscv read asm indexError')
    except Exception as e:
        print('riscv read asm file error')
        raise Exception() from e

    return count


def set_jal_callee_data(str_list, count, cur_funcstack):
    is_ret_flag = False
    callee_addr = str_list[-2].split(",")[-1]
    bl_symbol = str_list[-1]
    match = HEX_COLON_RULE.match(callee_addr)
    if not match:
        print("bl address not match callee_addr: %s" % callee_addr)

    match = JUMP_SYMBOL_RULE.match(bl_symbol)
    if match:
        callee_addr = "0x%s" % callee_addr
        # Risc-v save cost
        if bl_symbol in RISCV_SAVE_DICT:
            count += RISCV_SAVE_DICT[bl_symbol]
        elif bl_symbol.startswith(RISCV_RESTORE_BEGIN):
            is_ret_flag = True
        else:
            cur_funcstack.callee_func_addr.add(callee_addr)

    return count, is_ret_flag


def set_jalr_jr_data(str_list, str_index, count, cur_funcstack):
    is_ret_flag = False
    if len(str_list) > str_index + 2:
        callee_addr = str_list[-2]
        bl_symbol = str_list[-1]

        match_addr = HEX_COLON_RULE.match(callee_addr)
        match_symbol = JUMP_SYMBOL_RULE.match(bl_symbol)
        if match_addr and match_symbol:
            callee_addr = "0x%s" % callee_addr
            # Risc-v save cost
            if bl_symbol in RISCV_SAVE_DICT:
                count += RISCV_SAVE_DICT[bl_symbol]
            elif not bl_symbol.startswith(RISCV_RESTORE_BEGIN):
                cur_funcstack.callee_func_addr.add(callee_addr)

            is_ret_flag = True

    return count, is_ret_flag


def set_analyze_data(analyze_mode, cur_funcstack, prevline, prev_src_line):
    if analyze_mode == 0:
        cur_funcstack.ptr_src_location.append('...')
    else:
        match = SRC_LINE_RULE.match(prevline)
        if match:
            cur_funcstack.ptr_src_location.append(re.split(r'/|\\', prevline)[-1])
        else:
            cur_funcstack.ptr_src_location.append('...')
    if analyze_mode == 2:
        func_ptr_list = VAR_FUNC_PTR_RULE.findall(prev_src_line)
        for func_ptr_with_brackets in func_ptr_list:
            func_str = func_ptr_with_brackets[:-1]
            if not keyword.iskeyword(func_str):
                cur_funcstack.ptr_var_list.append(func_str)
        if not func_ptr_list:
            match = VAR_FUNC_PTR_RULE1.search(prev_src_line)
            if match and not keyword.iskeyword(match.group(0)[1:-1]):
                cur_funcstack.ptr_var_list.append(match.group(0)[1:-1])

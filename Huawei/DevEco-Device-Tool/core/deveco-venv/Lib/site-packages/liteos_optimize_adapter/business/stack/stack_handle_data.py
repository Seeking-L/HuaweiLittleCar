#!/usr/bin/env python3
# coding=utf-8

import json
import re
import os

from liteos_optimize_adapter.util.common_utils import CommonUtils

MAX_IDX = 1000
MAX_DEPTH = 9223372036854775807


class StackHandleData:
    def __init__(self, json_path, addr2line_exe_path, elf_path):
        self._json_data = self.get_config_json(json_path)
        self._addr2line_exe_path = addr2line_exe_path
        self._elf_path = elf_path
        tree_table_nodes, list_data = self.get_tree_list_data()
        obj = {
            'stackData': self._json_data,
            'treeTablezNodes': tree_table_nodes,
            'listData': list_data
        }
        json_string = json.dumps(obj, indent=4)
        flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        with os.fdopen(os.open(json_path, flags, 0o640), 'w') as fp:
            fp.write(json_string)

    @staticmethod
    def get_config_json(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                res = file.read().strip()
                json_data = json.loads(s=res)
                return json_data
        except FileExistsError:
            print('file exists error')
        return {}

    def get_tree_list_data(self):
        keys = []
        tree_table_nodes = []
        list_data = []

        for key in self._json_data:
            value = self._json_data[key]
            if value['depth'] >= MAX_DEPTH:
                value['depth'] = 'ï¼Ÿ'
            if value['IsCalled'] == 0 and (value['MaxCost'] != 0 or value['LocalCost'] != 0):
                keys.append(key)
                list_data.append(value)
                pattern = re.compile(r'[<>:]')
                name = re.sub(pattern, '', value['funcname'])
                tree_table_data_item = {
                    'id': value['funcaddr'],
                    'pId': '',
                    'name': name,
                    'Depth': value['depth'],
                    'MaxCost': value['MaxCost'],
                    'LocalCost': value['LocalCost'],
                    'Location': value['Location'],
                    'FilePath': value['Location'],
                    'IsRec': value['IsRec']
                }
                tree_table_nodes.append(tree_table_data_item)
        self.handle_data(keys, list_data, tree_table_nodes)
        return tree_table_nodes, list_data

    def handle_data(self, keys, list_data, tree_table_nodes):
        if len(keys) > 0:
            ret = self.match_addrs2line(keys)
            self.set_tree_table(ret, list_data, tree_table_nodes)

    def set_tree_table(self, ret, list_data, tree_table_nodes):
        index = 1
        valid_exp = r'^([A-Za-z]:.*):(\d+)$'
        linux_path_reg_exp = r'\w+:(\d+)$'
        for i, list_data_val in enumerate(list_data):
            if index < len(ret) and (re.search(valid_exp, ret[index].strip()) is not None or \
                    re.search(linux_path_reg_exp, ret[index].strip()) is not None):
                start = ret[index].rindex('/') + 1
                list_data_val['Location'] = ret[index][start:]
                if tree_table_nodes[i] is not None:
                    tree_table_nodes[i]['FilePath'] = ret[index]
                    tree_table_nodes[i]['Loaction'] = ret[index][start:]
            index += 2

    def match_addrs2line(self, addrs):
        idx = 0
        path_arr = []
        while idx < len(addrs):
            strs = ' '.join(addrs[idx:(idx + MAX_IDX)])
            cmd = [self._addr2line_exe_path, '-Cfe', self._elf_path, strs]
            path_line = CommonUtils.exec_cmd(cmd).strip().split('\n')
            idx += MAX_IDX
            path_arr.extend(path_line)
        return path_arr

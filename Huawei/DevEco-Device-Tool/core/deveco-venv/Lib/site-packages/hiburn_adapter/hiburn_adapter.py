# pylint: too-many-instance-attributes
import collections
import copy
from os.path import (expanduser, join)
import platform
import subprocess
import tempfile
import xml.etree.ElementTree as xml

JRE_NAME = "java.exe" if platform.system() == "Windows" else "java"
TOOL_NAME = "hiburn.jar"
DUMMY_FASTBOOT_PARTITION = {
    "partition_type": "fastboot",
    "partition_mem": "spi",
    "partition_addr": 0,
    "partition_length": "",
    "partition_fs": "none",
    "partition_enabled": False,
    "partition_bin": ""
}

BurnParams = collections.namedtuple('BurnParams', ['bin_file', 'chip', 'action', 'port', 'speed', 'delay_time'])
BurnBaseParams = collections.namedtuple('BurnBaseParams', ['parts_file', 'chip', 'action'])


class PartitionConfig():
    MEM_TYPES = ["spi", "emmc"]

    def __init__(self, partitions):
        self.__partitions = copy.deepcopy(partitions)
        for part in self.__partitions:
            part.update(
                {
                    "partition_addr": self.get_int_value(part["partition_addr"]),
                    "partition_length": self.get_int_value(part["partition_length"]),
                    "partition_enabled": True
                })
        self.__partitions.sort(
            key=lambda p: (
                self.MEM_TYPES.index(p["partition_mem"]),
                p["partition_addr"]
            ))

        if not any([p for p in self.__partitions if p["partition_type"] == "fastboot"]):
            self.__partitions.insert(0, DUMMY_FASTBOOT_PARTITION)

    @staticmethod
    def get_int_value(val) -> int:
        if isinstance(val, int):
            return val

        if isinstance(val, str):
            return (val.startswith("0x") and int(val, 16)) or int(val, 0)

        raise ValueError(f"Don't know how to interpret value {val} of type {type(val)}")

    def dump_xml(self, file_desc):
        root = xml.Element("Partition_Info", dict(ProgrammerFile=""))
        for p in self.__partitions:
            part = dict(
                Sel="1" if p["partition_enabled"] else "0",
                PartitionName=p["partition_type"],
                FlashType=p["partition_mem"],
                FileSystem=("partition_fs" in p and p["partition_fs"]) or "none",
                SelectFile=p["partition_bin"],
                Start=str(p["partition_addr"]),
                Length=str(p["partition_length"])
            )
            node = xml.Element("Part", part)
            root.append(node)

        tree = xml.ElementTree(root)
        tree.write(file_desc, encoding="utf-8", xml_declaration=True)


class HiBurn():

    def __init__(self,
                 tool_path,
                 cache_dir,
                 log_path=None,
                 jre_path=None,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.PIPE,
                 debug=False,
                 tool_name=TOOL_NAME):

        _jre_path = expanduser(jre_path) if jre_path and jre_path.startswith("~") else jre_path
        _tool_path = expanduser(tool_path) if tool_path and tool_path.startswith("~") else tool_path
        self.__tool = join(_tool_path or "", tool_name)
        self.__tool_path = _tool_path
        self.__jre_exe = join(_jre_path or "", JRE_NAME)
        self.__version = None
        self.__stderr = stderr
        self.__stdout = stdout
        self.__cache_dir = cache_dir
        self.__debug = debug
        self.__log_dir = log_path

    def __exec(self, cmd, verbose=False, use_authbind=False, **kwargs):
        """Exec command 'cmd' with hiburn

        Args:
            cmd::[str]
                list of command arguments
            verbose::[bool]
                output command line to execute
            use_authbind::Boolean
                optional flag to enable authbind-based execution to allow non-root
                access to privileged ports
            **kwargs
                subprocess arbitrary keyword arguments

        Returns: tuple(int, str, str)
            errorcode::int
                shell exit code
            stdout::str
                Output from subprocess stdout
            stderr::str
                Output from subprocess stderr
        """

        cmd = [self.__jre_exe, '-Duser.language=en', '-jar', self.__tool] + cmd

        if use_authbind:
            cmd = ["authbind", "--deep"] + cmd

        default = dict(stdout=self.__stdout,
                       stderr=self.__stderr,
                       shell=False)
        default.update(kwargs)
        kwargs = default

        if verbose:
            print(" ".join(cmd))

        p = subprocess.Popen(cmd, **kwargs)
        out, err = p.communicate()

        if isinstance(out, bytes):
            out = out.decode(errors="backslashreplace")

        if isinstance(err, bytes):
            err = err.decode(errors="backslashreplace")

        return p.returncode, out if out is not None else '', err if err is not None else ''

    @property
    def version(self) -> str:
        if self.__version is None:
            code, out, _ = self.__exec(cmd=['--version'])
            if code == 0:
                self.__version = out.strip()

        return self.__version

    def _burn_serial_one(
            self, burn_params: BurnParams, verbose=False, **_):
        cmd = [
            '--{}'.format(burn_params.action),
            "-n", burn_params.chip,
            "-m", "serial", burn_params.port, str(burn_params.speed),
            "-b", burn_params.bin_file
        ]
        if self.__log_dir:
            cmd.extend(["-lp", self.__log_dir])
        if burn_params.delay_time:
            cmd.extend(["-dt", str(burn_params.delay_time)])
        err, _, _ = self.__exec(cmd, cwd=self.__tool_path, verbose=verbose)
        return err

    def _burn_serial(self, burn_base_params: BurnBaseParams, port, verbose=False, **_):
        cmd = [
            '--{}'.format(burn_base_params.action),
            "-n", burn_base_params.chip,
            "-m", "serial", port,
            "-x", burn_base_params.parts_file
        ]
        if self.__log_dir:
            cmd.extend(["-lp", self.__log_dir])
        err, _, _ = self.__exec(cmd, cwd=self.__tool_path, verbose=verbose)
        return err

    def _burn_jtag(self, burn_base_params: BurnBaseParams, verbose=False, **_):
        # pylint: disable=too-many-locals
        cmd = [
            '--{}'.format(burn_base_params.action),
            "-n", burn_base_params.chip,
            "-m", "jtag",
            "-x", burn_base_params.parts_file
        ]
        if self.__log_dir:
            cmd.extend(["-lp", self.__log_dir])
        err, _, _ = self.__exec(cmd, cwd=self.__tool_path, verbose=verbose)
        return err

    def _burn_net(self,  # pylint: too-many-locals
                  burn_base_params: BurnBaseParams,
                  verbose=False,
                  **kwargs):
        cmd = [
            '--{}'.format(burn_base_params.action),
            "-n", burn_base_params.chip,
            "-m", "net", kwargs.get("port"),
            kwargs.get("net_server_ip"),
            kwargs.get("net_client_ip"),
            kwargs.get("net_client_mask"),
            kwargs.get("net_client_gw"),
            kwargs.get("net_server_port"),
            "-x", burn_base_params.parts_file
        ]
        if self.__log_dir:
            cmd.extend(["-lp", self.__log_dir])

        use_authbind = platform.system() == "Linux"
        err, _, _ = self.__exec(cmd, cwd=self.__tool_path, verbose=verbose, use_authbind=use_authbind)
        return err

    def _burn_usb(self, burn_base_params: BurnBaseParams, verbose=False, **_):
        cmd = [
            '--{}'.format(burn_base_params.action),
            "-n", burn_base_params.chip,
            "-m", "USBBootrom",
            "-x", burn_base_params.parts_file
        ]
        if self.__log_dir:
            cmd.extend(["-lp", self.__log_dir])
        err, _, _ = self.__exec(cmd, cwd=self.__tool_path, verbose=verbose)
        return err

    def _do_burn(self, partitions, chip, mode, action, **kwargs) -> int:
        handlers = {
            "serial": self._burn_serial,
            "usb": self._burn_usb,
            "net": self._burn_net,
            "jtag": self._burn_jtag
        }
        with tempfile.NamedTemporaryFile(prefix="hiburn-",
                                         suffix=".xml",
                                         dir=self.__cache_dir,
                                         delete=False) as parts_file:
            parts_config = PartitionConfig(partitions)
            parts_config.dump_xml(parts_file)
            parts_file.flush()
            return handlers[mode](BurnBaseParams(parts_file.name, chip, action), verbose=self.__debug, **kwargs)

    def burn(self, partitions, chip, mode, **kwargs) -> int:
        return self._do_burn(partitions, chip, mode, "burn", **kwargs)

    def burn_one(self, bin_file, chip, port, speed, delay_time, **kwargs) -> int:
        return self._burn_serial_one(BurnParams(bin_file, chip, "burn", port, speed, delay_time), **kwargs)

    def erase(self, partitions, chip, mode, **kwargs) -> int:
        return self._do_burn(partitions, chip, mode, "erase", **kwargs)

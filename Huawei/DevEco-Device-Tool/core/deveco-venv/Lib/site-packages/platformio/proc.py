# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import subprocess
import sys
from os.path import isdir, isfile, join, normpath
from threading import Thread, get_ident, current_thread
import psutil
import click

from platformio import exception
from platformio.compat import (
    WINDOWS,
    get_filesystem_encoding,
    get_locale_encoding,
    string_types,
)
if WINDOWS:
    from platformio.cmd_utils import (win_split, win_quote)
else:
    import shlex


class AsyncPipeBase(object):
    def __init__(self):
        self._fd_read, self._fd_write = os.pipe()
        self._pipe_reader = os.fdopen(self._fd_read, 'rb')
        self._buffer = ""
        self._thread = Thread(target=self.run)
        setattr(self._thread, 'base_thread', getattr(current_thread(), 'base_thread', get_ident()))
        self._thread.start()

    def get_buffer(self):
        return self._buffer

    def fileno(self):
        return self._fd_write

    def run(self):
        try:
            self.do_reading()
        except (KeyboardInterrupt, IOError):
            self.close()

    def do_reading(self):
        raise NotImplementedError()

    def close(self):
        self._buffer = ""
        os.close(self._fd_write)
        self._thread.join()


class BuildAsyncPipe(AsyncPipeBase):
    def __init__(self, line_callback, data_callback):
        self.line_callback = line_callback
        self.data_callback = data_callback
        super(BuildAsyncPipe, self).__init__()

    def do_reading(self):
        line_bytes = bytearray()
        for byte in iter(lambda: self._pipe_reader.read(1), bytes()):
            line_bytes += byte
            if byte == b"\n":
                line_str = line_bytes.decode(get_locale_encoding(), errors='backslashreplace')
                self.line_callback(line_str)
                self._buffer += line_str
                line_bytes = bytearray()

            if line_bytes and byte.strip() and line_bytes[-3:] == (byte * 3):
                line_str = line_bytes.decode(get_locale_encoding(), errors='backslashreplace')
                self.data_callback(line_str)
                self._buffer += line_str
                line_bytes = bytearray()

        self._pipe_reader.close()


class LineBufferedAsyncPipe(AsyncPipeBase):
    def __init__(self, line_callback):
        self.line_callback = line_callback
        super(LineBufferedAsyncPipe, self).__init__()

    def do_reading(self):
        for line in iter(self._pipe_reader.readline, bytes()):
            line = line.decode(get_locale_encoding(), errors='backslashreplace')
            self._buffer += line
            self.line_callback(line)
        self._pipe_reader.close()


class ByteBufferedAsyncPipe(AsyncPipeBase):
    def __init__(self, byte_callback):
        self.byte_callback = byte_callback
        super(ByteBufferedAsyncPipe, self).__init__()

    def do_reading(self):
        line_bytes = bytearray()
        for byte in iter(lambda: self._pipe_reader.read(1), bytes()):
            line_bytes += byte
            if byte in [b"\n", b"\r"]:
                line_str = line_bytes.decode(get_locale_encoding(), errors='backslashreplace')
                self.byte_callback(line_str)
                self._buffer += line_str
                line_bytes = bytearray()

        self._pipe_reader.close()


class skipWarningBufferedAsyncPipe(AsyncPipeBase):
    def __init__(self, line_callback):
        self.line_callback = line_callback
        super(skipWarningBufferedAsyncPipe, self).__init__()

    def _read_peek(self):
        peek_len = len(self._pipe_reader.peek())
        return self._pipe_reader.read(peek_len)

    def do_reading(self):
        for line in iter(self._read_peek, bytes()):
            line = line.decode(errors='backslashreplace')
            if len(line) > int(4000):
                continue
            self._buffer += line
            self.line_callback(line)
        self._pipe_reader.close()


def _echo_build_path(logger, path):
    if logger and path:
        click.echo()
        click.secho(f"please check the compilation log: {path}", fg="cyan")


def exec_command(*args, **kwargs):
    result = {"out": None, "err": None, "returncode": None}

    default = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    default.update(kwargs)
    kwargs = default
    logger, path = None, None
    try:
        logger = kwargs.pop('logger')
        path = kwargs.pop('log_path')
    except KeyError:
        pass

    p = subprocess.Popen(*args, **kwargs)
    try:
        result['out'], result['err'] = p.communicate()
        result["returncode"] = p.returncode
    except KeyboardInterrupt as e:
        _echo_build_path(logger, path)
        raise exception.AbortedByUser() from e
    finally:
        for s in ("stdout", "stderr"):
            if isinstance(kwargs[s], AsyncPipeBase):
                result[s[3:]] = kwargs[s].get_buffer()
                kwargs[s].close()

    for k, v in result.items():
        if isinstance(result[k], bytes):
            try:
                result[k] = result[k].decode(get_locale_encoding() or get_filesystem_encoding())
            except UnicodeDecodeError:
                result[k] = result[k].decode("latin-1")
        if v and isinstance(v, string_types):
            result[k] = result[k].strip()

    _echo_build_path(logger, path)
    return result


def is_ci():
    return os.getenv("CI", "").lower() == "true"


def is_container():
    if not isfile("/proc/1/cgroup"):
        return False
    with open("/proc/1/cgroup") as fp:
        for line in fp:
            line = line.strip()
            if ":" in line and not line.endswith(":/"):
                return True
    return False


def get_pythonexe_path():
    return os.environ.get("PYTHONEXEPATH", normpath(sys.executable))


def copy_pythonpath_to_osenv():
    _PYTHONPATH = []
    if "PYTHONPATH" in os.environ:
        _PYTHONPATH = os.environ.get("PYTHONPATH").split(os.pathsep)
    for p in os.sys.path:
        conditions = [p not in _PYTHONPATH]
        if not WINDOWS:
            conditions.append(isdir(join(p, "click")) or isdir(join(p, "platformio")))
        if all(conditions):
            _PYTHONPATH.append(p)
    os.environ["PYTHONPATH"] = os.pathsep.join(_PYTHONPATH)


def where_is_program(program, envpath=None):
    env = os.environ
    if envpath:
        env["PATH"] = envpath

    # try OS's built-in commands
    try:
        result = exec_command(["where" if WINDOWS else "which", program], env=env)
        if result["returncode"] == 0 and isfile(result["out"].strip()):
            return result["out"].strip()
    except OSError:
        pass

    # look up in $PATH
    for bin_dir in env.get("PATH", "").split(os.pathsep):
        if isfile(join(bin_dir, program)):
            return join(bin_dir, program)
        if isfile(join(bin_dir, "%s.exe" % program)):
            return join(bin_dir, "%s.exe" % program)

    return program


def quote_cmd_line(cmd_line):
    if WINDOWS:
        return win_quote(cmd_line)

    return shlex.quote(cmd_line)


def split_cmd_line(cmd_line):
    if WINDOWS:
        return win_split(cmd_line)

    return shlex.split(cmd_line)


def shutdown_process_by_port(port, process_name=None):
    """
    Stop the process based on the port number
    """
    # search pid by port
    cmd = 'netstat -ano|findstr %s' % port if WINDOWS else "netstat -tunlp|grep %s" % port
    try:
        with os.popen(cmd) as process_info:
            stdout = process_info.read()
        process_list = stdout.split("\n")
        if stdout:
            pid = process_list[0].split()[-1]
            kill_process_cmd = ['taskkill', '-f', '-pid', pid] if WINDOWS else ['kill', '-9', pid.split('/')[0]]
            subprocess.run(kill_process_cmd, shell=False, capture_output=True)
            return True
        else:
            if process_name and not WINDOWS:
                ps_out = subprocess.run(["ps", "-ef"], shell=False, capture_output=True)
                grep_out = subprocess.run(["grep", process_name],
                    input=ps_out.stdout, shell=False, capture_output=True)
                grep2_out = subprocess.run(["grep", "-v", "grep"],
                    input=grep_out.stdout, shell=False, capture_output=True)
                awk_out = subprocess.run(["awk", "{print $2}"],
                    input=grep2_out.stdout, shell=False, capture_output=True)
                subprocess.run(["xargs", "kill", "-9"],
                    input=awk_out.stdout, shell=False, capture_output=True)
    except Exception:  # pylint: disable=broad-except
        return False
    return False


def kill_process_tree_by_pid(pid, including_parent=True):
    """
    kill child processes and parent process
    """
    try:
        parent = psutil.Process(pid)
    except psutil.NoSuchProcess:
        return
    children = parent.children(recursive=True)
    for child in children:
        try:
            child.kill()
            child.wait(1)
        except psutil.NoSuchProcess:
            pass
    if including_parent:
        try:
            parent.kill()
            parent.wait(1)
        except psutil.NoSuchProcess:
            pass

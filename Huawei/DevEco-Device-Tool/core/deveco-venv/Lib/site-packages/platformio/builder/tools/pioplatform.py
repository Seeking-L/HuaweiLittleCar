# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import

import sys
import json
import re
import os
from os.path import isdir, isfile, join, expanduser, isabs

from SCons.Script import ARGUMENTS  # pylint: disable=import-error
from SCons.Script import COMMAND_LINE_TARGETS  # pylint: disable=import-error

from platformio import exception, fs, util
from platformio.compat import WINDOWS
from platformio.managers.platform import PlatformFactory
from platformio.project.config import ProjectOptions, ProjectConfigBase

# pylint: disable=too-many-branches, too-many-locals


@util.memoized()
def PioPlatform(env):
    variables = env.GetProjectOptions(as_dict=True)
    if "framework" in variables:
        # support DevEco Core 3.0 dev/platforms
        variables["pioframework"] = variables["framework"]
    p = PlatformFactory.newPlatform(env["PLATFORM_MANIFEST"])
    p.configure_default_packages(variables, COMMAND_LINE_TARGETS)
    return p


def BoardConfig(env, board=None):
    with fs.cd(env.subst("$PROJECT_DIR")):
        try:
            p = env.PioPlatform()
            board = board or env.get("BOARD")
            if not board:
                raise ValueError("BoardConfig: Board is not defined")
            return p.board_config(board)
        except AssertionError as e:
            sys.stderr.write("Error: AssertionError\n")
            env.Exit(1)
        except exception.UnknownBoard as e:
            sys.stderr.write("Error: UnknownBoard\n")
            env.Exit(1)
    raise Exception("BoardConfig: Invalid project dir")


def GetFrameworkScript(env, framework):
    p = env.PioPlatform()
    if not p.frameworks:
        raise ValueError(f"Invalid value: {p.frameworks}")
    if framework not in p.frameworks:
        raise ValueError(f"{framework} not in {p.frameworks}")
    script_path = env.subst(p.frameworks[framework]["script"])
    if not isfile(script_path):
        script_path = join(p.get_dir(), script_path)
    return script_path


def LoadPartitions(board_config, env):
    framework_partition = board_config.get('upload.framework_partition', {})
    upload_partition_types = board_config.get('upload.partition_types', {})
    frameworks = env.get("PIOFRAMEWORK")
    if not upload_partition_types and framework_partition and frameworks:
        framework = (set(board_config.get('frameworks', {}).keys()) & set(frameworks)).pop()
        if framework in framework_partition:
            partition_types = framework_partition.get(framework, {}).get('partitions', {})
        else:
            bundle = env.GetProjectOption("hpm_project_base_package", '')
            product_hb = env.GetProjectOption('board_frameworks.hb.build.product', '')
            product = product_hb or bundle
            partition_types = framework_partition.get(product, {}).get('partitions', {})
        board_config.update('upload.partition_types', partition_types)

    board_config.update('upload_partitions', {})
    partitions = env.get('UPLOAD_PARTITIONS', [])
    for partition in partitions:
        part_ops = env.GetPartitionOptions(partition, as_dict=True)
        partition_path = f'upload.partition_types.{part_ops["partition_type"]}'
        board_config.update(
            f'upload_partitions.{partition}',
            {"partition_" + k: v
             for k, v in board_config.get(partition_path, {}).items()}
        )
        for option, value in part_ops.items():
            board_config.update(
                f'upload_partitions.{partition}.{option}', value)


def _add_prebuilt_toolpath(env):
    env.PrependENVPath("PATH", join(expanduser('~'), '.local', 'bin'))
    ohos_version = env.subst("$OHOS_VERSION")
    project_dir = env.subst("$PROJECT_DIR")
    product_hb = env.subst("$BOARD_FRAMEWORKS_HB_BUILD_PRODUCT")
    product_hpm = env.subst("$HPM_PROJECT_BASE_PACKAGE")
    product = product_hb or product_hpm
    status_path = join(project_dir, '.deveco', 'status', re.sub('[@/]', '.', product))
    if not ohos_version or not product or not isfile(status_path):
        return

    tool_status = json.load(open(status_path, 'r'))
    prebuilt_tools = tool_status.get('tools', {}).get('prebuilt', {})
    compiler_tools = tool_status.get('tools', {}).get('compiler', {})
    inner_tools = tool_status.get('tools', {}).get('inner', {})
    depend_tools = dict(prebuilt_tools, **compiler_tools)
    depend_tools.update(inner_tools)
    for tool in depend_tools:
        if not depend_tools.get(tool, {}).get('valid', False):
            continue
        bin_path = depend_tools.get(tool, {}).get('dest')
        env.PrependENVPath("PATH", bin_path)
    
    hpm_tools = tool_status.get('tools', {}).get('hpm', {})
    for tool, info in hpm_tools.items():
        environment_path = info.get('environment_path', [])
        storage_path = info.get('store')
        if info.get('valid', False):
            env.PrependENVPath("PATH", storage_path)
        if info.get('valid', False) and environment_path:
            env_paths = [join(storage_path, path) for path in environment_path]
            env.PrependENVPath("PATH", os.pathsep.join(env_paths))


def _handle_env_variables(env):
    p = env.PioPlatform()
    installed_packages = p.get_installed_packages()

    # Ensure real platform name
    env["PIOPLATFORM"] = p.name

    systype = util.get_systype()
    for name in installed_packages:
        type_ = p.get_package_type(name)
        if type_ not in ("toolchain", "uploader", "debugger"):
            continue
        pkg_dir = p.get_package_dir(name)
        env.PrependENVPath("PATH", pkg_dir)
        if isdir(join(pkg_dir, "bin")):
            env.PrependENVPath("PATH", join(pkg_dir, "bin"))
        if not WINDOWS and isdir(join(pkg_dir, "lib")) and type_ != "toolchain":
            env.PrependENVPath("DYLD_LIBRARY_PATH" if "darwin" in systype else "LD_LIBRARY_PATH", join(pkg_dir, "lib"),)

    compiler_bin_path = env.subst("$COMPILER_BIN_PATH")
    if compiler_bin_path:
        if not isabs(compiler_bin_path):
            compiler_bin_path = join(env.subst("$PROJECT_DIR"), compiler_bin_path)
        env.PrependENVPath("PATH", compiler_bin_path)

    _add_prebuilt_toolpath(env)

    # Platform specific LD Scripts
    if isdir(join(p.get_dir(), "ldscripts")):
        env.Prepend(LIBPATH=[join(p.get_dir(), "ldscripts")])


def LoadPioPlatform(env):
    _handle_env_variables(env)

    if "BOARD" not in env:
        return

    # update board manifest with overridden data from INI config
    board_config = env.BoardConfig()
    for option, value in env.GetProjectOptions():
        if not option.startswith("board_"):
            continue
        option = option.lower()[6:]
        try:
            if isinstance(board_config.get(option), bool):
                value = str(value).lower() in ("1", "yes", "true")
            elif isinstance(board_config.get(option), int):
                value = int(value)
        except KeyError:
            pass
        board_config.update(option, value)

    # load partitions
    LoadPartitions(board_config, env)

    # load default variables from board config
    for option_meta in ProjectOptions.values():
        if not option_meta.buildenvvar or option_meta.buildenvvar in env:
            continue
        data_path = (
            option_meta.name[6:]
            if option_meta.name.startswith("board_")
            else option_meta.name.replace("_", ".")
        )
        try:
            env[option_meta.buildenvvar] = board_config.get(data_path)
        except KeyError:
            pass

    if "build.ldscript" in board_config:
        env.Replace(LDSCRIPT_PATH=board_config.get("build.ldscript"))


def ConvertToProjectOptions(env, clivars):
    env.Replace(
        **{
            m.buildenvvar: ProjectConfigBase.parse_multi_values(env[m.buildenvvar])
            for m in ProjectOptions.values()
            if m.buildenvvar in list(clivars) and m.buildenvvar in env and m.multiple
        })


def PrintConfiguration(env):  # pylint: disable=too-many-statements
    platform = env.PioPlatform()
    board_config = env.BoardConfig() if "BOARD" in env else None

    def _get_platform_data():
        data = ["PLATFORM: %s %s" % (platform.title, platform.version)]
        if platform.src_version:
            data.append("#" + platform.src_version)
        if int(ARGUMENTS.get("PIOVERBOSE", 0)) and platform.src_url:
            data.append("(%s)" % platform.src_url)
        if board_config:
            data.extend([">", board_config.get("name")])
        return data

    def _get_hardware_data():
        data = ["HARDWARE:"]
        mcu = env.subst("$BOARD_MCU")
        f_cpu = env.subst("$BOARD_F_CPU")
        if mcu:
            data.append(mcu.upper())
        if f_cpu:
            f_cpu = int("".join([c for c in str(f_cpu) if c.isdigit()]))
            data.append("%dMHz," % (f_cpu / 1000000))
        if not board_config:
            return data
        ram = board_config.get("upload", {}).get("maximum_ram_size")
        flash = board_config.get("upload", {}).get("maximum_size")
        if ram and flash:
            data.append(
                "%s RAM, %s Flash" % (fs.format_filesize(ram), fs.format_filesize(flash))
            )
        return data

    def _get_debug_data():
        debug_tools = (
            board_config.get("debug", {}).get("tools") if board_config else None
        )
        if not debug_tools:
            return None
        data = [
            "DEBUG:",
            "Current",
            "(%s)"
            % board_config.get_debug_tool_name(env.GetProjectOption("debug_tool")),
        ]
        onboard = []
        external = []
        for key, value in debug_tools.items():
            if value.get("onboard"):
                onboard.append(key)
            else:
                external.append(key)
        if onboard:
            data.extend(["On-board", "(%s)" % ", ".join(sorted(onboard))])
        if external:
            data.extend(["External", "(%s)" % ", ".join(sorted(external))])
        return data

    def _get_packages_data():
        data = []
        for item in platform.dump_used_packages():
            original_version = util.get_original_version(item["version"])
            info = "%s %s" % (item["name"], item["version"])
            extra = []
            if original_version:
                extra.append(original_version)
            if "src_url" in item and int(ARGUMENTS.get("PIOVERBOSE", 0)):
                extra.append(item["src_url"])
            if extra:
                info += " (%s)" % ", ".join(extra)
            data.append(info)
        if not data:
            return None
        return ["PACKAGES:"] + ["\n - %s" % d for d in sorted(data)]

    for data in (
        _get_platform_data(),
        _get_hardware_data(),
        _get_debug_data(),
        _get_packages_data(),
    ):
        if data and len(data) > 1:
            print(" ".join(data))


def exists(_):
    return True


def generate(env):
    env.AddMethod(PioPlatform)
    env.AddMethod(BoardConfig)
    env.AddMethod(GetFrameworkScript)
    env.AddMethod(LoadPioPlatform)
    env.AddMethod(PrintConfiguration)
    env.AddMethod(ConvertToProjectOptions)
    return env

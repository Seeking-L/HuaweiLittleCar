import json
import time
import random
import asyncio
import inspect
import platformio.rpc.exception


# Return it from handler to notify that no need to send response now.
# Handler can use send_async_response or send_async_error to send response manually.
class AsyncResponse:
    pass


class Connection:
    def __init__(self, ws):
        self.connection_id = ''.join(f'{random.randint(0, 255):02x}' for _ in range(8))
        self.web_socket = ws


class HandlerManager:
    def __init__(self, logger):
        self.__logger = logger
        self.__handler_classes = {}
        self.__handlers = {}

    @property
    def connections(self):
        return list(self.__handlers.keys())

    def add_handler_class(self, namespace, klass):
        self.__handler_classes[namespace] = klass

    def open_connection(self, connection):
        self.__handlers[connection] = {}
        for namespace, klass in self.__handler_classes.items():
            if not issubclass(klass, Handler):
                raise TypeError(f"{klass} is not the subclass of Handler")
            self.__handlers[connection][namespace] = klass(connection=connection, manager=self, logger=self.__logger)

    def handle(self, connection, method, request):
        for namespace, handler in self.__handlers.get(connection, {}).items():
            for name, rpc_method in handler.methods().items():
                kwargs = {}
                if f'{namespace}.{name}' == method and 'params' in rpc_method['args']:
                    kwargs['params'] = request.get('params')
                if f'{namespace}.{name}' == method and 'request_id' in rpc_method['args']:
                    kwargs['request_id'] = request.get('id')
                if f'{namespace}.{name}' == method:
                    return rpc_method['func'](**kwargs)
        raise platformio.rpc.exception.MethodNotFoundError(request.get('id'), method)

    def close_connection(self, connection):
        for _, handler in self.__handlers.get(connection, {}).items():
            handler.on_close_connection()
        self.__handlers.pop(connection)

    def get_handler(self, connection, namespace):
        return self.__handlers.get(connection, {}).get(namespace, None)


class Handler:
    def __init__(self, connection, manager: HandlerManager, logger):
        self.manager = manager
        self.logger = logger
        self.connection = connection

    async def send_async_response(self, result, request_id):
        r = {"jsonrpc": "2.0", "result": result, "id": request_id}
        self.logger.log(self.logger.DEBUG, f'< outgoing message: {r}')
        await self.connection.web_socket.send(json.dumps(r))

    async def send_async_error(self, error, request_id):
        r = platformio.rpc.exception.RpcError(code=-32000, message=f'error: {error}', request_id=request_id).to_json()
        self.logger.log(self.logger.WARNING, f'< outgoing message: {r}')
        await self.connection.web_socket.send(json.dumps(r))

    def on_close_connection(self):
        pass

    def get_handler(self, namespace):
        return self.manager.get_handler(self.connection, namespace)

    @staticmethod
    def method(method=None):
        def decorator(function):
            def wrapper(*args, **kwargs):
                return function(*args, **kwargs)

            wrapper.rpc_method = method if method is not None else function.__name__
            wrapper.rpc_method_params = inspect.signature(function).parameters
            return wrapper

        return decorator

    def methods(self):
        return {getattr(self, attr).rpc_method: {'func': getattr(self, attr),
                                                 'args': getattr(self, attr).rpc_method_params}
                for attr in dir(self) if hasattr(getattr(self, attr), 'rpc_method')}


class RpcProtocol:
    def __init__(self, handler_manager, auto_stop_delay, logger):
        self.__handler_manager = handler_manager
        self.__auto_stop_delay = auto_stop_delay
        self.__auto_stop_cb = None
        self.logger = logger
        self.request_mapper = {}
        self.exit_code = 0
        self.token = ''.join(f'{random.randint(0, 255):02x}' for _ in range(8))
        self.local_host = "127.0.0.1"
        self.authentication_func = ['ide.listen_commands', 'app.get_state', 'ide.trace_data']

    def close(self):
        for connection in self.__handler_manager.connections:
            self.__handler_manager.close_connection(connection)

    def verify_session_sid(self, data):
        """
        SID: As credentials for login; Inject sid when listening_commands is requested for the first time.
        The following RPC request parameters contain sid.
        If the sid is different from the carried sid, the request is regarded as an error request.

        rpc_json: RPC request data
        namespaces: Range of RPC to be verified
        """
        rpc_json = json.loads(data)
        namespaces = ['app', 'ide', 'os', 'core', 'project']

        current_namespace = rpc_json['method'].split('.')[0]
        if rpc_json['method'] not in self.authentication_func and current_namespace in namespaces:
            rpc_params = rpc_json['params']
            if not self.token:
                message = f"Not logged in status"
                self.logger.error(message)
                raise platformio.rpc.exception.RpcError(code=-32000, message=message)
            if rpc_json['method'] == "core.call": # core.call params
                is_bad_sid = False
            else:
                is_bad_sid = rpc_params[-1] != self.token
        else:
            is_bad_sid = False
        return is_bad_sid

    def verify_headers_info(self, wr):
        """
        verify host/origin
        :wr: websocket request
        """
        message = None
        if self.local_host not in ''.join(wr.headers.get_all("host")):
            message = f"Request ip address is not allowed"

        user_agent = ''.join(wr.headers.get_all('user-agent'))
        if user_agent and not any(agent in user_agent for agent in ('Python', 'Electron')):
            message = f"Bad kernel: {user_agent}"
        if message:
            self.logger.error(message)
            raise platformio.rpc.exception.RpcError(code=-32000, message=message)

    def rpc_handle(self, connection, data):
        request = {}
        try:
            self.logger.info(f'> incoming message: {data}')
            request = json.loads(data)
            if 'method' not in request:
                raise platformio.rpc.exception.InvalidRpcError()
            result = self.__handler_manager.handle(connection=connection,
                                                   method=request['method'],
                                                   request=request)
            response = {"jsonrpc": "2.0", "result": result, "id": request['id']} if 'id' in request else None
            if isinstance(result, AsyncResponse):
                response = None

        except platformio.rpc.exception.RpcError as e:
            response = e.to_json()
        except json.JSONDecodeError:
            response = platformio.rpc.exception.ParseJsonError().to_json()
        except PermissionError:
            response = platformio.rpc.exception.PermissionRpcError(request_id=request.get('id')).to_json()
        except Exception as e:  # pylint: disable=broad-except
            response = platformio.rpc.exception.RpcError(code=-32000,
                                                         message=f'error: {e}',
                                                         request_id=request.get('id')).to_json()
        return response

    async def on_connected(self, wr, ws):
        """
        :ws: sanic.server.websockets.impl.WebsocketImplProtocol
        :wr: <Request: GET /wsrpc>
        """
        self.verify_headers_info(wr)
        connection = Connection(ws)
        self.__handler_manager.open_connection(connection)
        try:
            self.logger.info(f'Connection established "{connection.connection_id}"')
            while True:
                data = await ws.recv()
                is_bad_sid = self.verify_session_sid(data)
                response = dict(code=-32000, message='error: bad token') if is_bad_sid else \
                    self.rpc_handle(connection, data)
                if response:
                    self.logger.log(self.logger.WARNING if 'error' in response else self.logger.DEBUG,
                                    f'< outgoing message: {response}')
                    await ws.send(json.dumps(response))
        finally:
            self.__handler_manager.close_connection(connection)
            self.logger.info(f'Connection closed "{connection.connection_id}"')
            self.charge_auto_stop()

    def charge_auto_stop(self):
        if self.__auto_stop_cb is not None:
            self.__auto_stop_cb.cancel()
            self.__auto_stop_cb = None
        if self.__auto_stop_delay is not None:
            def auto_stop():
                if len(self.__handler_manager.connections) == 0:
                    self.logger.info('No more connections, stopping sever by timeout')
                    asyncio.get_event_loop().stop()

            self.__auto_stop_cb = asyncio.get_event_loop().call_later(self.__auto_stop_delay, auto_stop)

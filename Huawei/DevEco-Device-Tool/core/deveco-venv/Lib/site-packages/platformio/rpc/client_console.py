import sys
import queue
import threading
import base64
import asyncio
import collections
import serial.tools.miniterm
import jsonrpc_websocket
# noinspection PyPackageRequirements
import click
from platformio.compat import get_locale_encoding
from platformio.rpc.client_file_transfer import FileTransfer
from platformio.serial_miniterm import ConsoleStdin


class ExitCodeError(Exception):
    def __init__(self, code):
        super().__init__()
        self.code = code


class Console:
    def __init__(self, transport):
        # noinspection PyBroadException
        try:
            self.__console = serial.tools.miniterm.Console()
        except Exception:  # pylint: disable=broad-except
            self.__console = ConsoleStdin()
        self.__transport = transport
        self.__stdin = queue.Queue()
        self.__reader_thread_alive = False
        self.__stdin_last_commands = collections.deque(maxlen=3)

    async def execute(self, command, artifacts=None):
        exit_code = None
        try:
            encoding = 'UTF-8'
            if '--encoding' in command:
                encoding = command[command.index('--encoding') + 1]
            # start execution on operation server
            execution = await self.__transport.execution.start(cmd=command)
            execution_id = execution['execution_id']
            # setup console
            self.__console.setup()
            reader_thread = threading.Thread(target=self.__reader, name='console.reader')
            reader_thread.daemon = True
            self.__reader_thread_alive = True
            reader_thread.start()
            # communication loop
            while exit_code is None:
                in_data = bytearray()
                while not self.__stdin.empty():
                    in_data.extend(self.__stdin.get_nowait().encode())
                ExitCodeByUser = await self.__communicate(execution_id, in_data, encoding)
                if ExitCodeByUser:
                    break
                await asyncio.sleep(0.1)
        except ExitCodeError as e:
            exit_code = e.code
        except Exception as e:   # pylint: disable=broad-except
            click.secho('execute error', fg='red')
        finally:
            self.cancel()
        if artifacts:
            for f in artifacts:
                await FileTransfer(transport=self.__transport).download(f)
        return exit_code if exit_code is not None else -1

    def cancel(self):
        self.__reader_thread_alive = False
        self.__console.cancel()
        self.__console.cleanup()

    def __reader(self):
        while self.__reader_thread_alive:
            try:
                c = self.__console.getkey()
            except KeyboardInterrupt:
                c = '\x03'
            self.__stdin.put(c)
            self.__stdin_last_commands.append(c)

    async def __communicate(self, execution_id, stdin_data, encoding):
        request = {'execution_id': execution_id}
        if stdin_data:
            request['stdin'] = base64.b64encode(stdin_data).decode()
        try:
            response = await self.__transport.execution.communicate(**request)
        except jsonrpc_websocket.TransportError as e:
            raise ExitCodeError(-1) from e
        except ConnectionResetError as e:
            raise ExitCodeError(-1) from e
        encoding = encoding or get_locale_encoding() or "utf8"
        self.__console.write_bytes(
            base64.b64decode(response.get('stderr', b'')).decode(
                encoding, errors='backslashreplace').encode("utf8", errors='backslashreplace'))
        self.__console.write_bytes(
            base64.b64decode(response.get('stdout', b'')).decode(
                encoding, errors='backslashreplace').encode("utf8", errors='backslashreplace'))
        code = response.get('exit_code')
        if code is not None:
            raise ExitCodeError(code)
        # user pressed Ctrl-C 3 times sequentially, terminate console
        if self.__stdin_last_commands.maxlen == len(self.__stdin_last_commands) and \
                all(x == '\x03' for x in self.__stdin_last_commands):
            return True

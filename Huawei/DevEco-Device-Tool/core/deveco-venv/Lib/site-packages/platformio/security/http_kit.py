"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.
Create: 2021-10-13
"""
# !/usr/bin/env python
# -*- coding: utf-8 -*-

"""
http_kit: Some HTTP-related tools
"""
import os
import re
import requests
import OpenSSL
import time
from threading import Thread
from threading import Lock
from platformio import app
from platformio.helpers import get_config_json_path

SETTINGS_PATH = os.path.join(get_config_json_path(), "settings.json")
CERTIFICATE_VERIFICATION_INTERVAL = 24 * 60 * 60 * 1000
LOCK = Lock()


def check_certificate_revoked(certificate_path, proxies, headers):
    """
    Check whether the certificate in the path is revoked.
    :param certificate_path: Certificate folder path
    :param proxies: Whether proxy is required
    :param headers: Request header
    :return: whether the check is passed.
    """
    files = os.listdir(certificate_path)
    result = []
    threads = []
    for file in files:
        thread = Thread(target=check_certifiacate, args=(certificate_path, proxies, headers, file, result))
        thread.start()
        threads.append(thread)
    for thread in threads:
        thread.join()
    return not result


def request_cerify(crl_url, proxies, headers, result, cert):
    try:
        if proxies is None:
            response = requests.get(crl_url, timeout=(3, 3), headers=headers)
        else:
            response = requests.get(crl_url, proxies=proxies, headers=headers, timeout=(3, 3))
    except requests.exceptions.RequestException:
        return
    if response.status_code != 200:
        LOCK.acquire()
        result.append(0)
        LOCK.release()
        return

    revoked_objects = OpenSSL.crypto.load_crl(
        OpenSSL.crypto.FILETYPE_ASN1, response.content).get_revoked()
    if revoked_objects is None:
        return

    for rvk in revoked_objects:
        if hex(cert.get_serial_number()) == f"0x{rvk.get_serial().decode('utf-8')}":
            LOCK.acquire()
            result.append(0)
            LOCK.release()


def check_certifiacate(certificate_path, proxies, headers, file, result):
    certificate_file = os.path.join(certificate_path, file)

    with open(certificate_file, 'r') as file_read:
        cert = OpenSSL.crypto.load_certificate(
            OpenSSL.crypto.FILETYPE_PEM, file_read.read())
        index = -1
        for i in range(0, cert.get_extension_count()):
            if cert.get_extension(i).get_short_name().decode(
                    "UTF-8") == "crlDistributionPoints":
                index = i
                break
        if index == -1:
            return
        crl_dp = cert.get_extension(
            index).get_data().decode("unicode_escape")
        crl_urls = re.findall(r'http:[^:]*crl', crl_dp, re.I)
        sub_threads = []
        for crl_url in crl_urls:
            sub_thread = Thread(target=request_cerify, args=(crl_url, proxies, headers, result, cert))
            sub_thread.start()
            sub_threads.append(sub_thread)

        for sub_thread in sub_threads:
            sub_thread.join()


def cert_expired(host):
    with app.State(SETTINGS_PATH, lock=False) as s:
        invalidation = s.get(host, 0)
        return invalidation < int(time.time() * 1000)


def update_cert_expire(host):
    with app.State(SETTINGS_PATH, lock=True) as s:
        s.update({host: int(time.time() * 1000) + CERTIFICATE_VERIFICATION_INTERVAL})

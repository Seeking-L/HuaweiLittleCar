#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
Description:
Create: 2022-03-17
"""
import os
import sys
import re
import json
import psutil
import socket
import asyncio
import websockets
from subprocess import Popen, DEVNULL
from functools import wraps
from typing import Type
from shlex import quote
from platformio.helpers import get_platformio_packages_path, get_config_json_path
from platformio.helpers import get_installed_core_path
from platformio.proc import shutdown_process_by_port
from platformio.managers.platform import PlatformFactory
from platformio.exception import UnknownPlatform
from platformio.commands.exception import UnknownError, NetWorkConnectError, PlatformioLowLevelError

TOOLKIT_COUNTRY_CODE = 'CN'
IS_LINUX = sys.platform == "linux"
TOOLKIT_TRACE_SERVER_DATA_SOURCE = 'DevEcoDeviceTool'
TOOLKIT_TRACE_SERVER_HOST = '127.0.0.1'
TOOLKIT_TRACE_SERVER_PORT = 10553 if IS_LINUX else 10554
THREAD_DELAY_TIME = 30
THREAD_CYCLE_TIME = 30
PROGRAM_EXIT_DELAY_TIME = 5
WRITE_HEART_BEAT_TIME = 30
SERVER_LAUNCH_TIMEOUT = 5 * 60
START_TRACE_SERVICE = True  # trace service switch
TRACE_SERVICE_JAR = 'traceservice.jar'
OPEN_JDK = 'tool_openjdk_jre'
TOOL_TRACE = "tool_trace"
TRACE_SID = "10000"  # service identifier
LOG_PATH = get_config_json_path()


def service_started():
    try:
        for proc in psutil.process_iter(['cmdline']):
            if proc.info['cmdline'] and set(['-jar', TRACE_SERVICE_JAR]).issubset(set(proc.info['cmdline'])):
                return True
    except Exception as e:  # pylint: disable=broad-except
        UnknownError(e)
        return False
    return False


def _send_message(para):
    if TraceData.client_sock is not None:
        para_str = json.dumps(para)
        msg = bytes(para_str, encoding='utf8')
        TraceData.client_sock.send(
            bytes('{:0>4d}'.format(len(msg)), encoding='utf8') + msg
        )


def _send_country_code(code):
    para = {
        'type': 'setCountryCode',
        'datas': {
            'countryCode': code
        }
    }
    _send_message(para)


def _send_save_address(service):
    para = {
        'type': 'setTraceFileSaveAddress',
        'datas': {
            'serviceFlag': service
        }
    }
    _send_message(para)


def _get_version():
    version = ""
    try:
        full_version_path = os.path.join(get_installed_core_path(), "version_full.json")
        with open(full_version_path, "r", encoding="utf8") as fp:
            path_dict = json.loads(fp.read())
        if path_dict:
            version = path_dict.get("version")
    except Exception as e:
        UnknownError(e)
    finally:
        version = version if version else ''
    return version


def _send_trace_data(sid, action, detail):
    para = {
        'type': 'trace',
        'datas': {
            'sid': sid,
            'uid': '',
            'version': _get_version(),
            'action': f"DevEcoDeviceTool.{action}",
            'detail': detail
        }
    }
    _send_message(para)


def _ensure_service_started():
    """
    Start trace serive,
    which accept socket connection and send data to remote server.
    """
    if not service_started():
        core_path = get_platformio_packages_path()
        trace_tool_path = os.path.abspath(
            os.path.join(core_path, TOOL_TRACE)
        )
        java_tool_path = os.path.abspath(
            os.path.join(
                core_path, OPEN_JDK, 'bin', 'java'
            )
        )
        cmd_args = [
            java_tool_path,
            '-Dlog.path=%s' % LOG_PATH,
            '-Xms64m', '-Xmx64m', '-XX:ParallelGCThreads=8',
            '-XX:+UseConcMarkSweepGC', '-XX:+UseParNewGC',
            '-noclassgc', '-jar', TRACE_SERVICE_JAR,
            'threadDelayTime=%d' % THREAD_DELAY_TIME,
            'threadCycleTime=%d' % THREAD_CYCLE_TIME,
            'programExitDelayTime=%d' % PROGRAM_EXIT_DELAY_TIME,
            'writeHeartbeatTime=%d' % WRITE_HEART_BEAT_TIME,
            'socketServerPort=%d' % TOOLKIT_TRACE_SERVER_PORT,
            'countryCode=%s' % TOOLKIT_COUNTRY_CODE,
            'fileSaveAddress=%s' % TOOLKIT_TRACE_SERVER_DATA_SOURCE,
            'ideVersion=%s' % quote(_get_version())
        ]
        Popen(cmd_args, cwd=trace_tool_path, shell=False, stdout=DEVNULL)

    return service_started()


def start_trace_service():
    result = False
    try:
        result = _ensure_service_started()
    except Exception as e:  # pylint: disable=broad-except
        UnknownError(e)
    return result


def stop_trace_service():
    return shutdown_process_by_port(TOOLKIT_TRACE_SERVER_PORT)


class TraceData(object):
    """
    Use to trace functions,
    it will connect to trace service and send trace data to it
    """
    client_sock = None

    def __init__(self, sid, action, detail=None):
        if detail is None:
            detail = {}
        self.sid = sid
        self.action = action
        self.detail = detail

    def __call__(self, func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            self.trace()
            return func(*args, **kwargs)

        return wrapped_function

    @staticmethod
    def trace_data(sid, action, detail):
        """
        :param sid: service identifier
        :param action: brief action description
        :param detail: additional detailed information description
        """
        if not START_TRACE_SERVICE:
            return

        if TraceData.client_sock is None:
            TraceData.client_sock = socket.socket(
                socket.AF_INET, socket.SOCK_STREAM)
            TraceData.client_sock.settimeout(50)
            TraceData.client_sock.setsockopt(
                socket.SOL_SOCKET, socket.SO_KEEPALIVE, True)
            try:
                TraceData.client_sock.connect(
                    (TOOLKIT_TRACE_SERVER_HOST, TOOLKIT_TRACE_SERVER_PORT)
                )
            except socket.timeout:
                TraceData.client_sock = None
            except ConnectionRefusedError:
                TraceData.client_sock = None

        if TraceData.client_sock is not None and service_started():
            detail = detail if detail is not None else {}
            detail['dataSource'] = TOOLKIT_TRACE_SERVER_DATA_SOURCE
            _send_trace_data(sid, action, detail)

    def trace(self):
        try:
            TraceData.trace_data(self.sid, self.action, self.detail)
        except Exception as e:  # pylint: disable=broad-except
            UnknownError(e)


class HpmTrace(TraceData):
    """
    HPM Trace interface
    """
    action = "Hpm"
    trace_fields = (
        "bundleName", "succeeded", "projectName", "startTime", "endTime", "causes"
    )

    @staticmethod
    def parameter_validate(*args):
        return True

    def __assemble_data(self, *args):
        """
        Assemble the trace fields and input parameters into a dictionary.
        """
        return dict(
            zip(self.trace_fields, args)
        )

    @staticmethod
    def version(*args) -> dict:
        """
        hpm version trace
        """
        if not isinstance(args[0], dict):
            raise TypeError
        return args[0]

    def install(self, *args) -> dict:
        """
        hpm install bundle
        """
        self.parameter_validate(*args)
        return self.__assemble_data(*args)

    def uninstall(self, *args) -> dict:
        """
        hpm uninstall bundle
        """
        self.parameter_validate(*args)
        return self.__assemble_data(*args)

    def update(self, *args) -> dict:
        """
        hpm update bundle
        """
        self.parameter_validate(*args)
        return self.__assemble_data(*args)

    @staticmethod
    def index() -> dict:
        """
        The HPM page is displayed.
        """
        return {'succeeded': True}

    @staticmethod
    def search(bundle_name, result) -> dict:
        """
        hpm search bundle
        param bundle_name: str,
        param result: list, hpm search results
        """
        r = []
        for item in result:
            for k in item:
                if k in ['manifest']:
                    r.append(item.get(k))
        return dict(
            zip(("bundleName", "result"), (bundle_name, r))
        )

    def init(self, *args) -> dict:  # pylint = disable=W
        """
        trace create bundle, Unused Features
        """
        pass  # pylint: disable=W0107


class ActsTrace(TraceData):
    """
    Acts Trace interface
    """
    action = "Acts"
    trace_fields = (
        "casetypes", "projectName", "exectime", "board", "succeeded"
    )

    def case_types(self, case_types, project_name) -> dict:
        """
        param case_types: list, test case list
        param project_name: str, project name
        """
        if not isinstance(case_types, list):
            raise TypeError
        if not case_types:
            raise ValueError
        return dict(zip(
            self.trace_fields[0:2], (case_types, project_name)
        ))

    @staticmethod
    def build_xts(*args) -> dict:
        """
        User build xts
        param exectime: float, Test Case Execution Time
        param board: str, Test Board Type
        param projectName: str, project name
        param succeeded: bool
        """
        return args[0]

    @staticmethod
    def exec_cases(*args) -> dict:
        """
        User Executing Test Cases
        param exectime: float, Test Case Execution Time
        param board: str, Test Board Type
        param cases: str, Test Board Type
        param projectName: str, project name
        param succeeded: bool, Test whether the test case is success executed
        """
        return args[0]

    @staticmethod
    def index() -> dict:
        """
        The action configuration page is displayed.
        """
        return {'succeeded': True}


class ProjectManager(TraceData):
    action = "Project"

    @staticmethod
    def parameter_process(params):
        """
        process parameter,projectDir-->projectName
        params:["hisilicon_arm", "hi3516dv300", "hpm", "C:\\xxx\\sourcecode",
                "@ohos/hispark_taurus", {"manifest": xxx}, None]
        return:["hisilicon_arm", "hi3516dv300", "hpm", "sourcecode",...]
        """
        _params = list(map(lambda x: os.path.split(x)[1] if isinstance(x, str) and os.path.isdir(x) else x, params))
        return _params

    def hpm_download_project(self, params: list) -> dict:
        """
        Initialize project dotting
        params:["hisilicon_arm", "hi3516dv300", "hpm", "C:\\xxx\\sourcecode",
                "@ohos/hispark_taurus", {"manifest": {"description": "local"},
                "name": "dist", "version": "latest"}, null]
        """
        trace_fields = (
            "platform", "board", "framework", "projectName", "hpmBasePackage",
            "hpmTemplate", "chipPackagePath", "generatCode", "envPrefix", "succeeded", "errorCause", "startTime",
            "endTime"
        )
        _params = self.parameter_process(params)
        return dict(zip(trace_fields, _params))

    def create_project(self, params: list) -> dict:
        """
        Initialize project dotting
        params:["hisilicon_arm", "hi3516dv300", "hpm", "C:\\xxx\\sourcecode",
                "@ohos/hispark_taurus", {"manifest": {"description": "local"},
                "name": "dist", "version": "latest"}, null]
        """
        trace_fields = (
            "platform", "board", "framework", "projectName", "hpmBasePackage",
            "hpmTemplate", "chipPackagePath", "generatCode", "envPrefix", "succeeded", "errorCause"
        )
        _params = self.parameter_process(params)
        return dict(zip(trace_fields, _params))

    def import_project(self, params: list) -> dict:
        """
        Import project dotting
        params：["hisilicon_arm", ["hi3516dv300"], "hpm", "D:\\xxx\\sourcecode"]
        """
        trace_fields = (
            "platform", "board", "framework", "chipPackagePath", "projectName", "hpmBasePackage",
            "succeeded", "errorCause"
        )
        _params = self.parameter_process(params)
        trace_value = [k[0] if isinstance(k, list) else k for k in _params]
        return dict(zip(trace_fields, trace_value))

    def create_project_by_source(self, params: list) -> dict:
        """
        create project by oh source

        params：[duration,version_name,is_succeeded,error_causes]
        """
        trace_fields = (
            "duration", "version_name", "succeeded", "errorCause"
        )
        _params = self.parameter_process(params)
        return dict(zip(trace_fields, _params))


class TaskTrace(TraceData):
    '''
    project Task dotting
    '''
    action = "Task"
    trace_fields = {
        'succeeded', "duration", "protocol",
        "vendor", "board", "level"
    }

    @staticmethod
    def __assemble_data(name, config, result, is_remote):  # pylint: disable=R0201
        """
        process data
        is_remote:Whether the burning mode is remote
        """
        env_config = config.items(env=name, as_dict=True)
        try:
            platform = PlatformFactory.newPlatform(env_config["platform"])
            board_config = platform.board_config(env_config["board"])
            level = board_config.get("build", {}).get("device_level", -1)
        except UnknownPlatform:
            level = -1
        is_success = isinstance(result.get('succeeded'), bool)
        return {
            'succeeded': is_success,
            'duration': round(result.get("duration", 0), 3),
            "protocol": env_config.get("upload_protocol", ''),
            'vendor': env_config.get("platform", ''),
            'board': env_config.get("board", ''),
            "level": level,
            "is_remote": is_remote,
            "causes": result.get('succeeded') if not is_success else "",
            "startTime": round(result.get("startTime", 0), 3),
            "endTime": round(result.get("endTime", 0), 3),
        }

    def clean(self, *args) -> dict:
        """
        clean Task dotting
        """
        return self.__assemble_data(*args)

    def buildprog(self, *args) -> dict:
        """
        build Task dotting
        """
        return self.__assemble_data(*args)

    def erase(self, *args) -> dict:
        """
        Erase Task dotting
        """
        return self.__assemble_data(*args)

    def upload(self, *args):
        """
        upload Task dotting
        """
        data = self.__assemble_data(*args)
        self.trace_data('10000', 'upload', data)


class RemoteTrace(TraceData):
    action = "Remote"

    def connect(self, is_success, duration) -> dict:  # pylint: disable=R0201
        """
        Enable Remote,Only the connection success.
        The IP address of the connection is not recorded.
        """
        return {'succeeded': is_success, 'duration': duration}

    @staticmethod
    def upload(*args) -> dict:  # pylint = disable=W
        """
        Burning Files in Remote Mode
        """
        remote_upload_data = {"succeeded": True, "operateType": "upload", "dataSource": "DevEcoDeviceTool"}
        remote_upload_data.update({"platform": args[0], "fileName": args[1], "fileSize": args[2],
                                   "startTime": args[3], "endTime": args[4]})
        return remote_upload_data

    @staticmethod
    def download(*args) -> dict:  # pylint = disable=W
        """
        Burning Files in Remote Mode
        """
        remote_download_data = {"succeeded": True, "operateType": "download", "dataSource": "DevEcoDeviceTool"}
        remote_download_data.update({"platform": args[0], "fileName": args[1], "fileSize": args[2],
                                     "startTime": args[3], "endTime": args[4]})
        return remote_download_data  # pylint: disable=W0107

    def device(self, *args):  # pylint = disable=W
        """
        Obtaining Remote Device Information
        """
        pass  # pylint: disable=W0107

    def debug(self, *args):  # pylint = disable=W
        """
        Remote Debugging Code
        """
        pass  # pylint: disable=W0107


class DebugTrace(TraceData):

    def debug(self, *args) -> dict:  # pylint = disable=W
        """
        debug data,interface:gdb/server
        LOAD_CMDS:
        MONITOR_PORT:
        DEBUG_INTERFACE:
        DEBUG_SPEED:
        """
        pass  # pylint: disable=W0107


class CheckTrace(TraceData):
    """
    Unused Features
    """
    pass  # pylint: disable=W0107


class ProfilingTrace(TraceData):
    """
    profiling trace
    """

    def profiling_load(self, *args) -> dict:  # pylint = disable=W
        """
        Import historical data for analysis
        """
        pass  # pylint: disable=W0107

    def live_device(self, *args) -> dict:  # pylint = disable=W
        """
        output information of online devices
        """
        pass  # pylint: disable=W0107


class HdfTrace(TraceData):
    """
    Hdf trace
    """
    action = "Hdf"
    trace_fields = (
        "productName", "succeeded"
    )

    @staticmethod
    def index() -> dict:
        """
        The HDF page is displayed.
        """
        return {'succeeded': True}

    def add(self, *args) -> dict:
        """
        hdf add driver
        param productName: str,Name of the product add driver
        param succeeded: bool,driver add is succeed
        """
        return dict(
            zip(self.trace_fields, args)
        )


class ScaffoldTrace(TraceData):
    """
    Scaffold trace
    """
    action = 'Scaffold'
    trace_fields = (
        'vendor', 'product', 'board', 'inherit_product'
    )

    def add(self, *args) -> dict:
        """
        add new product
        """
        return dict(
            zip(self.trace_fields, args)
        )


class RepoTrace(TraceData):
    """
    trace download source using repo
    """
    action = 'Repo'
    trace_fields = (
        'protocol', 'stage', 'succeeded'
    )

    def download(self, *args) -> dict:
        """
        repo download
        """
        return dict(
            zip(self.trace_fields, args)
        )


class TraceOperate(object):

    def __init__(self, trace_factory: Type[TraceData]):
        self.handler_factory = trace_factory

    def operate(self, action, operate_type, *args):
        try:
            handler_klass = self.handler_factory(TRACE_SID, action)
            if hasattr(handler_klass, operate_type):
                # handle project path in args
                # such as: D:\download\code-1.1.0 ——> code-1.1.0
                params = self.__handler_project_name(*args)
                trace_data = getattr(handler_klass, operate_type)(*params)
                if trace_data:
                    # data dict add key: operateType
                    trace_data.update(
                        # small hump
                        {"operateType": re.sub(r"_(\w)", lambda match: match.group(1).upper(), operate_type)}
                    )
                    # sends data to the socket
                    handler_klass.trace_data(TRACE_SID, action, trace_data)
        except Exception as e:  # pylint: disable=W0703
            UnknownError(e)

    @staticmethod
    def __handler_project_name(*args):
        """
        Processes the path in the parameter as a file name and returns all parameters
        param project_path: str
        """
        _res = []
        for arg in args:
            try:
                # isdir() is insecure function
                if os.path.isdir(arg):
                    _, project_name = os.path.split(arg)
                    _res.append(project_name)
                    continue
                _res.append(arg)
            except TypeError:
                _res.append(arg)
        return _res


class ComponentTrace(TraceData):
    """
    trace component tools process
    """
    action = 'Component'
    trace_fields = (
        'event', 'succeeded'
    )

    def gen_product_cfg(self, *args) -> dict:
        """
        generate product config
        """
        return dict(
            zip(self.trace_fields, args)
        )

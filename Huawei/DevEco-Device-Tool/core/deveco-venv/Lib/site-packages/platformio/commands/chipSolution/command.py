#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
Description: Chip Solution Manager
Create: 2021-08-23
"""

import os
import json
import subprocess
import click
from typing import List
from xml.etree import ElementTree
from xml.dom.minidom import parseString
from platformio.commands.exception import PlatformioFileNotFound, PlatformioFailedToParseFile
from . import utils


@click.group(short_help="Chip Solution Manager")
def cli():
    pass


@cli.command("config-info", short_help="Obtain the code repository configuration information of the chip solution.")
@click.option("--project", required=True)
@click.pass_context
def config_info(ctx, project: str):
    bundle_json_path = os.path.join(project, '.deveco', 'profile', 'bundle.json')
    existed, file = utils.check_file_exist(bundle_json_path)
    if not existed:
        click.echo(json.dumps({"success": False, "message": "fileNotExist", "messageParams": [file]}))
        raise PlatformioFileNotFound(bundle_json_path)

    product_company_name, board_company_name = utils.get_product_company_and_board_company_name(bundle_json_path)
    if not all([product_company_name, board_company_name]):
        click.echo(json.dumps(
            {"success": False, "message": "failedToParseFile", "messageParams": {"filePath": bundle_json_path}}))
        raise PlatformioFailedToParseFile(bundle_json_path)

    manifest = utils.serialized_manifest_data(project, product_company_name, board_company_name)
    is_empty_xml_created = False
    try:
        tree = ElementTree.parse(manifest.get('xmlPath'))
        root = tree.getroot()
    except (ElementTree.ParseError, FileNotFoundError):
        is_empty_xml_created = True
        root = ElementTree.fromstring("<manifest></manifest>")

    remotes_data = {}
    remotes = root.findall('remote')

    repos_path_list: List[str] = []

    for remote in remotes:
        remote_name = remote.attrib.get('name')
        remote_fetch = remote.attrib.get('fetch')
        remotes_data[remote_name] = remote_fetch

    projects = root.findall('project')
    for project_el in projects:
        remote = project_el.attrib.get('remote')
        project_data = utils.serialized_project_data(project_el, remotes_data, remote)

        if project_el.attrib.get("path") == os.path.join('vendor', product_company_name):
            manifest['vendor'] = project_data
        elif project_el.attrib.get("path") == os.path.join('device', board_company_name):
            manifest['device'] = project_data
        else:
            repos_path_list.append(os.path.join(project, project_el.attrib.get("path")))
            manifest.get('extendProjects').append(project_data)

    manifest["existRepos"] = manifest["existRepos"] and utils.check_exist_repos(*repos_path_list)
    if is_empty_xml_created:
        form_data = utils.manifest_to_form(manifest)
        ctx.invoke(save_config_info, project=project, form_str=json.dumps(form_data), suppressed=True)

    click.echo(json.dumps({"success": True, "data": manifest, "message": ""}))


@cli.command("save-config-info",
             short_help="Save the code repository configuration information of the chip solution.")
@click.option("--project", required=True)
@click.option("--form-str", required=True)
@click.option("--suppressed", is_flag=True)
def save_config_info(project: str, form_str: str, suppressed: bool):
    form = json.loads(form_str)
    xml_path = utils.get_profile_xml_path(project)
    root = ElementTree.Element("manifest")

    remotes = {}

    primary_repo, sub_repo = utils.get_primary_repo_url_and_sub_repo_name(form.get("deviceRepoAddress"))
    utils.create_remote(remotes, root, primary_repo)
    utils.create_project_element(root, {
        "name": sub_repo,
        "path": form.get("devicePath"),
        "revision": form.get("deviceRevision"),
        "remote": remotes.get(primary_repo)
    })

    primary_repo, sub_repo = utils.get_primary_repo_url_and_sub_repo_name(form.get("vendorRepoAddress"))
    if not remotes.get(primary_repo):
        utils.create_remote(remotes, root, primary_repo)

    utils.create_project_element(root, {
        "name": sub_repo,
        "path": form.get("vendorPath"),
        "revision": form.get("vendorRevision"),
        "remote": remotes.get(primary_repo)
    })

    for extendProject in form.get("extendProjects", []):
        primary_repo, sub_repo = utils.get_primary_repo_url_and_sub_repo_name(extendProject.get("repoAddress"))
        if not remotes.get(primary_repo):
            utils.create_remote(remotes, root, primary_repo)

        utils.create_project_element(root, {
            "name": sub_repo,
            "path": extendProject.get("path"),
            "revision": extendProject.get("revision"),
            "remote": remotes.get(primary_repo)
        })

    xml_string = ElementTree.tostring(root)
    xml_write = parseString(xml_string)
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    with os.fdopen(os.open(xml_path, flags, 0o640), "w") as fp:
        xml_write.writexml(fp, addindent=' ' * 4, newl='\n', encoding='utf-8')

    if not suppressed:
        click.echo(json.dumps({"success": True}))


@cli.command("clone-code", short_help="Cloning the Source Code of the Chip Solution")
@click.option("--project", required=True)
def clone_code(project: str):
    tree = ElementTree.parse(utils.get_profile_xml_path(project))
    root = tree.getroot()

    remote_map: dict = {}
    remotes: List[ElementTree.Element] = root.findall('remote')
    for remote in remotes:
        remote_map[remote.attrib.get('name')] = remote.attrib.get('fetch')

    project_elements: List[ElementTree.Element] = root.findall('project')

    no_pull_projects: List[ElementTree.Element] = []

    successes: List[str] = []
    failed: List[str] = []

    for project_element in project_elements:
        project_remote: str = project_element.get('remote')
        remote_fetch: str = remote_map.get(project_remote)
        if not remote_fetch:
            no_pull_projects.append(project_element)
            continue

        repo_url: str = "/".join([remote_fetch.rstrip("/"), project_element.attrib.get("name") + '.git'])
        click.secho(f"Cloning {repo_url}", fg="blue")

        (dir_path, dirname) = os.path.split(project_element.attrib.get("path"))
        clone_path = os.path.join(project, dir_path)

        if not os.path.exists(clone_path):
            os.makedirs(clone_path, mode=0o700)

        try:
            result = subprocess.run(
                ["git", "clone", repo_url, dirname, '-b', project_element.attrib.get("revision")],
                cwd=clone_path, encoding="utf-8")
        except FileNotFoundError as e:
            click.echo(e)
            no_pull_projects.append(project_element)
            continue
        else:
            if result.returncode:
                click.secho(f"ErrorCode: {result.returncode}", fg="red")
                click.secho(f"Failed to clone {repo_url}\n\n", fg="red")
                failed.append(project_element.attrib.get("path"))
            else:
                click.secho(f"Successfully cloned {repo_url}\n\n", fg="green")
                successes.append(project_element.attrib.get("path"))

    utils.print_clone_result(successes, failed)
    return True

# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-arguments, too-many-statements
# pylint: disable=too-many-locals, too-many-branches

import os
import sys
import socket
from os.path import isfile
from platformio import app, exception, fs
from platformio.commands.debug import helpers
from platformio.commands.debug.exception import DebugInvalidOptionsError
from platformio.project.config import ProjectConfig
from platformio.project.exception import ProjectEnvsNotAvailableError
from platformio.project.helpers import is_platformio_project, load_project_ide_data
from platformio.commands.debug.process.server import DebugServer
from platformio.commands.debug.process.remote_server import RemoteDebugServer
from platformio.commands.debug.process.hssclient import HSSClient
from platformio.commands.debug.process.client import GDBClient

# noinspection PyPackageRequirements
import click


@click.command(
    "debug",
    context_settings=dict(ignore_unknown_options=True),
    short_help="DevEco Unified Debugger",
)
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option(
    "-c",
    "--project-conf",
    type=click.Path(
        exists=True, file_okay=True, dir_okay=False, readable=True, resolve_path=True
    ),
)
@click.option("--environment", "-e", metavar="<environment>")
@click.option("--verbose", "-v", is_flag=True)
@click.option("--interface", type=click.Choice(["gdb", "server",
                     "vartrace_gdb", "hss"]))
@click.option("--server-arguments", default='default')
@click.option("--client-port", default='')
@click.option("--force-local", is_flag=True, default=None)
@click.argument("__unprocessed", nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def cli(ctx, **kwargs):
    project_dir = kwargs.get("project_dir")
    project_conf = kwargs.get("project_conf")
    environment = kwargs.get("environment")
    verbose = kwargs.get("verbose")
    interface = kwargs.get("interface")
    server_arguments = kwargs.get("server_arguments")
    client_port = kwargs.get("client_port")
    force_local = kwargs.get("force_local")
    __unprocessed = kwargs.get("__unprocessed")

    app.set_session_var("custom_project_conf", project_conf)
    force_local = not os.environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    # use env variables from Eclipse or CLion
    for sysenv in ("CWD", "PWD", "PLATFORMIO_PROJECT_DIR"):
        if is_platformio_project(project_dir):
            break
        if os.getenv(sysenv):
            project_dir = os.getenv(sysenv)

    with fs.cd(project_dir):
        env_name, debug_options, chip_package_path = _get_env_debug_options(
            project_conf, environment, ctx, server_arguments, project_dir)

    configuration = load_project_ide_data(project_dir, env_name)
    if not configuration:
        raise DebugInvalidOptionsError("Could not load debug configuration")

    try:
        fs.ensure_udev_rules()
    except exception.InvalidUdevRules as e:
        click.echo(helpers.escape_gdbmi_stream("~", str(e) + "\n") if helpers.is_gdbmi_mode() else str(e) + "\n",
                   nl=False)

    debug_options["load_cmds"] = helpers.configure_esp32_load_cmds(
        debug_options, configuration)

    if interface == "server":
        upload_args = dict(ctx=ctx, project_dir=project_dir, env_name=env_name, verbose=verbose)
        _upload_project(debug_options, configuration, upload_args)

    if not isfile(configuration["prog_path"]):
        if not configuration['is_custom_prog_path']:
            error_msg = "Program/firmware is missed. Check project option 'debug_elf'. "\
                        f"{'Check project option `debug_elf`='}"\
                        f"'{configuration['prog_path']}'"
            raise DebugInvalidOptionsError(error_msg)

    if not client_port:
        client_port = debug_options["port"]

    variables = _get_variables(project_dir, configuration, debug_options, client_port)

    interface_args = dict(
        project_dir=project_dir, env_name=env_name, variables=variables, configuration=configuration,
        force_local=force_local, debug_options=debug_options, chip_package_path=chip_package_path, unprocessed=__unprocessed)

    _handle_interfaces(interface, interface_args)

    return True


def _get_env_debug_options(project_conf, environment, ctx, server_arguments, project_dir):
    config = ProjectConfig.get_instance(project_conf)
    config.validate(envs=[environment] if environment else None)

    env_name = environment or helpers.get_default_debug_env(config)
    env_options = config.items(env=env_name, as_dict=True)
    chip_package_path = env_options.get("chip_package_path")
    if not set(env_options.keys()) >= {"platform", "board"}:
        raise ProjectEnvsNotAvailableError()
    debug_options = helpers.validate_debug_options(
        ctx, env_options, server_arguments, project_dir)
    if not debug_options:
        raise ValueError(f"Invalid value: {debug_options}")

    return (env_name, debug_options, chip_package_path)


def _get_variables(project_dir, configuration, debug_options, client_port):
    variables = {
        'PROJECT_DIR': project_dir,
        'PROG_PATH': configuration["prog_path"],
        'BUILD_OUT_DIR': configuration['build_out_dir'],
        'PROG_DIR': os.path.dirname(configuration["prog_path"]),
        'PROG_NAME': os.path.basename(os.path.splitext(configuration["prog_path"])[0]),
        'DEBUG_PORT': debug_options["port"],
        'CLIENT_PORT': client_port,
        'ENTRY_POINT': configuration.get('debug_entry_point'),
        'INIT_BREAK': configuration.get('debug_init_break'),
        'UPLOAD_PROTOCOL': debug_options.get("upload_protocol"),
        'LOAD_CMDS': '\n'.join(debug_options.get("load_cmds",  [])),
        'MONITOR_PORT': configuration.get('monitor_port'),
        'EXIT_CMDS': '\n'.join(debug_options.get("exit_cmds", [])),
        'DEBUG_INTERFACE': debug_options["interface"],
        'DEBUG_SPEED': debug_options["speed"],
        'DEBUG_DEVICE': debug_options["device"],
        'DEBUG_SCRIPT': debug_options.get("script", '')
    }
    return variables


def _upload_project(debug_options, configuration, upload_args):
    ctx = upload_args.get('ctx')
    project_dir = upload_args.get('project_dir')
    env_name = upload_args.get('env_name')
    verbose = upload_args.get('verbose')

    load_mode = debug_options["load_mode"]
    if load_mode == "always":
        helpers.upload_project(ctx, project_dir, env_name, verbose)
    elif load_mode == "modified":
        if helpers.is_prog_obsolete(configuration["prog_path"]):
            helpers.upload_project(ctx, project_dir, env_name, verbose)


def _handle_interfaces(interface, interface_args):
    interface_table = {
        "server": _handle_interface_server,
        "gdb": _handle_interface_gdb,
        "hss": _handle_interface_hss,
        "vartrace_gdb": _handle_interface_var_gdb
    }
    interface_table[interface](interface_args)


def _handle_interface_server(interface_args):
    project_dir = interface_args.get('project_dir')
    env_name = interface_args.get('env_name')
    variables = interface_args.get('variables')
    configuration = interface_args.get('configuration')
    force_local = interface_args.get('force_local')
    debug_options = interface_args.get('debug_options')

    if force_local:
        click.secho('DebugMode: local', fg='cyan')
        server = DebugServer(project_dir=project_dir,
                                env=env_name,
                                variables=variables,
                                debug_options=debug_options)
    else:
        click.secho('DebugMode: remote', fg='cyan')
        server = RemoteDebugServer(project_dir=project_dir,
                                    env=env_name,
                                    variables=variables,
                                    debug_options=debug_options,
                                    prog_path=configuration["prog_path"],
                                    origin_command=sys.argv)
    code = server.run()
    if code != 0:
        raise click.exceptions.ClickException(
            f'Debug server return code {code}')


def _handle_interface_gdb(interface_args):
    project_dir = interface_args.get('project_dir')
    env_name = interface_args.get('env_name')
    variables = interface_args.get('variables')
    configuration = interface_args.get('configuration')
    unprocessed = interface_args.get('unprocessed')
    force_local = interface_args.get('force_local')

    client = GDBClient(project_dir=project_dir,
                           env=env_name,
                           variables=variables,
                           gdb_path=configuration['gdb_path'],
                           args=unprocessed)

    if not force_local:
        RemoteDebugServer.download_files(project_path=project_dir,
                files=[os.path.join(client.cache_dir, '.pioinit')])

    code = client.run()
    if code != 0:
        raise click.exceptions.ClickException(
            f'GDBClient return code {code}')


def _handle_interface_hss(interface_args):
    project_dir = interface_args.get('project_dir')
    env_name = interface_args.get('env_name')
    variables = interface_args.get('variables')
    unprocessed = interface_args.get('unprocessed')
    chip_package_path = interface_args.get('chip_package_path')
    hssclient_path = os.path.abspath(os.path.join(chip_package_path, '../', 'IDE', 'hssclient', 'hssclient.exe'))
    hssclient = HSSClient(project_dir=project_dir,
                            env=env_name,
                            variables=variables,
                            hssclient_path=hssclient_path,
                            args=unprocessed)
    hssport_status = True
    while hssport_status:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        hssport_status = sock.connect_ex(('127.0.0.1', 3333))
    code = hssclient.run()
    if code != 0:
        raise click.exceptions.\
            ClickException(f'HSSClient return code {code}')


def _handle_interface_var_gdb(interface_args):
    project_dir = interface_args.get('project_dir')
    env_name = interface_args.get('env_name')
    variables = interface_args.get('variables')
    configuration = interface_args.get('configuration')
    unprocessed = interface_args.get('unprocessed')
    force_local = interface_args.get('force_local')

    vartrace_client = GDBClient(project_dir=project_dir,
                    env=env_name, variables=variables,
                    gdb_path=configuration['gdb_path'], args=unprocessed)
    if not force_local:
        RemoteDebugServer.download_files(project_path=project_dir,
                files=[os.path.join(vartrace_client.cache_dir,
                                        '.pioinit')])
    gdbport_status = True
    while gdbport_status:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        gdbport_status = sock.connect_ex(('127.0.0.1', 3333))
    code = vartrace_client.vartrace_gdb_run()
    if code != 0:
        raise click.exceptions.ClickException(
            f'GDBClient return code {code}')

import os
import time
import queue
import random
import base64
import threading
import subprocess
import platformio.commands.remote.handlers.base_handler
from platformio.helpers import get_executable_path
from platformio.proc import kill_process_tree_by_pid
from platformio.rpc.server import Handler
import logging

remote_logger = logging.getLogger(__name__)


class Execution(platformio.commands.remote.handlers.base_handler.BaseHandler):

    HOS_NAME = ['hos', 'hos.exe']

    def __init__(self, connection, manager, logger):
        super().__init__(connection=connection, manager=manager, logger=logger)
        self.__procedures = {}
        self.__status_watcher = threading.Thread(target=self.__execution_status_watcher)
        self.__status_watcher.daemon = True
        self.__status_watcher.start()

    def on_close_connection(self):
        for k, v in self.__procedures.items():
            if v['exit_code'] is None:
                self.logger.debug(f'terminate execution {k} ...')
                kill_process_tree_by_pid(v['process'].pid)
                v['process'].stdout.close()
                v['process'].stderr.close()
                v['process'].wait(1)
                v['stdout']['thread'].join(timeout=1)
                if v['stdout']['thread'].is_alive():
                    raise RuntimeError('stdout reader thread is alive')
                v['stderr']['thread'].join(timeout=1)
                if v['stderr']['thread'].is_alive():
                    raise RuntimeError('stderr reader thread is alive')
                self.logger.debug(f'execution {k} is terminated')

    @Handler.method()
    def start(self, params):
        execution_id = ''.join(f'{random.randint(0, 255):02x}' for _ in range(16))
        # prepare environment
        environ = os.environ.copy()
        environ['PATH'] = f'{os.path.dirname(get_executable_path())}{os.pathsep}{environ.get("PATH", "")}'
        environ['DEVECO_ISATTY'] = '1'
        # patch command line
        cmd = []
        for origin in params['cmd']:
            resolved = origin
            try:
                resolved = self.session.remote_to_local_path_command(origin)

            except ValueError:
                pass

            cmd.append(resolved if resolved else origin)
        if os.path.basename(cmd[0]) in self.HOS_NAME:
            cmd[0] = get_executable_path()
        # execute
        self.logger.info(f'starting execution {execution_id}: {params}')
        self.logger.debug(f'resolved execution cmd  {execution_id}: {cmd} in {self.session.local_path()}')
        process = subprocess.Popen(cmd, env=environ, cwd=self.session.local_path(),
                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        stdout_data = queue.Queue()
        stdout_thread = threading.Thread(target=self.__stream_reader, args=(process.stdout, stdout_data, execution_id))
        stderr_data = queue.Queue()
        stderr_thread = threading.Thread(target=self.__stream_reader, args=(process.stderr, stderr_data, execution_id))
        self.__procedures[execution_id] = {
            'process': process,
            'stdout': {'data': stdout_data, 'thread': stdout_thread},
            'stderr': {'data': stderr_data, 'thread': stderr_thread},
            'exit_code': None
        }

        stdout_thread.start()
        stderr_thread.start()
        return {'execution_id': execution_id}

    @Handler.method()
    def communicate(self, params):
        proc = self.__procedures.get(params['execution_id'])
        self.logger.debug(f'communicate to execution {params["execution_id"]}')
        if proc is None:
            raise Exception(f'no execution with id {params["execution_id"]} found')
        response = {'exit_code': proc['exit_code']}
        # collect stdout
        b = bytearray()
        while not proc['stdout']['data'].empty():
            b.extend(proc['stdout']['data'].get_nowait())
        response['stdout'] = base64.b64encode(b).decode()
        # collect stderr
        b = bytearray()
        while not proc['stderr']['data'].empty():
            b.extend(proc['stderr']['data'].get_nowait())
        response['stderr'] = base64.b64encode(b).decode()
        # pass stdin
        stdin_data = base64.b64decode(params.get('stdin', '').encode())
        if stdin_data:
            proc['process'].stdin.write(stdin_data)
            proc['process'].stdin.flush()

        return response

    def __execution_status_watcher(self):
        while True:
            self.__handle_watch_status()
            time.sleep(0.1)

    def __handle_watch_status(self):
        for k, v in self.__procedures.items():
            if v['exit_code'] is None:
                v['exit_code'] = v['process'].poll()
                if v['exit_code'] is not None:
                    self.logger.info(f'status watcher: execution {k} is finished with code {v["exit_code"]}')

    def __stream_reader(self, s, q, execution_id):
        self.logger.debug(f'stream reader {execution_id}::{q} started')
        try:
            while execution_id in self.__procedures:
                b = s.read(1)
                if not b:
                    break
                q.put(b)
        except Exception as e:  # pylint: disable=W0703
            remote_logger.error('stream reader error')
        finally:
            self.logger.debug(f'stream reader {execution_id}::{q} finished')

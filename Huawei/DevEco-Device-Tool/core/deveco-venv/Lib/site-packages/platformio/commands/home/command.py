# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import json
import os
import socket
import asyncio
import tarfile
import random
import click
import sanic
import shutil
import platformio.compat
import platformio.managers.core
import platformio.exception
import platformio.rpc.server
import platformio.logger
import platformio.commands.home.rpc.handlers.app
import platformio.commands.home.rpc.handlers.ide
import platformio.commands.home.rpc.handlers.os
import platformio.commands.home.rpc.handlers.piocore
import platformio.commands.home.rpc.handlers.project

from platformio.helpers import get_config_json_path, get_suite_json_path
from platformio.helpers import get_logger_config

REQUEST_MAX_SIZE = 300 * 1024 * 1024        # Maximum request size
MAX_FILE_NAME_LENGTH = 128                  # Maximum filename length
MAX_FILE_CNT = 20                           # Maximum tarfile count
MAX_BUNDLE_JSON_SIZE = 10 * 1024 * 1024     # Maximum size of bundle.json


@click.command("home", short_help="DevEco Home")
@click.option("--port", type=int, default=8008, help="HTTP port, default=8008")
@click.option("--host", default="127.0.0.1", help=("HTTP host, default=127.0.0.1. You can open DevEco Home for inbound "
                                                   "connections with --host=0.0.0.0"))
@click.option("--no-open", is_flag=True)
@click.option("--shutdown-timeout", default=0, type=int, help=("Automatically shutdown server on timeout (in seconds) "
                                                               "when no clients are connected. Default is 0 which "
                                                               "means never auto shutdown"))
@click.option("--verbose", is_flag=True)
def cli(port, host, no_open, shutdown_timeout, verbose):
    already_started = is_port_used(host, port)
    if already_started:
        click.secho("DevEco Home server is already started in another process.", fg="yellow")
        return
    home_url = f"http://{host}:{port}"
    shutdown_timeout = shutdown_timeout if shutdown_timeout else None

    logger = platformio.logger.Logger(**get_logger_config(), level='debug' if verbose else 'info')
    server = sanic.Sanic('DevEco_remote_operation_server', configure_logging=False)
    server.config.REQUEST_MAX_SIZE = REQUEST_MAX_SIZE
    # Web page
    contrib_dir = platformio.managers.core.get_core_package_dir("deveco-home")
    if not os.path.isdir(contrib_dir):
        raise platformio.exception.PlatformioException("Invalid path to DevEco Home Contrib")

    async def home_page_handler(r, path):
        if r.args.get('__shutdown__', False):
            rpc.close()
            asyncio.get_event_loop().stop()
            server.stop()
        if not path:
            path = 'index.html'
        response = await sanic.response.file(os.path.join(contrib_dir, 'dist', path))
        response.cookies['deveco-key'] = ''.join(f'{random.randint(0, 255):02x}' for _ in range(8))
        return response

    # middleware: Prevents XSS attack
    @server.middleware('response')
    async def prevent_xss(request, response):
        response.headers["x-xss-protection"] = "1; mode=block"

    server.add_route(uri='/<path:path>', handler=home_page_handler)
    server.add_route(uri='/fileUpload', handler=callback_file_upload, methods=['post'])

    # RPC server
    handlers = platformio.rpc.server.HandlerManager(logger=logger)
    add_handler_class(handlers)
    rpc = platformio.rpc.server.RpcProtocol(
        handler_manager=handlers, auto_stop_delay=shutdown_timeout, logger=logger)
    click.echo("token:%s" % rpc.token)
    server.add_websocket_route(uri='/wsrpc', handler=rpc.on_connected)

    async def notify_server_started():
        banner_show(home_url, host)
        rpc.charge_auto_stop()

    # starting
    server.add_task(notify_server_started())
    loop = asyncio.get_event_loop()
    asy_task = asyncio.ensure_future(server.create_server(host=host, port=port, return_asyncio_server=True), loop=loop)
    asy_server = loop.run_until_complete(asy_task)
    loop.run_until_complete(asy_server.startup())
    loop.run_until_complete(asy_server.before_start())
    loop.run_until_complete(asy_server.after_start())
    if not no_open:
        click.launch(home_url)
    try:
        loop.run_forever()
    finally:
        rpc.close()
        loop.stop()


def add_handler_class(handlers):
    handlers.add_handler_class('app', platformio.commands.home.rpc.handlers.app.AppRPC)
    handlers.add_handler_class('ide', platformio.commands.home.rpc.handlers.ide.IDERPC)
    handlers.add_handler_class('os', platformio.commands.home.rpc.handlers.os.OSRPC)
    handlers.add_handler_class('core', platformio.commands.home.rpc.handlers.piocore.CoreRPC)
    handlers.add_handler_class('project', platformio.commands.home.rpc.handlers.project.ProjectRPC)


def banner_show(home_url, host):
    # banner
    click.echo("\n".join(["",
                            "  ___I_",
                            " /\\-_--\\   DevEco Home",
                            "/  \\_-__\\",
                            "|[]| [] |  %s" % home_url,
                            "|__|____|______________%s" % ("_" * len(host)),
                            ]))
    click.echo("")
    click.echo("Open DevEco Home in your browser by this URL => %s" % home_url)
    click.echo("DevEco Home has been started. Press Ctrl+C to shutdown.")


def is_port_used(host, port):
    socket.setdefaulttimeout(1)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    if platformio.compat.WINDOWS:
        try:
            s.bind((host, port))
            s.close()
            return False
        except socket.error:
            pass
    else:
        try:
            s.connect((host, port))
            s.close()
        except socket.error:
            return False

    return True


def write_data_to_file(file, file_path):
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    #                                        0o600: Only the owner can read and write.
    with os.fdopen(os.open(file_path, flags, 0o600), 'wb') as file_handle:
        file_handle.write(file.body)


async def callback_file_upload(request):
    if not request.form.get('type'):
        return sanic.json(body={'success': False, 'msg': "typeNotDefined"})

    cache_dir = os.path.join(get_config_json_path(), '.cache')
    if not os.path.exists(cache_dir):
        os.mkdir(cache_dir)

    f = request.files.get("file")

    if len(f.name) > MAX_FILE_NAME_LENGTH:
        return sanic.json(body={'success': False, 'msg': "fileNameTooLong"})

    if request.form.get('type') == 'profile':
        profiles_dir = os.path.join(cache_dir, 'profile')
        if not os.path.exists(profiles_dir):
            os.mkdir(profiles_dir)

        file_name = os.path.join(profiles_dir, f.name)
        if file_name.split('.')[-1].lower() != 'tgz':
            return sanic.json(body={'success': False, 'msg': "fileTypeNotSupported"})

        write_data_to_file(f, file_name)

        return un_tgz(file_name)

    elif request.form.get('type') in ['dataSheet', 'readme']:
        if request.form.get('type') == 'readme' and f.name != 'README.md':
            return sanic.json(body={'success': False, 'msg': "nonStandardNaming"})
        profiles_dir = os.path.join(cache_dir, 'profile')
        if not os.path.exists(profiles_dir):
            os.mkdir(profiles_dir)

        file_name = os.path.join(profiles_dir, f.name)
        write_data_to_file(f, file_name)
        return sanic.json(body={'success': True}, dumps=json.dumps, default=str)

    elif request.form.get('type') == 'suiteBurn':
        if is_suite_json_data(f.body):
            project_dir = request.form.get('project_dir')
            product = request.form.get('product')
            file_name = get_suite_json_path(project_dir, product)
            if os.path.exists(file_name):
                shutil.copy(file_name, file_name + '.backup')
            write_data_to_file(f, file_name)
            return sanic.json(body={'success': True}, dumps=json.dumps, default=str)
        return sanic.json(body={'success': False, 'msg': "notSuiteJsonData"})

    return sanic.json(body={'success': False, 'msg': "typeNotDefined"})


def is_suite_json_data(data):
    res = True
    try:
        json_data = json.loads(data)
        suite_key = ['tool_name', 'commands', 'ui_config', 'partitions_config']
        if not (isinstance(json_data, dict) and all(i in json_data for i in suite_key)):
            res = False
    except json.decoder.JSONDecodeError:
        res = False

    return res


def un_tgz(file_name):
    try:
        tar = tarfile.open(file_name)
    except tarfile.ReadError:
        os.remove(file_name)
        return sanic.json(body={'success': False, 'msg': "fileFailedToParse"})

    try:
        info = tar.getmember("bundle.json")
    except KeyError:
        tar.close()
        os.remove(file_name)
        return sanic.json(body={'success': False, 'msg': "noBundleJson"})

    if info.size > MAX_BUNDLE_JSON_SIZE:
        tar.close()
        os.remove(file_name)
        return sanic.json(body={'success': False, 'msg': "bundleJsonTooLarge"})

    f_reader = tar.extractfile("bundle.json")
    try:
        data = json.loads(f_reader.read())
    except json.decoder.JSONDecodeError:
        return sanic.json(body={'success': False, 'msg': "fileFailedToParse"})

    return sanic.json(body={'success': True, "data": data},
                      dumps=json.dumps, default=str)

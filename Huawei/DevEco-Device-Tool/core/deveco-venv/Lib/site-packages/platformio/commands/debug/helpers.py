# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import os
import re
import sys
from fnmatch import fnmatch
from hashlib import sha1
from io import BytesIO
from os.path import isfile, isdir, join

from platformio import exception, fs, util
from platformio.commands import PlatformioCLI
from platformio.commands.debug.exception import DebugInvalidOptionsError
from platformio.commands.platform import platform_install as cmd_platform_install
from platformio.commands.run.command import cli as cmd_run
from platformio.compat import is_bytes
from platformio.managers.platform import PlatformFactory
from platformio.managers.package import PackageManager
from platformio.project.config import ProjectConfig
from platformio.project.options import ProjectOptions
from platformio.commands.dotting.helpers import TraceData


class GDBMIConsoleStream(BytesIO):  # pylint: disable=too-few-public-methods

    STDOUT = sys.stdout

    def write(self, text):
        self.STDOUT.write(escape_gdbmi_stream("~", text))
        self.STDOUT.flush()


def is_gdbmi_mode():
    return "--interpreter" in " ".join(PlatformioCLI.leftover_args)


def escape_gdbmi_stream(prefix, stream):
    bytes_stream = False
    if is_bytes(stream):
        bytes_stream = True
        stream = stream.decode()

    if not stream:
        return b"" if bytes_stream else ""

    ends_nl = stream.endswith("\n")
    stream = re.sub(r"\\+", "\\\\\\\\", stream)
    stream = stream.replace('"', '\\"')
    stream = stream.replace("\n", "\\n")
    stream = '%s"%s"' % (prefix, stream)
    if ends_nl:
        stream += "\n"

    return stream.encode() if bytes_stream else stream


def get_default_debug_env(config):
    default_envs = config.default_envs()
    all_envs = config.envs()
    for env in default_envs:
        if config.get("env:" + env, "build_type") == "debug":
            return env
    for env in all_envs:
        if config.get("env:" + env, "build_type") == "debug":
            return env
    return default_envs[0] if default_envs else all_envs[0]


def build_project(ctx, project_dir, env_name, verbose):
    ctx.invoke(cmd_run, project_dir=project_dir, environment=[env_name], target=["buildprog"], verbose=verbose)


def upload_project(ctx, project_dir, env_name, verbose):
    ctx.invoke(cmd_run, project_dir=project_dir, environment=[env_name], target=["upload"], verbose=verbose)


def get_executable_dir(platform, platform_packages, executable, project_dir):
    env_paths = []
    pm = PackageManager(platform.config.get_optional_dir("packages"), [], [project_dir])
    for package in platform_packages:
        if "@" in package:
            package_dir = pm.get_package_dir(package.split("@")[0])
        if package_dir and isdir(package_dir):
            env_paths.append(package_dir)
    for tool_path in env_paths:
        exec_path = join(tool_path, executable)
        if isfile(exec_path):
            return tool_path
        exec_path = join(tool_path, "bin", executable)
        if isfile(exec_path):
            return join(tool_path, "bin")
    return None


# pylint: disable=too-many-locals
def validate_debug_options(cmd_ctx, env_options, server_arguments, project_dir):
    def _cleanup_cmds(items):
        items = ProjectConfig.parse_multi_values(items)
        return ["$LOAD_CMDS" if item == "$LOAD_CMD" else item for item in items]
    try:
        platform = PlatformFactory.newPlatform(env_options["platform"])
    except exception.UnknownPlatform:
        cmd_ctx.invoke(cmd_platform_install, platforms=[env_options["platform"]], skip_default_package=True)
        platform = PlatformFactory.newPlatform(env_options["platform"])

    board_config = platform.board_config(env_options["board"])
    tool_name = board_config.get_debug_tool_name(env_options.get("debug_tool"))
    tool_settings = board_config.get("debug", {}).get("tools", {}).get(tool_name, {})
    server_options = None

    # specific server per a system
    if isinstance(tool_settings.get("server", {}), list):
        for item in tool_settings["server"][:]:
            tool_settings["server"] = item
            if util.get_systype() in item.get("system", []):
                break

    # user overwrites debug server
    if env_options.get("debug_server"):
        server_options = {"cwd": None, "executable": None, "arguments": env_options.get("debug_server")}
        server_options["executable"] = server_options["arguments"][0]
        server_options["arguments"] = server_options["arguments"][1:]
    elif "server" in tool_settings:
        server_options = handle_server_options(
            tool_settings, platform, env_options, project_dir, server_arguments)

    debug_client = env_options.get("debug_client")
    if not debug_client:
        debug_client = board_config.get("debug", {}).get("client")

    TraceData.trace_data('10000', 'Debug',
        {
            'client': debug_client,
            'vendor': env_options["platform"],
            "board": env_options["board"],
            "level": board_config.get("build", {}).get("device_level", -1)
        })

    extra_cmds = _cleanup_cmds(env_options.get("debug_extra_cmds"))
    extra_cmds.extend(_cleanup_cmds(tool_settings.get("extra_cmds")))

    option_args = dict(
        tool_name=tool_name, env_options=env_options, board_config=board_config,
        tool_settings=tool_settings, debug_client=debug_client, extra_cmds=extra_cmds,
        server_options=server_options, cleanup_cmds=_cleanup_cmds)

    return get_debug_options(option_args)


def configure_esp32_load_cmds(debug_options, configuration):
    ignore_conds = [
        debug_options["load_cmds"] != ["load"],
        "xtensa-esp32" not in configuration.get("cc_path", ""),
        not configuration.get("flash_extra_images"),
        not all(
            [isfile(item["path"]) for item in configuration.get("flash_extra_images")]
        ),
    ]
    if any(ignore_conds):
        return debug_options["load_cmds"]

    mon_cmds = [
        'monitor program_esp32 "{{{path}}}" {offset} verify'.format(
            path=fs.to_unix_path(item["path"]), offset=item["offset"]
        )
        for item in configuration.get("flash_extra_images")
    ]
    mon_cmds.append(
        'monitor program_esp32 "{%s.bin}" 0x10000 verify'
        % fs.to_unix_path(configuration["prog_path"][:-4])
    )
    return mon_cmds


def has_debug_symbols(prog_path):
    if not isfile(prog_path):
        return False
    matched = {
        b".debug_info": False,
        b".debug_abbrev": False,
        b" -Og": False,
        b" -g": False,
        b"__PLATFORMIO_BUILD_DEBUG__": False,
    }
    with open(prog_path, "rb") as fp:
        handle_read_data(fp, matched)

    return all(matched.values())


def handle_read_data(fp, matched):
    last_data = b""
    while True:
        data = fp.read(1024)
        if not data:
            break
        for pattern, found in matched.items():
            if found:
                continue
            if pattern in last_data + data:
                matched[pattern] = True
        last_data = data


def is_prog_obsolete(prog_path):
    prog_hash_path = prog_path + ".sha1"
    if not isfile(prog_path):
        return True
    shasum = sha1()
    with open(prog_path, "rb") as fp:
        while True:
            data = fp.read(1024)
            if not data:
                break
            shasum.update(data)
    new_digest = shasum.hexdigest()
    old_digest = None
    if isfile(prog_hash_path):
        with open(prog_hash_path) as fp:
            old_digest = fp.read()
    if new_digest == old_digest:
        return False
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    with os.fdopen(os.open(prog_hash_path, flags, 0o640), 'w') as fp:
        fp.write(new_digest)
    return True


def reveal_debug_port(env_debug_port, tool_name, tool_settings):
    def _get_pattern():
        if not env_debug_port:
            return None
        if set(["*", "?", "[", "]"]) & set(env_debug_port):
            return env_debug_port
        return None

    def _is_match_pattern(port):
        pattern = _get_pattern()
        if not pattern:
            return True
        return fnmatch(port, pattern)

    def _look_for_serial_port(hwids):
        for item in util.get_serialports(filter_hwid=True):
            if not _is_match_pattern(item["port"]):
                continue
            port = item["port"]
            if tool_name.startswith("blackmagic"):
                if (
                    "windows" in util.get_systype()
                    and port.startswith("COM")
                    and len(port) > 4
                ):
                    port = "\\\\.\\%s" % port
                if "GDB" in item["description"]:
                    return port
            for hwid in hwids:
                hwid_str = ("%s:%s" % (hwid[0], hwid[1])).replace("0x", "")
                if hwid_str in item["hwid"]:
                    return port
        return None

    if env_debug_port and not _get_pattern():
        return env_debug_port
    if not tool_settings.get("require_debug_port"):
        return None

    debug_port = _look_for_serial_port(tool_settings.get("hwids", []))
    if not debug_port:
        raise DebugInvalidOptionsError("Please specify `debug_port` for environment")
    return debug_port


def get_debug_options(option_args):
    tool_name = option_args.get('tool_name')
    env_options = option_args.get('env_options')
    board_config = option_args.get('board_config')
    tool_settings = option_args.get('tool_settings')
    debug_client = option_args.get('debug_client')
    extra_cmds = option_args.get('extra_cmds')
    server_options = option_args.get('server_options')
    cleanup_cmds = option_args.get('cleanup_cmds')

    result = dict(
        tool=tool_name,
        upload_protocol=env_options.get("upload_protocol", board_config.get("upload", {}).get("protocol")),

        load_cmds=cleanup_cmds(env_options.get("debug_load_cmds", tool_settings.get("load_cmds",
            tool_settings.get("load_cmd", ProjectOptions["env.debug_load_cmds"].default)))),

        load_mode=env_options.get("debug_load_mode", tool_settings.get(
            "load_mode", ProjectOptions["env.debug_load_mode"].default)),

        init_break=env_options.get("debug_init_break", tool_settings.get("init_break",
            tool_settings.get("client_tools", {}).get(debug_client,
                {}).get("init_break", ProjectOptions["env.debug_init_break"].default))),

        init_launch_cmds=cleanup_cmds(env_options.get("debug_init_cmds", tool_settings.get("init_launch_cmds",
            tool_settings.get("client_tools", {}).get( debug_client, {}).get("init_launch_cmds")))),

        init_attach_cmds=cleanup_cmds(env_options.get("debug_init_cmds", tool_settings.get("init_attach_cmds",
            tool_settings.get("client_tools", {}).get(debug_client, {}).get("init_attach_cmds")))),

        exit_cmds=cleanup_cmds(env_options.get("debug_exit_cmds", tool_settings.get("exit_cmds",
            tool_settings.get("client_tools", {}).get(debug_client, {}).get("exit_cmds")))),

        extend_server_args=cleanup_cmds(env_options.get("debug_extend_server_args", tool_settings.get(
            "extend_server_args", tool_settings.get("client_tools", {}).get(debug_client,
                {}).get("extend_server_args")))),

        extra_cmds=extra_cmds,
        require_debug_port=tool_settings.get("require_debug_port", False),
        port=reveal_debug_port(env_options.get("debug_port", tool_settings.get("port",
            tool_settings.get("client_tools", {}).get(debug_client, {}).get("port"))),
            tool_name, tool_settings),

        server=server_options,
        interface=env_options.get("debug_interface", "jtag"),
        speed=str(env_options.get("debug_speed", "auto")),
        device=env_options.get("debug_device", "Cortex-M3").split('|').pop(),
        script=env_options.get("debug_script", '')
    )
    return result


def handle_server_options(tool_settings, platform, env_options, project_dir, server_arguments):
    server_options = tool_settings["server"]
    server_package = server_options.get("package")
    if server_package:
        server_package_dir = (
            platform.get_package_dir(server_package) if server_package else None
        )
        if server_package and not server_package_dir:
            chip_package_path = env_options["chip_package_path"]
            if chip_package_path:
                server_package_dir = os.path.abspath(os.path.join(chip_package_path, '../', 'IDE', 'hw_openocd'))
            else:
                platform.install_packages(
                    with_packages=[server_package], skip_default_package=True, silent=True
                )
                server_package_dir = platform.get_package_dir(server_package)
    else:
        server_package_dir = get_executable_dir(
            platform,
            env_options.get("platform_packages", []),
            server_options["executable"],
            project_dir
        )

    arguments = server_options.get("arguments", [])
    if isinstance(arguments, dict):
        if server_arguments not in arguments:
            raise DebugInvalidOptionsError(f'"{server_arguments}" is not defined for server arguments. '
                                            f'Available values are {list(arguments.keys())}')
        arguments = arguments[server_arguments]

    server_options.update(
        dict(
            cwd=server_package_dir,
            executable=server_options.get("executable"),
            arguments=[
                a.replace("$PACKAGE_DIR", server_package_dir)
                if server_package_dir
                else a
                for a in arguments
            ],
        )
    )
    return server_options
# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
import subprocess
import threading
import time
import platformio.commands.debug.process.base
import platformio.commands.debug.exception


class GDBClient(platformio.commands.debug.process.base.BaseProcess):
    # pylint: disable=too-many-arguments
    def __init__(self, project_dir, env, variables, gdb_path, args):
        super().__init__(project_dir=project_dir, env=env, variables=variables)
        self.gdb_path = gdb_path
        self.args = self.apply_variables(list(args))
        self.prog_path = variables['PROG_PATH']
        self.exit_cmds = variables['EXIT_CMDS'] + \
            '\n' if variables['EXIT_CMDS'] else 'monitor shutdown\n'

    def run(self):
        args = ['piogdb', '-q',
                '--directory', self.cache_dir,
                '--directory', self.project_dir,
                '-l', '10'] + self.args

        gdb_data_dir = self._get_data_dir(self.gdb_path)
        if gdb_data_dir:
            args.extend(['--data-directory', gdb_data_dir])

        args.append(self.prog_path)

        gdb_process = subprocess.Popen(executable=self.gdb_path,
                                       args=args,
                                       env=os.environ,
                                       cwd=self.project_dir,
                                       stdout=None,
                                       stderr=None,
                                       stdin=subprocess.PIPE)

        stdin_capture_thread = threading.Thread(
            target=self.__stdin_parser, args=[gdb_process])
        stdin_capture_thread.start()
        stdin_capture_thread.join()
        if gdb_process.poll() is None:  # process is still alive, kill it
            gdb_process.terminate()
        return gdb_process.returncode if gdb_process.returncode else 0

    def vartrace_gdb_run(self):
        vartrace_gdb_args = ['piogdb', '-q',
                '--directory', self.cache_dir,
                '--directory', self.project_dir,
                '-l', '10'] + self.args
        vartrace_gdb_data_dir = self._get_data_dir(self.gdb_path)
        if vartrace_gdb_data_dir:
            vartrace_gdb_args.extend(['--data-directory',
                                             vartrace_gdb_data_dir])
        vartrace_gdb_args.append(self.prog_path)
        vartrace_gdb_process = subprocess.Popen(executable=self.gdb_path,
                                       args=vartrace_gdb_args,
                                       env=os.environ,
                                       cwd=self.project_dir,
                                       stdout=None,
                                       stderr=None,
                                       stdin=subprocess.PIPE)
        localhost_command = 'target remote localhost:3333\n'
        load_command = 'load\n'
        continue_command = 'c\n'
        vartrace_gdb_process.stdin.write(localhost_command.encode())
        vartrace_gdb_process.stdin.flush()
        vartrace_gdb_process.stdin.write(load_command.encode())
        vartrace_gdb_process.stdin.flush()
        vartrace_gdb_process.stdin.write(continue_command.encode())
        vartrace_gdb_process.stdin.flush()
        stdin_capture_thread = threading.Thread(
            target=self.__stdin_parser, args=[vartrace_gdb_process])
        stdin_capture_thread.start()
        stdin_capture_thread.join()
        if vartrace_gdb_process.poll() is None:
            vartrace_gdb_process.terminate()
        return vartrace_gdb_process.returncode if \
            vartrace_gdb_process.returncode else 0

    def __stdin_parser(self, process):
        target_is_run = False
        while process.poll() is None:
            data = sys.stdin.readline()
            if '-exec-continue' in data:
                target_is_run = True

            if '-exec-run' in data:
                if target_is_run:
                    self.echo(f'{data.split("-", 1)[0]}^running\n')
                    continue
                data = data.replace('-exec-run', '-exec-continue')

            if '-gdb-exit' in data or data.strip() in ('q', 'quit'):
                process.stdin.write(self.exit_cmds.encode())
                process.stdin.flush()
                process.stdin.write(data.encode())
                process.stdin.flush()
                # need to wait a bit to transfer command. 100ms should be enough
                time.sleep(0.1)
                break

            process.stdin.write(data.encode())
            process.stdin.flush()

    @staticmethod
    def _get_data_dir(gdb_path):
        if 'msp430' in gdb_path:
            return None
        gdb_data_dir = os.path.realpath(os.path.join(
            os.path.dirname(gdb_path), '..', 'share', 'gdb'))
        return gdb_data_dir if os.path.isdir(gdb_data_dir) else None

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Copyright (c) Huawei Technologies Co., Ltd. 2021-2022 All rights reserved.

    CLI for OpenHarmony image download

    Date: 2022/4/24

"""

import os
import platform
import ctypes
import shutil
import time
import re
import subprocess
import click
import requests

from platformio.unpacker import FileUnpacker
from platformio.project.config import ProjectConfig
from platformio.compat import dump_json_to_unicode
from platformio.commands.sourcedownload.helpers import SourceDownloadConfig as DownloadConfig
from platformio.commands.sourcedownload.helpers import deveco_progressbar, download_trace
from platformio.commands.sourcedownload.helpers import OversizeError
from platformio.exception import ToolNotFound

MAX_IMAGE_SIZE = 100 * 1024 ** 3


@click.group(short_help="Download resources from the Internet")
def cli():
    pass


@cli.command("oh_image_download", short_help="OpenHarmony image source download.")
@click.option("--download_url", required=True, help='OpenHarmony source download url.')
@click.option("--oh_size", required=True, help='Download OpenHarmony Version size.')
@click.option("--download_location", required=True, help='Selected download directory.')
@download_trace
def download_oh_image_source(download_url: str, oh_size: str, download_location: str):
    """
    [1]. Check whether the disk space meets the requirements.\n
    [2]. Check whether download_location dir is exists.\n
    [3]. If the cache exists. Directly unzip xxx.gar.gz to the download_location.\n
    [4]. If the cache not exists. download selected openHarmony image and sha256 file to check.\n
    [5]. Unzip xxx.tar.gz to current download_location and delete xxx.tar.gz.\n
    [6]. If the dir '~/' space is sufficient, mkdir cache dir and copy the xxx.tar.gz to here for future use.\n

    :download_url: URL of the version to be downloaded.
    :oh_size: download image size
    :download_location: download and unzip directory.
    """
    version_name = get_oh_version_name(download_url)
    temp_file = os.path.join(download_location, version_name)  # Interrupt Downloaded Files
    cache_file_location: str = DownloadConfig.SOURCE_CACHE_STORE_DIRECTORY + os.sep + version_name
    oh_size_rel: float = float(re.findall(r'\d+\.?\d*', oh_size)[0])
    if not check_disk_space(oh_size_rel, download_location):
        return False, DownloadConfig.SPACE_INSUFFICIENT_MSG, version_name

    if not os.path.exists(download_location):
        return False, DownloadConfig.DOWNLOAD_DIR_NOT_EXIST_MSG, version_name

    if os.path.exists(temp_file):
        done_size = os.path.getsize(temp_file)
        download_res = download_target(download_url, download_location, oh_size, start_size=done_size)
        return download_done_handle(download_res, version_name, download_url, cache_file_location, download_location)

    temp_code_name = version_name.split(".tar.gz")[0]
    shutil.rmtree(os.path.join(download_location, temp_code_name), ignore_errors=True)

    if os.path.exists(cache_file_location):
        clear_dir_except_dot_deveco(download_location)
        unzip_target_to_download_location(cache_file_location, download_location)
        return True, '', version_name

    if not os.path.exists(DownloadConfig.SOURCE_CACHE_STORE_DIRECTORY):
        os.makedirs(DownloadConfig.SOURCE_CACHE_STORE_DIRECTORY)

    if not check_disk_space(oh_size_rel, DownloadConfig.SOURCE_CACHE_STORE_DIRECTORY):
        return False, DownloadConfig.SPACE_INSUFFICIENT_MSG, version_name

    download_res = download_target(download_url, download_location, oh_size)
    return download_done_handle(download_res, version_name, download_url, cache_file_location, download_location)


def download_done_handle(download_res, version_name, download_url, cache_file_location, download_location):
    if not download_res[1]:
        return False, download_res[2], version_name

    shutil.move(download_res[0], DownloadConfig.SOURCE_CACHE_STORE_DIRECTORY)

    if not download_and_check_sha256(download_url, cache_file_location):
        error_causes = f'{get_oh_version_name(download_url)} is damaged. Please download it again. !'
        return False, error_causes, version_name

    clear_dir_except_dot_deveco(download_location)
    unzip_target_to_download_location(cache_file_location, download_location)
    return True, '', version_name


def clear_dir_except_dot_deveco(target_dir: str):
    """
    Remove dirs and files except .deveco under target_dir

    :target_dir: Target directory for remove
    """
    dir_files = os.listdir(target_dir)
    for path_name in dir_files:
        if path_name == '.deveco':
            continue
        path = os.path.join(target_dir, path_name)
        if os.path.isfile(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path, ignore_errors=True)


def get_oh_version_name(download_url: str) -> str:
    """
    Obtain the full name of the version file from the download link.

    :download_url: URL of the version to be downloaded.
    """
    return os.path.basename(download_url)


def download_and_check_sha256(download_url, cache_file_location):
    """
    Obtain the SHA256 file corresponding to the version to be downloaded and verify the file with the download file.

    :download_url:  URL of the version to be downloaded.
    :cache_file_location: Store path is ~/.deveco-device-tool/openharmony-source
    """
    click.secho("Checking sha256. Please wait...", fg="green")
    check_sha256 = ["curl", "-s", "-k", "%s.sha256" % download_url]
    local_sha256 = ["sha256sum", cache_file_location]
    check_sha256_res = []
    if not shutil.which('curl'):
        raise ToolNotFound('curl')
    for statement in check_sha256, local_sha256:
        if statement == check_sha256:
            output = subprocess.check_output(statement, shell=False)
        else:
            p1 = subprocess.Popen(statement, stdout=subprocess.PIPE)
            p2 = subprocess.Popen([shutil.which("awk"), '{print $1}'], stdin=p1.stdout, stdout=subprocess.PIPE)
            p1.stdout.close()
            output = p2.communicate(timeout=900)[0]
        check_sha256_res.append(output.decode('utf-8').strip('\r\n'))
    click.echo("Verification completed!")
    return len(check_sha256_res) == 2 and check_sha256_res[0] == check_sha256_res[1]


def check_disk_space(oh_size_rel: float, download_location: str) -> bool:
    """
    Returns whether the currently specified directory space is larger than the code to be downloaded.

    :oh_size : image size
    :download_location: downloaded store location
    """
    if platform.system() == 'Windows':
        disk_section = os.path.abspath(download_location)[:3]
        free_bytes = ctypes.c_ulonglong(0)
        ctypes.windll.kernel32.GetDiskFreeSpaceExW(ctypes.c_wchar_p(disk_section), None, None,
                                                   ctypes.pointer(free_bytes))
        return free_bytes.value / (DownloadConfig.KILO_BYTE ** 3) > oh_size_rel
    else:
        if not os.path.exists(download_location):
            os.mkdir(download_location)
        fd_info = os.statvfs(download_location)
        return fd_info.f_bavail * fd_info.f_frsize / (DownloadConfig.KILO_BYTE ** 3) > oh_size_rel


def download_target(download_url: str, download_location: str, oh_size: str, start_size=0):
    version_name: str = get_oh_version_name(download_url)
    store_file_name: str = download_location + os.sep + version_name
    download_result, error_causes, max_attempts, attempt, down_res = False, '', 3, 0, None
    while attempt < max_attempts:
        attempt += 1
        try:
            down_res = requests.get(download_url, stream=True, timeout=(5, 10))
            break
        except OSError:
            error_causes = f'Download {version_name} timeout!'
            click.secho(error_causes, fg='red')
            return store_file_name, download_result, error_causes
        except requests.exceptions.Timeout:
            error_causes = f'"please check the network"'
            click.secho(error_causes, fg='red')
            return store_file_name, download_result, error_causes
    total_size = int(down_res.headers['content-length'])

    if down_res.status_code == 200:
        if start_size != 0:
            click.echo(click.style(f'Continue Downloading: {version_name}, '
                f'Remaining size: {round((total_size - start_size) / 1024 ** 2, 2)}M , '
                f'Please wait patiently', fg='green'))
        else:
            click.echo(click.style(f'Downloading Source: {version_name}, Downloading size: {oh_size} , '
                                   f'Please wait patiently', fg='green'))
    else:
        error_causes = f'Downloading {version_name} failed with code: {down_res.status_code}!'
        click.secho(error_causes, fg='red')
        return store_file_name, download_result, error_causes

    start_time, done_chunk, temp_size = time.time(), 0, 0
    error_causes = "downloading OpenHarmony Source Code failed; you should check your local network and reload vscode "
    try:
        flags = os.O_RDWR | os.O_CREAT | os.O_APPEND
        with os.fdopen(os.open(store_file_name, flags, 0o640), "ab") as f, deveco_progressbar(
                length=total_size - start_size, label="Download Progress: ", show_speed=True,
                bar_template="%(label)s  [%(bar)s]  Download percentage, estimated time and download speed: %(info)s "
        ) as bar:
            header = {"Range": f"bytes={start_size}-{total_size}"}
            params = {
                'down_res': down_res if start_size == 0 else requests.get(download_url, headers=header, stream=True,
                                                                          timeout=(5, 10)),
                'start_time': start_time, 'temp_size': temp_size}
            done_chunk = download_srcfile(bar, f, params, done_chunk)
            download_result = (total_size-start_size) == done_chunk
            click.echo('Download complete!') if download_result else click.echo('Download Interrupted!')
            click.secho(error_causes, fg='red') if not download_result else click.echo('')
    except OSError as e:
        click.secho(error_causes, fg='red')
        return store_file_name, download_result, e
    return store_file_name, download_result, error_causes


def download_srcfile(bar, f, params, done_chunk):
    for chunk in params.get('down_res').iter_content(chunk_size=DownloadConfig.KILO_BYTE):
        if chunk:
            start_time = params.get('start_time')
            temp_size = params.get('temp_size')
            if temp_size > MAX_IMAGE_SIZE:
                raise OversizeError('{:.2}G'.format(MAX_IMAGE_SIZE / 1024**3))
            done_chunk += len(chunk)
            if time.time() - start_time > 1:
                params['start_time'] = time.time()
                bar.speed = done_chunk - temp_size
                params['temp_size'] = done_chunk
            f.write(chunk)
            bar.update(len(chunk))
    return done_chunk


def unzip_target_to_download_location(store_file_name: str, download_location: str):
    click.secho("Unpacking artifacts. Please wait...", fg="green")
    with FileUnpacker(store_file_name) as f:
        f.unpack(dest_dir=download_location,
                 target_dir='/'.join([os.path.basename(store_file_name)[:-7], 'OpenHarmony']))


def move_unpack_file_to_project(project_dir: str, download_url: str):
    """
    Remove unnecessary folder levels after decompression

    projectName>code-v1.1.4-LTS>OpenHarmony>modules-->projectName>modules
    """
    click.secho("Extracting files. Please wait...", fg="green")
    try:
        oh_version_name = get_oh_version_name(download_url).split(".tar.gz")[0]
        handle_unpack_file(download_url, project_dir)
        shutil.rmtree(os.path.join(project_dir, oh_version_name), ignore_errors=True)
    except OSError as e:
        click.secho('oserror', fg="yellow")
    except IndexError as e:
        click.echo('IndexError')


def handle_unpack_file(download_url, project_dir):
    oh_version_name = get_oh_version_name(download_url).split(".tar.gz")[0]
    for root, dirs, files in os.walk(
            os.path.join(project_dir, oh_version_name, DownloadConfig.REDUNDANT_FOLDER_LAYERS)
    ):
        for d in dirs:
            src_module_dir = os.path.join(root, d)
            dest_module_dir = os.path.join(project_dir, d)
            if os.path.exists(dest_module_dir):
                shutil.rmtree(dest_module_dir)
            click.echo(f"moving folder: {src_module_dir} --> {os.path.join(project_dir, d)}")
            shutil.move(src_module_dir, os.path.join(project_dir, d))
        for file in files:
            if os.path.exists(os.path.join(project_dir, file)):
                os.remove(os.path.join(project_dir, file))
            click.echo(f"moving file: {os.path.join(root, file)} --> {project_dir}")
            shutil.move(os.path.join(root, file), project_dir)
        break


@cli.command("web_download", short_help="Web image source download.")
@click.option("-u", "--download_url", required=True, help='Web source download url.')
@click.option("-d", "--download_location", required=True, help='Select download directory.')
def download_web_source(download_url: str, download_location: str):
    """
    :download_url: URL of websource.
    :download_location: download dir.
    """
    file_name = os.path.basename(download_url)
    click.echo("Start download {} ... ".format(file_name))
    try:
        download = requests.get(download_url, stream=True, verify=False, timeout=(10, 600))
    except OSError as e:
        raise Exception(f'Download timeout!') from e
    store_file_name: str = os.path.join(download_location, file_name)
    try:
        save_source_file(store_file_name, download)
    except OSError as e:
        raise Exception(f'{download_url} download failed!') from e
    return True


def save_source_file(store_file_name, download):
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    with os.fdopen(os.open(store_file_name, flags, 0o640), "wb") as f:
        for chunk in download.iter_content(chunk_size=DownloadConfig.KILO_BYTE ** 2):
            if chunk:
                f.write(chunk)
    click.echo('Download complete!')


def get_config_for_options(config: ProjectConfig, section: str) -> dict:
    section_conifg = {}
    options = config.options(section=section)
    for option in options:
        section_conifg.update(
            {re.sub(r"_(\w)", lambda match: match.group(1).upper(), option): config.get(section, option)}
        )
    return section_conifg


@cli.command("config", short_help="Read the configuration from the ini file")
@click.option("-d", "--project-dir", required=True, help="The project path")
@click.option("-t", "--otype", required=True, help='Operation File Type')
@click.option("-s", "--section", help='configuration section')
@click.option("-o", "--option", help='configuration option')
@click.option("-v", "--value", help='configuration value')
def project_config(project_dir: str, otype: str, section: str, option: str, value: str):
    """
    Read File Configuration or Wirte Configuration to file
    Delete residual download artifacts

    :file_path: ini file path
    :otype: Operation Type
    :section: section.
    :option: option.
    :value: value.
    """
    config_path = os.path.join(project_dir, ".deveco", "deveco.ini")
    if not os.path.exists(config_path):
        return click.echo(dump_json_to_unicode({"code": 1, "msg": "NotFoundFile"}))
    config = ProjectConfig(config_path, parse_extra=False)
    if otype == "r":
        envs_conifg = {}
        if section == "all_envs":
            for env in config.sections():
                env_items = get_config_for_options(config, env)
                envs_conifg.update(env_items)
        else:
            env_items = get_config_for_options(config, section)
            envs_conifg.update(env_items)
        envs_conifg.update({"projectDir": project_dir})
        return click.echo(dump_json_to_unicode(envs_conifg))
    else:
        config.set(section, option, value)
        config.save()
        # Delete residual artifact
        download_url = config.get("env", "download_url")
        residual_artifact = os.path.join(project_dir, get_oh_version_name(download_url))
        if os.path.exists(residual_artifact) and os.path.getsize(residual_artifact) == 0:
            os.remove(residual_artifact)
        return click.echo(dump_json_to_unicode({"code": 0, "msg": "ok"}))

# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import io
import re
import sys
import glob
import shutil
import socket
import asyncio
import stat
import subprocess

import requests
import functools
import click
import platformio.fs
import platformio.app
import platformio.util
import platformio.helpers
from platformio.rpc.server import Handler


class OSRPC(Handler):

    # pylint: disable=too-many-arguments
    async def __fetch_content(self, request_id, uri, data=None, headers=None, cache_valid=None):
        cache_key = platformio.app.ContentCache.key_from_args(uri, data) if cache_valid else None
        if cache_key:
            with platformio.app.ContentCache() as cc:
                result = cc.get(cache_key)
                if result is not None:
                    return await self.send_async_response(result, request_id)
        try:
            if not headers:
                headers = {"User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) "
                                         "AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 "
                                         "Safari/603.3.8"}

            platformio.util.internet_on(raise_exception=True)
            method = requests.post if data else requests.get
            response = await asyncio.get_event_loop().run_in_executor(None, lambda: method(url=uri,
                                                                                           data=data,
                                                                                           headers=headers))
            response.raise_for_status()
        except Exception as e:  # pylint: disable=broad-except
            return await self.send_async_error(error=str(e), request_id=request_id)

        if cache_valid:
            with platformio.app.ContentCache() as cc:
                cc.set(cache_key, response.text, cache_valid)
        return await self.send_async_response(response.text, request_id)

    @Handler.method()
    def request_content(self, params, request_id):
        uri = params[0]
        if uri.startswith("http"):
            asyncio.get_event_loop().create_task(
                self.__fetch_content(request_id=request_id, uri=uri,
                                     data=params[1] if len(params) > 1 else None,
                                     headers=params[2] if len(params) > 2 else None,
                                     cache_valid=params[3] if len(params) > 3 else None)
            )
            return platformio.rpc.server.AsyncResponse()
        if os.path.isfile(uri):
            with io.open(uri, encoding="utf-8") as fp:
                return fp.read()
        raise Exception(f'Unknown uri type {uri}')

    @staticmethod
    @Handler.method()
    def open_url(params):
        if len(params) == 0:
            raise ValueError(f"Invalid Params")
        url = platformio.util.get_home_url(params[0])
        return click.launch(url)

    @staticmethod
    @Handler.method()
    def reveal_file(params):
        if not os.path.exists(params[0]):
            raise ValueError(f"Invalid Params: {params[0]}")
        return click.launch(params[0], locate=True)

    @staticmethod
    @Handler.method()
    def open_file(params):
        if not os.path.exists(params[0]):
            raise ValueError(f"Invalid Params: {params[0]}")
        return click.launch(params[0])

    @staticmethod
    @Handler.method()
    def is_file(params):
        path = platformio.util.get_real_path(params[0])
        return os.path.isfile(path)

    @staticmethod
    @Handler.method()
    def is_dir(params):
        path = platformio.util.get_real_path(params[0])
        return os.path.isdir(path)

    @staticmethod
    @Handler.method()
    def access(params):
        path = platformio.util.get_real_path(params[0])
        mode = 0
        modes = {'W_OK': os.W_OK,
           'R_OK': os.R_OK,
           'X_OK': os.X_OK,
           'F_OK': os.F_OK}
        for part in params[1]:
            if part in modes:
                mode |= modes[part]
            else:
                raise Exception(f'wrong mode {part}')
        return os.access(path, mode)

    @staticmethod
    @Handler.method()
    def is_empty_dir(params):
        path = platformio.util.get_real_path(params[0])
        return os.path.isdir(path) and os.listdir(path) == []

    @staticmethod
    @Handler.method()
    def rm_dir_or_file(params):
        path = platformio.util.get_real_path(params[0])
        if os.path.exists(path):
            if os.path.isdir(params[0]):
                shutil.rmtree(path)
            else:
                os.remove(path)

    @staticmethod
    @Handler.method()
    def make_dirs(params):
        path = platformio.util.get_real_path(params[0])
        return os.makedirs(path)

    @staticmethod
    @Handler.method()
    def is_exist_dir(params):
        path = platformio.util.get_real_path(params[0])
        return os.path.exists(path)

    @staticmethod
    @Handler.method()
    def get_file_mtime(params):
        path = platformio.util.get_real_path(params[0])
        return os.path.getmtime(path)

    @staticmethod
    @Handler.method()
    def get_file_content(params):
        path = platformio.util.get_real_path(params[0])
        f = open(path, 'r')
        return f.read()

    @staticmethod
    @Handler.method()
    def get_stack_content(params):
        with open(params[0], 'r+', encoding='utf-8') as f:
            return f.read()

    @staticmethod
    @Handler.method()
    def rename(params):
        src = platformio.util.get_real_path(params[0])
        dst = platformio.util.get_real_path(params[1])
        return os.rename(src, dst)

    @staticmethod
    @Handler.method()
    def copy(params):
        src = platformio.util.get_real_path(params[0])
        dst = platformio.util.get_real_path(params[1])
        return shutil.copytree(src, dst)

    @staticmethod
    @Handler.method()
    def glob(params):
        path_names = params[0] if isinstance(params[0], list) else [params[0]]
        root = params[1]
        result = set()
        for path_name in path_names:
            result |= set(glob.glob(os.path.join(root, path_name) if root else path_name))
        return list(result)

    @staticmethod
    @Handler.method()
    def list_dir(params):
        path = platformio.util.get_real_path(params[0])

        def _cmp(x, y):
            if x[1] and not y[1]:
                return -1
            if not x[1] and y[1]:
                return 1
            if x[0].lower() > y[0].lower():
                return 1
            if x[0].lower() < y[0].lower():
                return -1
            return 0

        def _is_hidden_path(pt):
            """Check whether a file is a hidden file or folder. The value true indicates that the file is hidden."""
            if sys.platform.startswith("win"):
                fa = os.stat(pt).st_file_attributes
                return bool(fa & stat.FILE_ATTRIBUTE_HIDDEN)
            else:
                return pt.startswith('.')

        items = []
        if path.startswith("~"):
            path = platformio.fs.expanduser(path)
        if not os.path.isdir(path):
            return items
        for item in os.listdir(path):
            try:
                item_is_dir = os.path.isdir(os.path.join(path, item))
                if item_is_dir:
                    os.listdir(os.path.join(path, item))
                items.append((os.path.join(path, item), item, item_is_dir,
                              _is_hidden_path(os.path.join(path, item))))
            except OSError:
                pass
        return sorted(items, key=functools.cmp_to_key(_cmp))

    @staticmethod
    @Handler.method()
    def get_logical_devices():
        items = []
        for item in platformio.util.get_logical_devices():
            if item["name"]:
                item["name"] = item["name"]
            items.append(item)
        return items

    @staticmethod
    @Handler.method(method='get_IP')
    def get_ip():
        hostname = socket.gethostname()
        return socket.gethostbyname(hostname)

    @staticmethod
    @Handler.method()
    def is_linux():
        return  "linux" in platformio.util.get_systype()

    @staticmethod
    @Handler.method()
    def is_curl_installed(params):
        need_check = params[0]
        if "linux" not in platformio.util.get_systype() or not need_check:
            return True
        try:
            subprocess.check_call(['dpkg', '-s', 'curl'],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=10)
            return True
        except (subprocess.CalledProcessError):
            return False

    @staticmethod
    @Handler.method()
    def repo_env_check():
        is_repo_valid = True
        output = b''
        msg = ''
        try:
            output = subprocess.check_output(['repo'], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            output = e.output
        except OSError:
            # repo not found
            is_repo_valid = False

        not_valid_case = b'warning: Python 3 support is currently experimental'
        if is_repo_valid and not_valid_case in output:
            # in this case we can make sure that repo is not ok
            msg = 'invalidVersion'
            is_repo_valid = False

        sys_path = os.environ.get('PATH', '').split(os.pathsep)
        bin_path = os.path.dirname(sys.executable)
        sys_path = [path for path in sys_path if path != bin_path]
        os.environ['PATH'] = os.pathsep.join(sys_path)

        python_env = False
        try:
            python = shutil.which('python')
            if python:
                python_link = os.readlink(python)
                python_ver = subprocess.Popen([python_link, '--version'], stdout=subprocess.PIPE,
                                              stderr=subprocess.STDOUT)
                if not python_ver.errors:
                    python_env = python_ver.stdout.read().decode().startswith("Python 3")
        except FileNotFoundError:
            pass

        return {
            'git': bool(shutil.which('git')),
            'gitLfs': bool(shutil.which('git-lfs')),
            'repo': is_repo_valid,
            'python': python_env,
            'msg': msg
        }

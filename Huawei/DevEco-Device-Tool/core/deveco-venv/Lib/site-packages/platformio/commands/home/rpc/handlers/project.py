# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import json
import time
import shutil
import psutil
import tarfile
import hashlib
from typing import Dict, List
import platformio.fs
import platformio.util
import platformio.exception
from urllib.parse import unquote
from platformio.project.config import ProjectConfig
from platformio.project.exception import ProjectError
from platformio.project.helpers import is_platformio_project
from platformio.project.options import get_config_options_schema, ProjectOptions
from platformio.managers.platform import PlatformManager, PlatformFactory
from platformio.ide.projectgenerator import ProjectGenerator
from platformio.rpc.server import Handler
from platformio.commands.home.rpc.handlers.app import AppRPC
from platformio.helpers import get_installed_core_path, get_config_json_path
from platformio.util import read_url_json

openharmony_master_url = read_url_json()
gitee_openharmony_master_https_url = openharmony_master_url.get('gitee_openharmony_master_https_url', '')
gitee_openharmony_master_ssh_url = openharmony_master_url.get('gitee_openharmony_master_ssh_url', '')

OHOS_GITEE_HTTPS = f'repo init -u {gitee_openharmony_master_https_url} -b master --no-repo-verify'
OHOS_GITEE_SSH = f'repo init -u {gitee_openharmony_master_ssh_url} -b master --no-repo-verify'


# pylint: disable=too-many-public-methods
class ProjectRPC(Handler):

    def __core_call(self, params, request_id, on_end):
        core_handler = self.manager.get_handler(self.connection, namespace='core')
        return core_handler.call(params, request_id, on_end)

    @staticmethod
    @Handler.method()
    def config_load(params):
        return ProjectConfig(params[0], parse_extra=False, expand_interpolations=False).as_tuple()

    @staticmethod
    @Handler.method()
    def config_dump(params):
        config = ProjectConfig(platformio.util.get_real_path(params[0]),
                               parse_extra=False, expand_interpolations=False)
        config.update(params[1], clear=True)
        return config.save()

    @staticmethod
    def _config_update_from_json(config, path, board):
        try:
            platform = config.items(env=board, as_dict=True).get("platform")
            json_config_path = PlatformFactory.newPlatform(platform).get_settings_dir(board)
            json_config_realpath = os.path.realpath(json_config_path)
            if json_config_realpath:
                ProjectRPC.handle_update_config_json(json_config_realpath, board, path, config)
                return True
        except Exception:  # pylint: disable=broad-except
            print("load options failed")
        return False

    @staticmethod
    def handle_update_config_json(json_config_realpath, board, path, config):
        project_dir = os.path.normpath(os.path.join(os.path.dirname(path), ".."))
        env_name = f"env:{board}"
        with open(json_config_realpath, 'r') as json_file:
            data = json.loads(json_file.read())
            options = data.get("options", [])
        for option in options:
            option_name = option.get("name", None)
            default_value = option.get("default", "")
            value = os.path.normpath(os.path.join(project_dir, default_value)) \
                if option.get("toabs", False) else default_value
            if option_name and \
                    (not config.has_option(env_name, option_name) or config.get(env_name, option_name) is None):
                config.set(env_name, option_name, value)
        config.save()

    @staticmethod
    @Handler.method()
    def config_update_options(params):
        path = platformio.util.get_real_path(params[0])
        board = params[1]
        config = ProjectConfig(path, parse_extra=False, expand_interpolations=False)
        load_done = ProjectRPC._config_update_from_json(config, path, board)
        if load_done:
            return True
        for env in config.envs():
            options = ProjectOptions["env.default_options"].default
            for option in options:
                _name, _value = option.split("=", 1)
                if not config.has_option(f"env:{env}", _name.strip()):
                    config.set(f"env:{env}", _name.strip(), _value.strip())
        return config.save()

    @staticmethod
    @Handler.method()
    def get_config_schema():
        return get_config_options_schema()

    @staticmethod
    @Handler.method()
    def get_possible_framework(params):
        if os.path.isfile(os.path.join(params[0], 'bundle.json')):
            return 'hpm'
        return 'hb'

    @staticmethod
    @Handler.method()
    def get_projects():
        def _get_project_data():
            data = {"boards": [], "envLibdepsDirs": [], "libExtraDirs": []}
            config = ProjectConfig()
            data["envs"] = config.envs()
            data["description"] = config.get("deveco", "description")
            data["libExtraDirs"].extend(config.get("deveco", "lib_extra_dirs", []))

            libdeps_dir = config.get_optional_dir("libdeps")
            for section in config.sections():
                if not section.startswith("env:"):
                    continue
                data["envLibdepsDirs"].append(os.path.join(libdeps_dir, section[4:]))
                if config.has_option(section, "platform"):
                    data["platform"] = config.get(section, "platform")
                if config.has_option(section, "board"):
                    data["boards"].append(config.get(section, "board"))
                data["libExtraDirs"].extend(config.get(section, "lib_extra_dirs", []))

            # skip non existing folders and resolve full path
            for key in ("envLibdepsDirs", "libExtraDirs"):
                data[key] = [
                    platformio.fs.expanduser(d) if d.startswith("~") else os.path.realpath(d)
                    for d in data[key]
                    if os.path.isdir(d)
                ]

            data["frameworks"] = set()
            for section in config.sections():
                data["frameworks"].update(config.get(section, "framework", []))

            return data

        def _path_to_name(path):
            return os.path.basename(path)

        result = []
        pm = PlatformManager()
        for project_dir in AppRPC.load_state()["storage"]["recentProjects"]:
            if not os.path.isdir(project_dir):
                continue
            boards = []
            try:
                with platformio.fs.cd(project_dir):
                    project_data = _get_project_data()
            except ProjectError:
                continue

            for board_id in project_data.get("boards", []):
                name = board_id
                try:
                    name = pm.board_config(board_id)["name"]
                except platformio.exception.PlatformioException:
                    pass
                boards.append({"id": board_id, "name": name})

            result.append(
                {
                    "path": project_dir,
                    "name": _path_to_name(project_dir),
                    "modified": int(os.path.getmtime(project_dir)),
                    "boards": boards,
                    "description": project_data.get("description"),
                    "envs": project_data.get("envs", []),
                    "envLibStorages": [
                        {"name": os.path.basename(d), "path": d}
                        for d in project_data.get("envLibdepsDirs", [])
                    ],
                    "extraLibStorages": [
                        {"name": _path_to_name(d), "path": d}
                        for d in project_data.get("libExtraDirs", [])
                    ],
                    "frameworks": list(project_data.get('frameworks', [])),
                    "platform": project_data.get('platform', '')
                }
            )
        return result

    @staticmethod
    @Handler.method()
    def get_project_examples():
        result = []
        for manifest in PlatformManager().get_installed():
            examples_dir = os.path.join(manifest["__pkg_dir"], "examples")
            if not os.path.isdir(examples_dir):
                continue
            items = []
            for project_dir, _, __ in os.walk(examples_dir):
                try:
                    config = ProjectConfig(os.path.join(project_dir, ".deveco", "deveco.ini"))
                    config.validate(silent=True)
                    project_description = config.get("deveco", "description")
                except ProjectError:
                    continue

                path_tokens = project_dir.split(os.path.sep)
                items.append(
                    {
                        "name": "/".join(
                            path_tokens[path_tokens.index("examples") + 1:]
                        ),
                        "path": project_dir,
                        "description": project_description,
                    }
                )
            result.append(
                {
                    "platform": {
                        "title": manifest["title"],
                        "version": manifest["version"],
                    },
                    "items": sorted(items, key=lambda item: item["name"]),
                }
            )
        return sorted(result, key=lambda data: data["platform"]["title"])

    @staticmethod
    def handle_framework(preconfigured_params, framework, args, hpm_base_package, hpm_template):
        if framework:
            preconfigured_params.append("framework")
            preconfigured_params.append("build_type")
            args.extend(["--project-option", "framework = %s" % framework])
            if framework == "hpm" and hpm_base_package:
                args.extend(["--project-option", f"hpm_project_base_package = {hpm_base_package}"])
            if framework == "hpm" and hpm_template and "name" in hpm_template:
                args.extend(["--project-option", f"hpm_project_template = {hpm_template['name']}"])
            if framework == "hpm":
                args.extend(["--project-option", "build_type = release"])

    @Handler.method()
    def init(self, params, request_id):
        framework, project_dir = params[2], platformio.util.get_real_path(params[3])
        hpm_base_package, hpm_template = params[4], params[5]
        chip_package_path, generate_code = platformio.util.get_real_path(params[6]), params[7]
        ohos_version, ohos_kernel = params[8], params[9]
        env_prefix, hb_product = params[10], params[11]
        download_type, download_name = params[12], params[13]
        download_size, download_url = params[14], params[15]
        preconfigured_params = ["platform", "board"]
        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")
        state = AppRPC.load_state()
        if not os.path.isdir(project_dir):
            os.makedirs(project_dir)
        args = ["init", "--board", params[1]]
        if params[0]:
            args.extend(["--project-option", "platform = %s" % params[0]])

        ProjectRPC.handle_framework(preconfigured_params, framework, args, hpm_base_package, hpm_template)

        if chip_package_path:
            if not os.path.exists(chip_package_path):
                raise ValueError(f"Invalid value: {chip_package_path}")
            args.extend(["--project-option", f"chip_package_path = {chip_package_path}"])
            args.extend(["--project-option", f"generate_code = {generate_code}"])
        if ohos_version:
            args.extend(["--project-option", f"ohos_version = {ohos_version}"])
        if ohos_kernel:
            args.extend(["--project-option", f"ohos_kernel = {ohos_kernel}"])
        if env_prefix:
            args.extend(["--env-prefix", env_prefix])
        if state["storage"]["coreCaller"] and state["storage"]["coreCaller"] in ProjectGenerator.get_supported_ides():
            args.extend(["--ide", state["storage"]["coreCaller"]])
        if hb_product:
            args.extend(["--project-option", f"board_frameworks.hb.build.product = {hb_product}"])
        if download_type:
            args.extend(["--project-option", f"download_type = {download_type}"])
        if download_name:
            args.extend(["--project-option", f"download_name = {download_name}"])
        if download_url is not None:
            args.extend(["--project-option", f"download_url = {download_url}"])
        if download_size is not None:
            args.extend(["--project-option", f"download_size = {download_size}"])

        args.extend(["--project-option", f"download_status = init"])

        return self.__core_call([args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @Handler.method()
    def cread_windows_project_init(self, params, request_id):
        chipconfig_platform = ['vendorhm', 'aucu']
        platform = params[0]
        framework = params[2]
        project_dir = params[3]
        hpm_template = params[4]
        chip_package_path = params[5]
        preconfigured_params = ["platform", "board"]
        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")
        if not os.path.isdir(project_dir):
            os.makedirs(project_dir)
        args = ["init", "--board", params[1]]
        if params[0]:
            args.extend(["--project-option", "platform = %s" % params[0]])
        if framework:
            preconfigured_params.append("framework")
            preconfigured_params.append("build_type")
            args.extend(["--project-option", "framework = %s" % framework])
            if framework == "hpm" and hpm_template and "name" in hpm_template:
                args.extend(["--project-option", f"hpm_project_template = {hpm_template['name']}"])
        if chip_package_path:
            args.extend([
             "--project-option",
             f"chip_package_path = {chip_package_path}"
            ])        
        if platform in chipconfig_platform:
            generate_code = params[6]
            args.extend([
             "--project-option",
             f"generate_code = {generate_code}"
            ])

        return self.__core_call([args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @Handler.method()
    def import_liteos_source(self, params, request_id):
        platform_name = params[0]
        boards = params[1]
        framework = params[2]
        chip_package_path = platformio.util.get_real_path(params[3])
        project_dir = platformio.util.get_real_path(params[4])
        hpm_base_package = params[5]
        preconfigured_params = ["platform", "board"]
        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")
        state = AppRPC.load_state()
        if not os.path.isdir(project_dir):
            raise FileNotFoundError("Not a directory: %s" % project_dir)
        args = ["init"]
        for board in boards:
            args.extend(['--board', board])
        if platform_name:
            args.extend(["--project-option", "platform = %s" % platform_name])
        if framework:
            preconfigured_params.append("framework")
            preconfigured_params.append("build_type")
            args.extend(["--project-option", "framework = %s" % framework])
            if framework == "hpm" and hpm_base_package:
                args.extend(["--project-option", f"hpm_project_base_package = {hpm_base_package}"])
            if framework == "hpm":
                args.extend(["--project-option", "build_type = release"])
            if 'hb' in framework:
                args.extend(["--project-option", "build_type = debug"])
        if chip_package_path:
            args.extend(
                ["--project-option",
                 f"chip_package_path = {chip_package_path}"])
        if state["storage"]["coreCaller"] and state["storage"]["coreCaller"] in \
                ProjectGenerator.get_supported_ides():
            args.extend(["--ide", state["storage"]["coreCaller"]])

        return self.__core_call(
            [args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @staticmethod
    def generate_init_project_options(args, **kwargs):
        if kwargs.get('platform_name'):
            args.extend(["--project-option", f"platform = {kwargs.get('platform_name')}"])
        if kwargs.get('framework'):
            args.extend(["--project-option", f"framework = {kwargs.get('framework')}"])
        if kwargs.get('ohos_version'):
            args.extend(["--project-option", f"ohos_version = {kwargs.get('ohos_version')}"])
        if kwargs.get('product'):
            args.extend(["--project-option", f"board_frameworks.hb.build.product = {kwargs.get('product')}"])
        if kwargs.get('profile'):
            args.extend(["--project-option", f"download_profile = {kwargs.get('profile')}"])
        return args

    @staticmethod
    def check_files(profile: str, data_sheep: str, profile_sha256: str, readme_sha256: str,
                    data_sheet_sha256: str) -> str or None:

        profile_path = os.path.join(get_config_json_path(), '.cache', 'profile', profile)
        with os.fdopen(os.open(profile_path, os.O_RDWR, 0o644), 'rb') as file_handle:
            if hashlib.new('sha256', file_handle.read()).hexdigest() != profile_sha256:
                return 'profileSHA256Mismatch'

        readme_path = os.path.join(get_config_json_path(), '.cache', 'profile', 'README.md')
        with os.fdopen(os.open(readme_path, os.O_RDWR, 0o644), 'rb') as file_handle:
            if hashlib.new('sha256', file_handle.read()).hexdigest() != readme_sha256:
                return 'readmeSHA256Mismatch'

        if data_sheep:
            profile_pdf_path = os.path.join(get_config_json_path(), '.cache', 'profile', data_sheep)
            with os.fdopen(os.open(profile_pdf_path, os.O_RDWR, 0o644), 'rb') as file_handle:
                if hashlib.new('sha256', file_handle.read()).hexdigest() != data_sheet_sha256:
                    return 'dataSheetSHA256Mismatch'

        return ''

    @staticmethod
    def transfer_file(profile, profile_pdf, project_dir):
        profile_path = os.path.join(get_config_json_path(), '.cache', 'profile', profile)

        if not os.path.isfile(profile_path):
            raise FileNotFoundError(profile)
        deveco_path = os.path.join(project_dir, '.deveco')
        if not os.path.isdir(deveco_path):
            os.makedirs(deveco_path)
        tar_file = tarfile.open(profile_path)
        tar_file.extractall(os.path.join(deveco_path, 'profile'))
        tar_file.close()
        os.remove(profile_path)

        readme_path = os.path.join(get_config_json_path(), '.cache', 'profile', 'README.md')
        if not os.path.isfile(readme_path):
            raise FileNotFoundError(readme_path)
        shutil.copyfile(readme_path, os.path.join(deveco_path, 'profile', 'README.md'))
        os.remove(readme_path)

        if profile_pdf:
            profile_pdf_path = os.path.join(get_config_json_path(), '.cache', 'profile', profile_pdf)
            if not os.path.isfile(profile_pdf_path):
                raise FileNotFoundError(profile_pdf_path)
            shutil.copyfile(profile_pdf_path, os.path.join(deveco_path, 'profile', profile_pdf))
            os.remove(profile_pdf_path)

    @Handler.method()
    def import_profile_source(self, params, request_id):
        platform_name = params[0]
        board = params[1]
        framework = params[2]
        ohos_version = params[3]
        product = params[4]
        protocol = params[5]
        profile = params[6]
        env_prefix = params[7]
        project_dir = platformio.util.get_real_path(params[8])
        profile_pdf = unquote(params[10]) if params[10] != 'undefined' else ''
        profile_sha256 = params[11]
        readme_sha256 = params[12]
        data_sheet_sha256 = params[13] if params[10] != 'undefined' else ''

        check_result = ProjectRPC.check_files(profile, profile_pdf, profile_sha256, readme_sha256, data_sheet_sha256)
        if check_result:
            return check_result

        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")

        ProjectRPC.transfer_file(profile, profile_pdf, project_dir)

        args = ["init"]
        if board:
            args.extend(['--board', board])

        args = ProjectRPC.generate_init_project_options(
            args,
            platform_name=platform_name,
            framework=framework,
            ohos_version=ohos_version,
            product=product,
            profile=profile,
        )

        download_url = OHOS_GITEE_HTTPS if protocol == 'https' else OHOS_GITEE_SSH
        args.extend(["--project-option", f"download_url = {download_url}"])
        args.extend(["--project-option", "download_type = repo"])
        args.extend(["--project-option", "download_status = init"])
        if profile_pdf:
            args.extend(["--project-option", f"profile_pdf = {profile_pdf}"])

        if env_prefix:
            args.extend(["--env-prefix", env_prefix])

        state = AppRPC.load_state()
        if state["storage"]["coreCaller"] and state["storage"]["coreCaller"] in \
                ProjectGenerator.get_supported_ides():
            args.extend(["--ide", state["storage"]["coreCaller"]])

        return self.__core_call([args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @staticmethod
    def _is_match_board(framework, frk, product_name, product):
        is_match_l2 = framework == 'ohos-sources' and frk.get('name', '') == framework and \
                      frk.get('build', {}).get('product_name', '') == product_name
        is_match_hb = framework == 'hb' and frk.get('name', '') == framework and \
                      ((frk.get('build', {}).get('product', '') == product) or (product in frk.get('products', [])))
        return is_match_l2 or is_match_hb

    @staticmethod
    @Handler.method()
    def get_match_board_id(params):
        platform_name = params[0]
        mcu = params[1]
        product = params[2]
        board_id = 'blank'
        if platform_name == 'blank':
            return board_id
        product_name, vendor = product.split('@')
        framework = 'hb' if vendor != 'built-in' else 'ohos-sources'
        for board_info in PlatformManager().get_installed_boards():
            if board_info.get('platform') == platform_name and board_info.get('mcu') == mcu:
                # use the first found boad_id if no match
                board_id = board_info.get('id')
                res = ProjectRPC.handle_get_board_id(board_info, framework, product_name, product)
                if res:
                    return res
        return board_id

    @staticmethod
    def handle_get_board_id(board_info, framework, product_name, product):
        for frk in board_info.get('frameworks', []):
            if ProjectRPC._is_match_board(framework, frk, product_name, product):
                return board_info.get('id')
        return ''

    @Handler.method()
    def import_ohos_source(self, params, request_id):
        platform_name = params[0]
        board_id = params[1]
        product = params[2]
        ohos_version = params[3]
        ohos_kernel = params[4]
        env_prefix = params[5]
        project_dir = platformio.util.get_real_path(params[6])
        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")
        state = AppRPC.load_state()
        if not os.path.isdir(project_dir):
            raise FileNotFoundError("Not a directory: %s" % project_dir)
        args = ["init"]

        args.extend(['--board', board_id])

        _, vendor = product.split('@')
        framework = 'hb' if vendor != 'built-in' else 'ohos-sources'
        args.extend(["--project-option", "framework = %s" % framework])

        if platform_name:
            args.extend(["--project-option", "platform = %s" % platform_name])

        if product:
            args.extend(["--project-option", "board_frameworks.hb.build.product = %s" % product])
            args.extend(["--project-option", "build_type = debug"])

        if ohos_version:
            args.extend(["--project-option", "ohos_version = %s" % ohos_version])

        if ohos_kernel:
            args.extend(["--project-option", "ohos_kernel = %s" % ohos_kernel])

        if env_prefix:
            args.extend(["--env-prefix", env_prefix])

        if state["storage"]["coreCaller"] and state["storage"]["coreCaller"] in \
                ProjectGenerator.get_supported_ides():
            args.extend(["--ide", state["storage"]["coreCaller"]])

        return self.__core_call(
            [args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @Handler.method()
    def import_v1_project(self, params, request_id):
        project_dir = platformio.util.get_real_path(params[0])
        prefer_file = platformio.util.get_real_path(params[1])
        preconfigured_params = ["platform", "board"]
        if not project_dir:
            raise ValueError(f"Invalid value: {project_dir}")
        state = AppRPC.load_state()
        if not os.path.isdir(project_dir):
            raise FileNotFoundError("Not a directory: %s" % project_dir)
        args = ["project", "import", "--prefer-file", prefer_file]
        framework = "ohos-sources"
        preconfigured_params.append("framework")
        preconfigured_params.append("build_type")
        args.extend(["--project-option", "framework = %s" % framework])
        args.extend(["--project-option", "build_type = debug"])
        if state["storage"]["coreCaller"] and state["storage"]["coreCaller"] in ProjectGenerator.get_supported_ides():
            args.extend(["--ide", state["storage"]["coreCaller"]])

        return self.__core_call([args, {"cwd": project_dir}], request_id, lambda code, text: (code, project_dir))

    @staticmethod
    @Handler.method()
    def remove_202_config(params):
        project_dir = platformio.util.get_real_path(params[0])
        deveco_ini = os.path.join(project_dir, '.deveco', 'deveco.ini')
        config = ProjectConfig(deveco_ini, parse_extra=False, expand_interpolations=False)
        try:
            if config.get_version() > '2.0.2':
                return
            is_special_platform = False
            for env in config.envs():
                platform_name = config.get(f'env:{env}', 'platform')
                if platform_name in ('ambiq', 'vendorhh'):
                    is_special_platform = True
                    break
            if not is_special_platform:
                os.remove(deveco_ini)
        except ProjectError:
            os.remove(deveco_ini)

    @staticmethod
    @Handler.method()
    def update_ohos_version(params):
        project_dir = platformio.util.get_real_path(params[0])
        deveco_ini = os.path.join(project_dir, '.deveco', 'deveco.ini')
        config = ProjectConfig(deveco_ini, parse_extra=False, expand_interpolations=False)
        if not config.has_section('env'):
            config.add_section('env')
        if params[1]:
            config.set('env', 'ohos_version', params[1])
        return config.save()

    @staticmethod
    @Handler.method()
    def get_env_ohos_version(params):
        project_dir = platformio.util.get_real_path(params[0])
        deveco_ini = os.path.join(project_dir, '.deveco', 'deveco.ini')
        config = ProjectConfig(deveco_ini, parse_extra=False, expand_interpolations=False)
        version = ''
        if config.has_section('env') and config.has_option('env', "ohos_version"):
            version = config.get("env", 'ohos_version', '')
        return version

    @staticmethod
    @Handler.method()
    def get_env_ohos_kernel(params):
        project_dir = platformio.util.get_real_path(params[0])
        deveco_ini = os.path.join(project_dir, '.deveco', 'deveco.ini')
        config = ProjectConfig(deveco_ini, parse_extra=False, expand_interpolations=False)
        kernel = ''
        if config.has_section('env') and config.has_option('env', "ohos_kernel"):
            kernel = config.get("env", 'ohos_kernel', '')
        return kernel

    @staticmethod
    @Handler.method()
    def get_env_products(params):
        product_list = []
        project_dir = platformio.util.get_real_path(params[0])
        deveco_ini = os.path.join(project_dir, '.deveco', 'deveco.ini')
        config = ProjectConfig(deveco_ini, parse_extra=False, expand_interpolations=False)
        framework = config.get('env', 'framework', [])
        for env in config.envs():
            try:
                product = config.get('env:' + env, 'board_frameworks.hb.build.product') \
                    if 'hpm' not in framework else config.get("env:" + env, 'hpm_project_base_package')
                if product and product not in product_list:
                    product_list.append(product)
            except ProjectError:
                pass
        product_list.reverse()
        return product_list

    @staticmethod
    @Handler.method()
    def prepare_download_script(params):
        project_dir = platformio.util.get_real_path(params[0])
        dest_path = os.path.join(project_dir, '.deveco', 'status', 'download_tools.py')
        if not os.path.isfile(dest_path):
            if not os.path.isdir(os.path.dirname(dest_path)):
                os.makedirs(os.path.dirname(dest_path))
            src_path = os.path.join(get_installed_core_path(), 'core', 'tool_utils', 'download_tools.py')
            shutil.copy(os.path.realpath(src_path), os.path.realpath(dest_path))

    @staticmethod
    @Handler.method()
    def is_downloading(params):
        project_dir = platformio.util.get_real_path(params[0])
        dest_path = os.path.join(project_dir, '.deveco', 'status', 'pid')
        if os.path.isfile(dest_path):
            with open(dest_path, 'r') as pid_file:
                pid = pid_file.readline()
                if psutil.pid_exists(int(pid)):
                    return True
        return False

    @staticmethod
    @Handler.method()
    def is_sdk_available(params):
        dest_path = params[0]
        files = os.listdir(dest_path)
        if "Version.md" in files:
            versionPath = os.path.join(dest_path, "Version.md")
            with open(versionPath) as f:
                lines = f.readlines()
            for line in lines:
                if line.find("Solarec") != -1:
                    return True
        return False

    @staticmethod
    @Handler.method()
    def get_open_harmony_source_info() -> List[Dict]:
        oh_cfg_path: str = os.path.join(get_installed_core_path(), 'core', 'tool_utils', 'openharmony_info.json')
        oh_cfg_path = os.path.realpath(oh_cfg_path)
        oh_cfg_info: List[Dict] = json.load(open(oh_cfg_path, 'rt'))
        return oh_cfg_info

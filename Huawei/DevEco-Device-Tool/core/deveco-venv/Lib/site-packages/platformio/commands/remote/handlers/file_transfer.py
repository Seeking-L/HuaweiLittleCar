import base64
import os
import zipfile
from platformio.helpers import get_upload_tool_path, get_upload_tool_zip_path
import platformio.commands.remote.handlers.base_handler
from platformio.rpc.server import Handler
from platformio.project.config import ProjectConfig


class FileTransfer(platformio.commands.remote.handlers.base_handler.BaseHandler):
    CHUNK_SIZE = 1024 * 10
    file_map = {}

    @Handler.method()
    def upload(self, params):
        if params['burn_tool']:
            local_path = os.path.join(get_upload_tool_zip_path(), params['file_name'])
        else:
            local_path = self.session.remote_to_local_path_file(remote=params['file'])
            self.file_map[params['file']] = local_path
        if not os.path.exists(local_path):
            os.makedirs(os.path.dirname(local_path), exist_ok=True)
        with open(local_path, 'rb+' if params.get('offset') and os.path.isfile(local_path) else 'wb+') as f:
            byte_data = base64.b64decode(params.get('content'))
            f.seek(params.get('offset'))
            f.write(byte_data)

    @Handler.method()
    def deveco_mapping(self, params):
        deveco_path = self.file_map[params["deveco_path"]]
        local_project = ProjectConfig(deveco_path)
        for section, option, values in self.project_config_iterator(local_project):
            for remote_path, local_path in self.file_map.items():
                remote_rel_path = self.session.get_remote_rel_path(remote_path)
                values = self.handle_values_by_path(values, remote_path, remote_rel_path, local_path)
            local_project.set(section=section, option=option, value=values)
        local_project.save(deveco_path)

    @staticmethod
    def handle_values_by_path(values, remote_path, remote_rel_path, local_path):
        if isinstance(values, (list, tuple)):
            for i, value in enumerate(values):
                if value in (remote_path, remote_rel_path):
                    values[i] = local_path
        else:
            if values in (remote_path, remote_rel_path):
                values = local_path
        return values

    @staticmethod
    def project_config_iterator(project):
        for section in project.sections():
            for option in project.options(section):
                yield section, option, project.get(section=section, option=option)

    @Handler.method()
    def download(self, params):
        local_path = self.session.remote_to_local_path_command(remote=params['file'])
        if not os.path.exists(local_path):
            raise FileNotFoundError(f'file {local_path} to be transferred does not exist')
        size = os.stat(local_path).st_size
        with open(local_path, 'rb') as f:
            f.seek(params.get('offset'))
            chunk = f.read(self.CHUNK_SIZE)
        return {'size': size, 'content': base64.b64encode(chunk).decode(), 'offset': params.get('offset')}


    @Handler.method()
    def check_upload_file(self, params):
        return os.path.exists(os.path.join(get_upload_tool_zip_path(), params['zip_name']))


    @Handler.method()
    def check_tool_file(self, params):
        return os.path.exists(os.path.join(get_upload_tool_path(), params['tool_name']))


    @Handler.method()
    def unzip_file(self, params):
        zip_path = os.path.join(get_upload_tool_zip_path(), params['zip_name'])
        tool_path = os.path.join(get_upload_tool_path(), params['tool_name'])
        f = zipfile.ZipFile(zip_path, 'r')
        f.extractall(tool_path)
        f.close()

# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-arguments,too-many-locals, too-many-branches

import os
import json
import codecs
from typing import List
from packaging import version
import click
import hpm_adapter  # pylint: disable=import-error, no-name-in-module
from tabulate import tabulate
import xml.etree.ElementTree as xml
import re

from platformio import exception, fs
from platformio.commands.platform import platform_install as cli_platform_install
from platformio.ide.projectgenerator import ProjectGenerator
from platformio.managers.platform import PlatformManager, PlatformFactory
from platformio.project.config import ProjectConfig
from platformio.project.exception import NotPlatformIOProjectError
from platformio.project.helpers import is_platformio_project
from platformio.project.options import ProjectOptions
from platformio.commands.exception import UnknownError

@click.group(short_help="Project Manager")
def cli():
    pass


@cli.command("config", short_help="Show computed configuration")
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=True, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--json-output", is_flag=True)
def project_config(project_dir, json_output):
    if not is_platformio_project(project_dir):
        raise NotPlatformIOProjectError(project_dir)
    with fs.cd(project_dir):
        config = ProjectConfig.get_instance()
    if json_output:
        return click.echo(config.to_json())
    click.echo(
        "Computed project configuration for %s" % click.style(project_dir, fg="cyan")
    )
    for section, options in config.as_tuple():
        click.echo()
        click.secho(section, fg="cyan")
        click.echo("-" * len(section))
        click.echo(
            tabulate(
                [
                    (name, "=", "\n".join(value) if isinstance(value, list) else value)
                    for name, value in options
                ],
                tablefmt="plain",
            )
        )
    return None


def validate_boards(ctx, param, value):  # pylint: disable=W0613
    pm = PlatformManager()
    for id_ in value:
        try:
            pm.board_config(id_)
        except exception.UnknownBoard as e:
            raise click.BadParameter(
                "`%s`. Please search for board ID using `hos boards` "
                "command" % id_
            ) from e
    return value


@cli.command("init", short_help="Initialize a project or update existing")
@click.option(
    "--project-dir",
    "-d",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("-b", "--board", multiple=True, metavar="ID", callback=validate_boards)
@click.option("--ide", type=click.Choice(ProjectGenerator.get_supported_ides()))
@click.option("-O", "--project-option", multiple=True)
@click.option("--env-prefix", default="")
@click.option("-s", "--silent", is_flag=True)
@click.pass_context
def project_init(
    ctx,  # pylint: disable=R0913
    **kwargs
):
    project_dir = kwargs.get("project_dir")
    board = kwargs.get("board")
    ide = kwargs.get("ide")
    project_option = kwargs.get("project_option")
    env_prefix = kwargs.get("env_prefix")
    silent = kwargs.get("silent")

    __echo_path_info(silent, project_dir)
    is_new_project = not is_platformio_project(project_dir)
    if is_new_project:
        if not os.path.exists(os.path.join(project_dir, ".deveco")):
            os.mkdir(os.path.join(project_dir, ".deveco"))
        init_base_project(project_dir)
    else:
        project_file_convert(os.path.join(project_dir, ".deveco", "deveco.ini"))

    if board:
        fill_project_envs(
            ctx, project_dir, board, project_option, env_prefix=env_prefix, force_download=ide is not None,
            import_settings=None
        )

    if ide:
        pg = ProjectGenerator(project_dir, ide, board)
        pg.generate()

    __echo_success(silent, ide, is_new_project)


def ini_fill(path):
    convert = False
    board_platform = {
        'asr582x': 'asrmicro',
        'bes2600w': 'bestechnic',
        'blank': 'blank',
        'bl602': 'bouffalo',
        'hh_scdy100': 'hihope',
        'hi3516dv300': 'hisilicon_arm',
        'hi3518ev300': 'hisilicon_arm',
        'hi3861': 'hisilicon_riscv',
        'bearpi_hm_nano': 'hisilicon_riscv',
        'imx6ull': 'nxp',
        'qemucortexa7': 'qemu',
        'rtl8720': 'realtek',
        'w800': 'winnermicro',
        'xr872': 'xradio'
    }

    config = ProjectConfig(path, parse_extra=False)
    for section in config.sections():
        cond = [section.startswith("env:"),
                config.has_option(section, "board"),
                config.has_option(section, "platform")
                ]
        if all(cond) and config.get(section, "platform") == 'hisilicon':
            board_id = config.get(section, "board")
            if board_id in board_platform:
                convert = True
                config.set(
                    section,
                    "platform",
                    board_platform[board_id],
                )

        cond2 = [section.startswith("partition:"),
                    config.has_option(section, "partition_board"),
                    not config.has_option(section, "partition_platform")
                ]
        if all(cond2):
            board_id = config.get(section, "partition_board")
            if board_id in board_platform:
                convert = True
                config.set(
                section,
                "partition_platform",
                board_platform[board_id],
            )

    if convert:
        config.save()


def project_file_convert(path):
    with open(path, "r") as fp:
        next(fp)
        line = fp.readline()
        ini_version = ''
        if 'Version:' in line:
            ini_version = line.split(':')[1].strip()

    if ini_version and version.parse(ini_version) <= version.parse('2.0.1'):
        ini_fill(path)

    if ini_version and version.parse(ini_version) <= version.parse('3.0.0'):
        config = ProjectConfig(path, parse_extra=False)
        convert_partition = []
        for section in config.sections():
            if section.startswith("env:") and config.has_option(section, "upload_partitions"):
                upload_partitions = config.get(section, "upload_partitions")
                partition_env = section[4:]
                convert_partition.append({'env': partition_env, 'upload_partitions' : upload_partitions})
        for partitions in convert_partition:
            for par in partitions['upload_partitions']:
                config.set(
                    par,
                    "partition_env",
                    partitions['env']
                )
        for section in config.sections():
            if section.startswith("partition:") and not config.has_option(section, "partition_env"):
                config.remove_section(section)
        config.save()

    if ini_version and version.parse(ini_version) <= version.parse('3.0.1'):
        add_suite_burn_enable(path)


def add_suite_burn_enable(path):
    convert = False
    config = ProjectConfig(path, parse_extra=False)
    for section in config.sections():
        if section.startswith("env:") and config.get(section, "platform") and config.get(section, "board"):
            p = PlatformFactory.newPlatform(config.get(section, "platform"))
            board_config = p.board_config(config.get(section, "board"))
            if 'upload' in board_config.manifest and 'suite_tool' in board_config.manifest['upload']:
                suite_tool = board_config.manifest.get('upload', {}).get('suite_tool', False)
                config.set(section, "suite_burn_enable", suite_tool)
                convert = True

    if convert:
        config.save()


def init_base_project(project_dir):
    with fs.cd(project_dir):
        config = ProjectConfig()
        config.save()


def init_cvs_ignore(project_dir):
    conf_path = os.path.join(project_dir, ".gitignore")
    if os.path.isfile(conf_path):
        return
    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    with os.fdopen(os.open(conf_path, flags, 0o640), "w") as fp:
        fp.write(".deveco\n")


class DownloadInfo(dict):
    """
    download Bean object while project initialization
    """

    def __init__(self):
        super(DownloadInfo, self).__init__(
            download_type='',
            download_name='',
            download_url='',
            download_size='',
            download_status='',
            download_profile='',
            profile_pdf=''
        )


def __get_board_config(import_settings, board_id, pm, project_platform):
    """
    get board config
    """
    if import_settings:
        arms = ['hi3516dv300', 'hi3518ev300']
        platform_name = 'hisilicon_arm' if board_id in arms else 'hisilicon_riscv'
        board_config = pm.board_config(board_id, platform_name)
    elif project_platform:
        _, _value = project_platform[0].split("=", 1)
        board_config = pm.board_config(board_id, _value.strip())
    else:
        board_config = pm.board_config(board_id)
    return board_config


def __customize_config_option(debug_name, upload_name):
    """
    User-defined configuration
    """
    return [
        # debug options
        {'option': 'debug_extra_cmds', 'path': f'debug.{debug_name}.launchAttach.postAttachCommandsSetSubPath',
         'convert': lambda x: [i for i in x if i]},
        {'option': 'debug_extra_cmds', 'path': f'debug.{debug_name}.launchAttach.'
                                               f'postAttachCommandsAddSymbolfile',
         'convert': lambda x: [i for i in x if i]},
        dict(option='debug_elf', path=f'debug.{debug_name}.launchAttach.executable'),
        # serial upload
        {'option': 'upload_port', 'path': f'upload.{upload_name}.serial.portnum'},
        {'option': 'upload_speed', 'path': f'upload.{upload_name}.serial.baudRate'},
        # network upload
        {'option': 'upload_net_client_ip', 'path': 'upload.network.network.remoteip'},
        {'option': 'upload_net_client_mask', 'path': 'upload.network.network.netmask'},
        {'option': 'upload_net_client_gw', 'path': 'upload.network.network.gateway'},
        {'option': 'upload_net_server_ip', 'path': 'upload.network.network.hostip'}
    ]


def __handle_old_settings(imported_options, imported_partitions, old_settings):
    """
    Processing Configuration Files of the v1 Version
    """
    for cfg in old_settings.get('configList', []):
        board = cfg.get('base', {}).get('board', '')
        upload_name = cfg.get('upload', {}).get('script', '')
        mem_type = cfg.get('upload', {}).get(upload_name, {}).get('device', {}).get('memtype', 'emmc')
        debug_name = cfg.get('debug', {}).get('script', '')

        imported_partitions[board] = cfg.get('upload', {}).get('partitions', [])
        for i in range(len(imported_partitions[board])):
            imported_partitions[board][i]['mem_type'] = mem_type if 'emmc' in mem_type else 'spi'

        import_mapping = __customize_config_option(debug_name, upload_name)
        if board not in imported_options:
            imported_options[board] = {}

        __add_rule_path(import_mapping, cfg, imported_options, board)


def __add_rule_path(import_mapping, cfg, imported_options, board):
    """
    add rule path
    """
    for rule in import_mapping:
        val = cfg
        for j_path in rule['path'].split('.'):
            val = val.get(j_path, {})
        if val and 'convert' in rule:
            val = rule['convert'](val)
        if val:
            if rule['option'] in imported_options[board]:
                imported_options[board][rule['option']] += val
            else:
                imported_options[board][rule['option']] = val


def __add_upload_options(board, config, env_prefix, board_id, output_bin):
    """
    Add upload config for deveco.ini
    """
    if 'upload' in board.manifest and 'partition_types' in board.manifest['upload']:
        for k in board.manifest['upload']['partition_types']:
            section = f"partition:{env_prefix}_{k}"
            config.add_section(section)
            config.set(section, 'partition_env', f"{env_prefix}")
            config.set(section, 'partition_type', k)
            config.set(section, 'partition_board', board_id)
            config.set(section, 'partition_platform', board.manifest['platform'])
            if output_bin and k in output_bin:
                config.set(section, 'partition_bin', output_bin.get(k, ''))
    return config


def __add_upload_port_protocol(board, envopts):
    """
    Adding a upload port and protocol
    """
    if 'upload' in board.manifest:
        envopts['upload_port'] = ''
        protocol = board.manifest.get('upload', {}).get('protocol', '')
        if protocol:
            envopts['upload_protocol'] = protocol

        if 'suite_tool' in board.manifest['upload']:
            envopts['suite_burn_enable'] = board.manifest.get('upload', {}).get('suite_tool', False)


def __add_partition_section_by_imported(imported_partitions, board_id, config):
    """
    set partition section by imported partitions
    """
    if board_id in imported_partitions:
        for i in range(len(imported_partitions[board_id])):
            file_path = __resolve_bin_path(imported_partitions[board_id][i].get('path'), board_id)
            section = f"partition:{board_id}_user{i}"
            config.add_section(section)
            config.set(section, 'partition_type', 'fastboot' if 'boot' in os.path.basename(file_path) else 'user')
            config.set(section, 'partition_board', board_id)
            config.set(section, 'partition_bin', os.path.normpath(file_path))
            config.set(section, 'partition_mem', imported_partitions[board_id][i].get('mem_type'))
            config.set(section, 'partition_addr', _to_hex_str(imported_partitions[board_id][i].get('destAddr')))
            config.set(section, 'partition_length', _to_hex_str(imported_partitions[board_id][i].get('size')))
    return config


def __add_upload_partitions_to_envopts(envopts, imported_partitions, board_id, board, env_prefix):
    """
    add upload partitions to envopts
    """
    if 'upload_partitions' not in envopts:
        envopts['upload_partitions'] = []

    if board_id in imported_partitions and len(imported_partitions[board_id]) > 0:
        for i in range(len(imported_partitions[board_id])):
            if imported_partitions[board_id][i].get('used', True):
                envopts['upload_partitions'].append(f'partition:{board_id}_user{i}')
    elif 'upload' in board.manifest and 'partition_types' in board.manifest['upload']:
        for k in board.manifest['upload']['partition_types']:
            envopts['upload_partitions'].append(f"partition:{env_prefix}_{k}")
    if len(envopts['upload_partitions']) == 0:
        del envopts['upload_partitions']


def __set_global_options_for_env(framework, ohos_version, ohos_kernel, down_info, config):
    """
    set framework for global
    """
    if any([framework, ohos_version, ohos_kernel, down_info.get("download_type") is not None]):
        if not config.has_section("env"):
            config.add_section("env")

        for k, v in down_info.items():
            if v is not None and not config.has_option("env", k):
                config.set("env", k, v)

        if framework and not config.has_option("env", "framework"):
            config.set("env", "framework", framework)

        if ohos_version and not config.has_option("env", "ohos_version"):
            config.set("env", "ohos_version", ohos_version)

        if ohos_kernel and not config.has_option("env", "ohos_kernel"):
            config.set("env", "ohos_kernel", ohos_kernel)
    return config


def __set_project_option_value(project_option, down_info, envopts, framework):
    """
    Processes project options into key-value pairs.
    """
    ohos_version, ohos_kernel = '', ''
    for item in project_option:
        if "=" not in item or item.startswith('platform'):
            continue

        _name, _value = item.split("=", 1)
        # we allow set framework globally, override default board framework
        if _name.strip() == "framework":
            framework = _value.strip()

        if _name.strip() == "ohos_version":
            ohos_version = _value.strip()
            continue

        if _name.strip() == "ohos_kernel":
            ohos_kernel = _value.strip()

        if _name.strip() in down_info.keys():
            down_info.update({_name.strip(): _value.strip()})
            continue

        envopts[_name.strip()] = _value.strip()
    return framework, ohos_version, ohos_kernel


def __init_hpm_project_template(envopts, project_dir):
    """
    Create an HPM template when creating a project using the HPM.
    """
    if 'hpm_project_template' in envopts:
        hpm = hpm_adapter.Hpm(stdout=None, stderr=None)
        hpm.init(dirname=project_dir, template=envopts['hpm_project_template'])


def __add_section_to_config(config, env_prefix, board_id, envopts):
    """
    add section to config
    """
    section = f"env:{env_prefix}"
    config.add_section(section)
    for option, value in envopts.items():
        config.set(section, option, value)
    return section, config


def fill_project_envs(ctx, project_dir, board_ids, project_option, **kwargs):
    # pylint: disable=R0915
    pm = PlatformManager()
    config = ProjectConfig(os.path.join(project_dir, ".deveco", "deveco.ini"), parse_extra=False)
    used_boards, imported_options, imported_partitions, used_platforms = [], {}, {}, []
    for section in config.sections():
        if all([section.startswith("env:"), config.has_option(section, "board")]):
            used_boards.append(config.get(section, "board"))

    if kwargs.get("import_settings"):
        with codecs.open(kwargs.get("import_settings"), "r", encoding="utf8") as fp:
            old_settings = json.loads(fp.read())
        __handle_old_settings(imported_options, imported_partitions, old_settings)

    project_platform = [item for item in project_option if item.startswith('platform')]
    for id_ in board_ids:
        down_info = DownloadInfo()
        framework = None
        board_config = __get_board_config(kwargs.get("import_settings"), id_, pm, project_platform)
        platform = PlatformFactory.newPlatform(board_config["platform"])
        board = platform.get_boards(id_)
        envopts = {"platform": board_config["platform"], "board": id_}

        if id_ in used_boards and kwargs.get("env_prefix") == "":
            continue
        frameworks = board_config.get("frameworks")
        if frameworks:
            framework = list(frameworks)[0]['name']
        framework, ohos_version, ohos_kernel = __set_project_option_value(project_option, down_info, envopts, framework)
        config = __set_global_options_for_env(framework, ohos_version, ohos_kernel, down_info, config)
        if id_ in imported_options:
            for k, v in imported_options[id_].items():
                envopts[k] = v

        __init_hpm_project_template(envopts, project_dir)
        __add_upload_port_protocol(board, envopts)
        repo_version = __get_repo_ohos_version(project_dir, ohos_version)
        __update_partition_types(board, framework, envopts)
        __add_upload_partitions_to_envopts(envopts, imported_partitions, id_, board, kwargs.get("env_prefix") or id_)
        __add_partitions_profile(board, framework, envopts, repo_version)
        output_bin = __get_version_bin(board, framework, envopts, repo_version)

        section, config = __add_section_to_config(config, kwargs.get("env_prefix") or id_, id_, envopts)
        config = __add_upload_options(board, config, kwargs.get("env_prefix") or id_ , id_, output_bin)
        config = __add_partition_section_by_imported(imported_partitions, id_, config)
        config.save()
        used_platforms.append(board_config["platform"])
    if kwargs.get("force_download") and used_platforms:
        _install_dependent_platforms(ctx, used_platforms)


def _install_dependent_platforms(ctx, platforms):
    installed_platforms = [p["name"] for p in PlatformManager().get_installed()]
    if set(platforms) <= set(installed_platforms):
        return
    ctx.invoke(
        cli_platform_install, platforms=list(set(platforms) - set(installed_platforms))
    )


def _to_hex_str(str_value):
    # Partition addr and size option of v1.x only support format like: 0, 3K, 3M, 0x300000
    if str_value is not None:
        str_value = str_value.strip()
        if str_value.lower().endswith('k'):
            return hex(int(str_value[:-1]) * 1024)
        if str_value.lower().endswith('m'):
            return hex(int(str_value[:-1]) * 1024 * 1024)
        if str_value.startswith('0x'):
            return str_value
        if str_value[-1].isdigit():
            return hex(int(str_value))
    return str_value


def __get_v1_settings_boards(prefer_file):
    boards = []
    with codecs.open(prefer_file, "r", encoding="utf8") as fp:
        old_settings = json.loads(fp.read())
    pm = PlatformManager()
    for cfg in old_settings.get('configList', []):
        board = cfg.get('base', {}).get('board', '')
        try:
            pm.board_config(board)
        except exception.UnknownBoard:
            continue
        except exception.PlatformioException:
            continue
        except Exception as e:
            raise RuntimeError(f"Unknown error when getting config: {board}") from e
        boards.append(board)
    return boards


def __get_repo_ohos_version(project_dir, ohos_version):
    xml_path = os.path.join(project_dir, '.repo', 'manifests', 'default.xml')
    repo_version = ''
    if os.path.exists(xml_path):
        repo_version = handle_parse_data(xml_path)

    if not repo_version:
        repo_version = ohos_version
        split_list = ohos_version.split('.')
        if len(split_list) >= 2:
            repo_version = '.'.join(split_list[:2])

    return repo_version


def handle_parse_data(xml_path):
    try:
        tree = xml.parse(xml_path, parser=xml.XMLParser(encoding="iso-8859-5"))
        root = tree.getroot()
        for default in root.findall('default'):
            repo_version = handle_get_version(default)
            if repo_version:
                return repo_version
    except OSError:
        pass
    except ValueError:
        pass
    except Exception as e:
        UnknownError(e)

    return ''


def handle_get_version(default):
    revision = default.get('revision')
    if revision:
        vision = os.path.basename(revision)
        pattern = r'\d{1,3}\.\d{1,3}\.{0,1}\d{0,3}'
        vision_list = re.findall(pattern, vision)
        if vision_list:
            split_list = vision_list[0].split('.')
            if len(split_list) >= 2:
                return '.'.join(split_list[:2])

    return ''


def __update_partition_types(board, framework, envopts):
    if 'upload' in board.manifest and 'partition_types' not in board.manifest['upload'] \
                                    and 'framework_partition' in board.manifest['upload']:
        framework_partition = board.manifest['upload']['framework_partition']
        partitions = {}
        if framework in framework_partition:
            partitions = framework_partition.get('framework', {}).get('partitions', {})
        elif 'hpm_project_base_package' in envopts:
            partitions = framework_partition.get(envopts['hpm_project_base_package'], {}).get('partitions', {})
        elif 'board_frameworks.hb.build.product' in envopts:
            partitions = framework_partition.get(envopts['board_frameworks.hb.build.product'], {}).get('partitions', {})

        board.manifest['upload']['partition_types'] = partitions


def __add_partitions_profile(board, framework, envopts, repo_version):
    if 'upload' in board.manifest and 'partitions_profile' in board.manifest['upload']:
        partitions_profile = board.manifest['upload']['partitions_profile']
        profile = ''
        loader_bin = ''
        if framework in partitions_profile:
            framework_profile = partitions_profile.get(framework, {})
            profile = framework_profile.get('profile_version', {}).get(repo_version, '') or \
                        framework_profile.get('profile', '')
            loader_bin = partitions_profile.get(framework, {}).get('loader_bin', '')
        elif 'hpm_project_base_package' in envopts:
            profile = partitions_profile.get(envopts['hpm_project_base_package'], {}).get('profile', '')
            loader_bin = partitions_profile.get(envopts['hpm_project_base_package'], {}).get('loader_bin', '')
        elif 'board_frameworks.hb.build.product' in envopts:
            product_profile = partitions_profile.get(envopts['board_frameworks.hb.build.product'], {})
            profile = product_profile.get('profile_version', {}).get(repo_version, '') or \
                        product_profile.get('profile', '')
            loader_bin = partitions_profile.get(envopts['board_frameworks.hb.build.product'], {}).get('loader_bin', '')

        if loader_bin:
            envopts['upload_loader_bin'] = loader_bin

        if profile:
            envopts['upload_partitions_profile'] = profile
            envopts['use_partitions_profile'] = True


def __get_version_bin(board, framework, envopts, repo_version):
    output_bin = {}
    if 'upload' in board.manifest and 'framework_partition' in board.manifest['upload']:
        version_bin = {}
        framework_partition = board.manifest['upload']['framework_partition']
        if framework in framework_partition:
            version_bin = framework_partition.get(framework, {}).get('output_bin_version', {})
        elif 'board_frameworks.hb.build.product' in envopts:
            version_bin = framework_partition.get(
                envopts['board_frameworks.hb.build.product'], {}).get('output_bin_version', {})

        if version_bin:
            output_bin = version_bin.get(repo_version, {})

    return output_bin


def __resolve_bin_path(bin_path, board):
    return bin_path.replace('${Base:board}', board)


def __echo_path_info(silent, project_dir):
    if not silent:
        if project_dir == os.getcwd():
            click.secho("\nThe current working directory", fg="yellow", nl=False)
            click.secho(" %s " % project_dir, fg="cyan", nl=False)
            click.secho("will be used for the project.", fg="yellow")
            click.echo("")

        click.echo(
            "The next files have been created in %s"
            % click.style(os.path.join(project_dir, ".deveco"), fg="cyan")
        )

        click.echo(
            "%s - Project Configuration File" % click.style("deveco.ini", fg="cyan")
        )


def __echo_success(silent, ide, is_new_project):
    if silent:
        return
    if ide:
        click.secho(
            "\nProject has been successfully %s including configuration files "
            "for `%s` IDE." % ("initialized" if is_new_project else "updated", ide),
            fg="green",
        )
    else:
        click.secho(
            "\nProject has been successfully %s! Useful commands:\n"
            "`hos run` - process/build project from the current directory\n"
            "`hos run --target upload` or `hos run -t upload` "
            "- upload firmware to a target\n"
            "`hos run --target clean` - clean project (remove compiled files)"
            "\n`hos run --help` - additional information"
            % ("initialized" if is_new_project else "updated"),
            fg="green",
        )


@cli.command("tasks", short_help="Show tasks")
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=True, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--json-output", is_flag=True)
def project_tasks(project_dir, json_output):
    if not is_platformio_project(project_dir):
        raise NotPlatformIOProjectError(project_dir)
    with fs.cd(project_dir):
        config = ProjectConfig.get_instance()

        task_tree = []

        if config.get("env", 'download_type') == "repo":
            profile_env = {'type': 'group',
                           'name': 'Chip Solution',
                           'title': 'Chip Solution',
                           'icon': 'chip',
                           'items': []}

            profile_env['items'].extend(profile_tasks(project_dir,
                                                      files=[["bundle.json", "json"],
                                                             ["README.md", "markdown"],
                                                             [config.get("env", "profile_pdf"), "file"]]))
            task_tree.append(profile_env)

        for env in config.envs():
            platform_name = config.get(f'env:{env}', 'platform')
            platform = PlatformFactory.newPlatform(platform_name)
            board_name = config.get(f'env:{env}', 'board')
            env_group = {'type': 'group',
                         'name': env,
                         'title': f'Environment {env}',
                         'icon': 'env',
                         'product': config.get(f'env:{env}', 'board_frameworks.hb.build.product', ''),
                         'items': []}

            for operation in platform.tasks(board_name, project_dir, env):
                env_group['items'].append(operation)
            task_tree.append(env_group)

        if json_output:
            return click.echo(json.dumps(task_tree))
        return click.echo(json.dumps(task_tree, indent=2))


@cli.command("upgrade", short_help="Upgrade project ini file")
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
def upgrade_project_ini(project_dir):
    ini_file = os.path.join(project_dir, ".deveco", "deveco.ini")
    if os.path.exists(ini_file):
        project_file_convert(ini_file)


@cli.command("get_config_item", short_help="get the default config item of a board")
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
    required=True
)
@click.option("--framework", "-f", help="the framework", required=True)
@click.option("--platform", "-p", help="the board platform", required=True)
@click.option("--board-id", "-b", help="the board name", required=True)
@click.option("--product", "-pd", help="the product name", required=True)
@click.option("--env-name", "-e", help="the env name", required=True)
@click.option("--ohos-version", "-v", help="the ohos version", default='')
@click.option("--ohos-kernel", "-k", help="the ohos kernel", required=True)
@click.option("--json-output", is_flag=True)
def get_config_item(**kwargs):
    project_dir = kwargs.get("project_dir")
    framework = kwargs.get("framework")
    platform = kwargs.get("platform")
    board_id = kwargs.get("board_id")
    product = kwargs.get("product")
    env_name = kwargs.get("env_name")
    ohos_version = kwargs.get("ohos_version")
    ohos_kernel = kwargs.get("ohos_kernel")
    json_output = kwargs.get("json_output")

    envopts = { "platform": platform, "board": board_id, "framework": [framework], "ohos_kernel": ohos_kernel }
    if framework == 'hpm':
        envopts['hpm_project_base_package'] = product
    else:
        envopts['board_frameworks.hb.build.product'] = product

    new_platform = PlatformFactory.newPlatform(platform)
    board = new_platform.get_boards(board_id)

    if 'upload' in board.manifest:
        envopts['upload_port'] = ''
        protocol = board.manifest.get('upload', {}).get('protocol', '')
        if protocol:
            envopts['upload_protocol'] = protocol

    _set_suite_burn_enable(board, project_dir, framework, product, envopts)

    repo_version = __get_repo_ohos_version(project_dir, ohos_version)

    __update_partition_types(board, framework, envopts)

    if 'upload_partitions' not in envopts:
        envopts['upload_partitions'] = []

    if 'upload' in board.manifest and 'partition_types' in board.manifest['upload']:
        for k in board.manifest['upload']['partition_types']:
            envopts['upload_partitions'].append(f"partition:{env_name}_{k}")
    if len(envopts['upload_partitions']) == 0:
        del envopts['upload_partitions']

    __add_partitions_profile(board, framework, envopts, repo_version)

    output_bin = __get_version_bin(board, framework, envopts, repo_version)

    options = ProjectOptions["env.default_options"].default
    for option in options:
        _name, _value = option.split("=", 1)
        if _name.strip() not in envopts:
            envopts[_name.strip()] = _value.strip()

    env_items = [(s, envopts[s]) for s in envopts]
    result_itmes = [(f'env:{env_name}', (env_items))]

    section_items = handle_upload_partitions(board, env_name, board_id, platform, output_bin)

    for k, v in section_items.items():
        result_itmes.append((k, [(s, v[s]) for s in v]))

    if json_output:
        click.echo(json.dumps(result_itmes))
    else:
        click.echo(result_itmes)


def handle_upload_partitions(board, env_name, board_id, platform, output_bin):
    section_items = {}
    if 'upload' in board.manifest and 'partition_types' in board.manifest['upload']:
        for k in board.manifest['upload']['partition_types']:
            section = {"partition_env": env_name, "partition_type": k, "partition_board": board_id,
                       "partition_platform": platform}
            if output_bin and k in output_bin:
                section["partition_bin"] = output_bin.get(k, '')
            section_items[f"partition:{env_name}_{k}"] = section
    return section_items


def _set_suite_burn_enable(board, project_dir, framework, product, envopts):
    if 'upload' in board.manifest and 'suite_tool' in board.manifest['upload']:
        envopts['suite_burn_enable'] = board.manifest.get('upload', {}).get('suite_tool', False)
        config = ProjectConfig(os.path.join(project_dir, ".deveco", "deveco.ini"), parse_extra=False)
        for section in config.sections():
            config_product = config.get(section, "hpm_project_base_package", "") if framework == 'hpm' else \
                        config.get(section, "board_frameworks.hb.build.product", "")
            cond = [
                section.startswith("env:"),
                config_product == product,
                config.has_option(section, "suite_burn_enable")
            ]
            if all(cond):
                envopts['suite_burn_enable'] = config.get(section, "suite_burn_enable")
                break


def profile_tasks(project_dir, files=None):
    if files is None:
        files = []

    def task(name: str, title: str, icon: str, cmd: List):
        t = {'type': 'task', 'name': name, 'title': title, 'id': f'deveco: {name.lower()} - profile',
             'icon': icon, 'cmd': cmd, 'taskType': 'profile'}
        for k in [k for k, v in t.items() if v is None]:
            t.pop(k)
        return t

    config_task = task("Config", "Configure code repositories of chip solution.", "config", ["DevEco.showHome", '/profileRepoConfig'])
    packing_task = task("Pack", "Packaged chip solutions", "package", ["deveco-device-tool.packChipSolution"])

    profile_task = {'type': 'group',
                    'name': 'Profile',
                    'title': 'Common Files',
                    'icon': 'files',
                    'items': []}

    for file, icon in files:
        if file:
            path = os.path.join(project_dir, ".deveco", "profile", file)
            profile_task['items'].append(
                task(file, path, icon, ["deveco-device-tool.openTextDocument", path])
            )

    return [profile_task, config_task, packing_task]


@cli.command("get_suite_json_config", short_help="get the suite config item of all project")
@click.option(
    "-d",
    "--project-dir",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
    required=True
)
@click.option("--json-output", is_flag=True)
def get_suite_json_config(**kwargs):
    project_dir = kwargs.get("project_dir")
    json_output = kwargs.get("json_output")
    suite_json = get_status_json_config(project_dir)

    all_projects_configs = {}
    for suite in suite_json:
        project_name = suite.get("product")
        file_path = suite.get("project_json_path")
        if project_name and file_path and os.path.exists(file_path):
            project_config_cur = get_suite_config(file_path)
            all_configs = read_suite_json(project_config_cur)
            project_configs = {project_name: all_configs}
            all_projects_configs.update(project_configs)

    if json_output:
        click.echo(json.dumps(all_projects_configs))
    else:
        click.echo(all_projects_configs)


def get_suite_config(file_path):
    current_project_config = {}
    with open(file_path, 'r', encoding='utf-8') as json_file:
        try:
            current_project_config = json.load(json_file)
        except json.JSONDecodeError as e:
            raise Exception(f'{file_path} parsing error!') from e
    return current_project_config
    
    
def get_status_json_config(project_dir):
    status_json_path = os.path.join(project_dir, ".deveco", "status")
    suite_json = []
    for root, _, files in os.walk(status_json_path):
        for file in files:
            file_path = os.path.join(root, file)
            status_json = read_status_json(file_path)
            if status_json:
                suite_json.append(status_json.get("tools", {}).get("suite_tool", {}))
    return suite_json


def read_status_json(file_path):
    with open(file_path, 'r', encoding='utf-8') as json_file:
        try:
            status_json = json.load(json_file)
            if isinstance(status_json, dict):
                return status_json
            else:
                return None
        except json.JSONDecodeError:
            return None


def read_suite_json(project_config_cur):
    all_configs = []
    ui_config = project_config_cur.get('ui_config', {})
    ui_config.update(project_config_cur.get('partitions_config', {}))
    ui_config.update(project_config_cur.get('expansion_config', {}))
    normal_configs = {
        "group": "upload",
		"readonly": False,
		"scope": "burn"
    }
    
    for key, value in ui_config.items():
        ui_config_info = dict(name=key)
        ui_config_info.update(value)
        ui_config_info.update(normal_configs)
        all_configs.append(ui_config_info)

    return all_configs

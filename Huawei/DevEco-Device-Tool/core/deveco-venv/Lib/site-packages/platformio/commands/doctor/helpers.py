import json
import os
import click
from tabulate import tabulate
import re
import subprocess
import sys
import xml.etree.ElementTree as xml
from enum import Enum
from os.path import join, isdir, dirname
from platformio.commands.exception import PlatformioFileNotFound,PlatformioJSONDecodeError,\
    BoardPathError,NoKernelConfigFileError
from platformio.commands.exception import UnknownError


OHOS_V32_REQUIRED_PREBUILT = ['refs/tags/OpenHarmony-v3.2-Beta4', 'refs/tags/OpenHarmony-v3.2-Beta3']


class PrebuiltStatus(Enum):
    SUCCESS = 0
    FAILED = 1
    IGNORE = 2


def read_json_file(input_file):
    if not os.path.isfile(input_file):
        raise PlatformioFileNotFound(input_file)

    with open(input_file, 'rb') as input_f:
        try:
            data = json.load(input_f)
            return data
        except json.JSONDecodeError:
            raise PlatformioJSONDecodeError(input_file)


def get_kernel_config(board_path):
    for kernel in os.listdir(board_path):
        kernel_path = os.path.join(board_path, kernel)

        if os.path.isdir(kernel_path):
            kernel_config = os.path.join(kernel_path, 'config.gni')
            if not os.path.isfile(kernel_config):
                continue
            yield kernel_config, kernel_path


def get_product_json_path(vendor_path, product):
    config_name, config_vendor = product.split('@')
    if os.path.isdir(vendor_path):
        return handle_json_path(vendor_path, config_name, config_vendor)
    return ''


def handle_json_path(vendor_path, config_name, config_vendor):
    for company in os.listdir(vendor_path):
        company_path = os.path.join(vendor_path, company)
        if not os.path.isdir(company_path):
            continue
        for product_dir in os.listdir(company_path):
            product_path = os.path.join(company_path, product_dir)
            config_path = os.path.join(product_path, 'config.json')
            if not os.path.isfile(config_path):
                continue
            info = read_json_file(config_path)
            if config_name == info.get('product_name') and config_vendor == company:
                return config_path
    return ''


def get_kernel_config_file_path(root_path, product):
    config_path = get_product_json_path(join(root_path, 'vendor'), product)
    info = read_json_file(config_path)

    device_company = info.get('device_company')
    board = info.get('board')

    board_path = os.path.join(root_path, 'device', device_company, board)
    # board and soc decoupling feature will add boards directory path here.
    if not os.path.exists(board_path):
        board_path = os.path.join(root_path, 'device', 'board',
                                    device_company, board)

    if not os.path.exists(board_path):
        raise BoardPathError(config_path)

    for kernel_config, _ in get_kernel_config(board_path):
        return kernel_config

    raise NoKernelConfigFileError(config_path)


def show_title(print_range, range_valid_map):
    valid = range_valid_map.get(print_range, False)
    click.echo(f'{print_range} tools are OK:  ', nl=False)
    click.secho(f'{valid}', fg='green' if valid else 'red')


def get_print_list(check_tools, print_range):
    upload_type_keys = ['upload', 'suite_tool']
    print_list = []
    for tool_type in check_tools.keys():
        if print_range == 'Build' and tool_type in upload_type_keys:
            continue
        if print_range == 'Upload' and tool_type not in upload_type_keys:
            continue
        for tool in check_tools[tool_type].keys():
            print_list.append((
                click.style(tool, fg='cyan'),
                tool_type,
                click.style('valid', fg='green') \
                    if check_tools[tool_type][tool]['valid'] else click.style('invalid', fg='red'),

            ))
    return print_list


def print_tools_list(tool_status, print_range):
    range_valid_map = {
        'All': tool_status.get('all_valid'),
        'Build': tool_status.get('build_valid'),
        'Upload': tool_status.get('upload_valid'),
    }
    click.echo('============================================')
    show_title(print_range, range_valid_map)
    click.echo('============================================')
    click.echo(
        tabulate(
            get_print_list(tool_status.get('tools'), print_range),
            headers=["name", "type", "status"],
        )
    )


def search_compiler_dir(package):
    for root, _, files in os.walk(package, followlinks=True):
        if not root.endswith('bin'):
            continue
        for file in files:
            res = re.match(r'(.+)gcc', file)
            if res:
                return root
    return None


def check_compiler_executable(bin_dir, compiler_name):
    if not isdir(bin_dir):
        return False
    bin_file = join(bin_dir, f'{compiler_name}')
    try:
        subprocess.check_call(
            [bin_file, '-v'],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=10)
        return True
    except subprocess.CalledProcessError:
        return False
    except subprocess.TimeoutExpired:
        return False
    except OSError:
        return False


def check_pip_deb_pkg(tool, tool_type):
    type_map = {'pip': ['python3', '-m', 'pip', 'show'], 'deb': ['dpkg', '-s']}
    if tool_type in type_map.keys():
        # do not use pip in venv
        sys_path = os.environ.get('PATH', '').split(os.pathsep)
        bin_path = dirname(sys.executable)
        sys_path = [path for path in sys_path if path != bin_path]
        os.environ['PATH'] = os.pathsep.join(sys_path)
        try:
            subprocess.check_call(
                type_map[tool_type] + [tool],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=10)
            return True
        except subprocess.CalledProcessError:
            return False
        except subprocess.TimeoutExpired:
            return False
        except OSError:
            return False
    return False


def get_repo_revision(project_dir):
    xml_path = os.path.realpath(os.path.join(project_dir, '.repo', 'manifests', 'default.xml'))
    if not os.path.exists(xml_path):
        return ''
    try:
        tree = xml.parse(xml_path, parser=xml.XMLParser(encoding="iso-8859-5"))
        root = tree.getroot()
        for item in root.findall('default'):
            if item.get('revision'):
                return item.get('revision')
    except OSError:
        pass
    except ValueError:
        pass
    except Exception as e:
        UnknownError(e)
    return ''


def get_cache_prebuilts_status(project_dir):
    prebuilts_status_flile = os.path.realpath(os.path.join(project_dir, '.deveco', 'status', 'prebuilts'))
    try:
        return PrebuiltStatus(json.load(open(prebuilts_status_flile, 'r')).get('status', PrebuiltStatus.FAILED))
    except (FileNotFoundError, ValueError):
        return PrebuiltStatus.FAILED


def is_standard_product(project_dir, product):
    config_path = get_product_json_path(join(project_dir, 'vendor'), product)
    try:
        info = read_json_file(config_path)
        return info.get('type') == 'standard'
    except (PlatformioFileNotFound, PlatformioJSONDecodeError):
        return False
    except Exception as e:
        UnknownError(e)
        return False


def update_prebuilts_download_status(project_dir, status, config, env):
    if 'hpm' in config.get('env:' + env, 'framework', []):
        return
    ohos_version = config.get('env', 'ohos_version', '')
    if not ohos_version or re.match( r'^[12]\.', ohos_version):
        return
    cache_status = get_cache_prebuilts_status(project_dir)
    if cache_status == PrebuiltStatus.SUCCESS:
        return
    ohos_python = join(project_dir, 'prebuilts', 'python')
    if not os.path.exists(ohos_python) and cache_status != PrebuiltStatus.IGNORE:
        status.update({
            'prebuilt_ok': False
        })
    # special treatment for v3.2-beta4
    repo_revision = get_repo_revision(project_dir)
    product_hb = config.get('env:' + env, 'board_frameworks.hb.build.product', '')
    if not product_hb or repo_revision not in OHOS_V32_REQUIRED_PREBUILT:
        return
    if is_standard_product(project_dir, product_hb) and cache_status != PrebuiltStatus.IGNORE:
        status.update({
            'prebuilt_ok': False
        })

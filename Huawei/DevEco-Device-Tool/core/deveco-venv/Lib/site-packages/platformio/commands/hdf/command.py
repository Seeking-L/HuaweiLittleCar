import json
import click
import os
import hdf_adapter # pylint: disable=import-error
import hb_adapter  # pylint: disable=import-error
import collections
import semantic_version

from platformio.commands.dotting.helpers import TraceOperate, HdfTrace
from platformio.commands.home.rpc.handlers.project import ProjectRPC
from platformio.commands.exception import HDFRunTimeError,InvalidConfError

SUPPORTED_PRODUCTS = {
    'ipcamera_hispark_taurus@hisilicon': dict(min_required_ver='0.0.0'),
    'ipcamera_hispark_taurus_linux@hisilicon': dict(min_required_ver='0.0.0'),
    'hispark_taurus_standard@hisilicon': dict(min_required_ver='0.0.0', os_type='standard'),
    'rk3568@hihope': dict(min_required_ver='0.0.0', os_type='standard'),
}

SUPPORTED_DOMAIN_MODULES = ['sensor', 'input', 'display', 'audio']

DriverInfo = collections.namedtuple('DriverInfo',
    ['vendor_name', 'board_name', 'kernel_name', 'module_name', 'device_name',
    'driver_name', 'runmode'])


@click.group(short_help="Hardware Driver Foundation")
def cli():
    pass


@cli.command("get-driver-list", short_help="Get the driver list")
@click.option(
    "--root-path",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--product", required=True)
def hdf_get_driver_list(root_path, product):
    features = get_features(root_path)
    if not features.get('validity', {}).get('valid', False):
        err_msg = 'HDF template function is not supported'
        click.echo(json.dumps({
            'success': False,
            'data': err_msg
        }, indent=4))
        HDFRunTimeError(err_msg)
        return

    try:
        hdf = hdf_adapter.Hdf(root_path)
        driver_list = []
        product_name = handle_hispark_taurus_product(product.split('@')[0])
        general_drivers = get_general_driver_list(root_path, product_name, hdf)
        driver_list.extend(general_drivers)

        support_domain = features.get('supportDomain', False)
        if support_domain:
            domain_drivers = get_domain_driver_list(root_path, product_name, hdf)
            driver_list.extend(domain_drivers)

        click.echo(json.dumps({
            'success': True,
            'data': driver_list
        }, indent=4))
    except RuntimeError as e:
        err_msg = str(e) if str(e) else 'Failed to get driver list'
        click.echo(json.dumps({
            'success': False,
            'data': err_msg
        }, indent=4))
        HDFRunTimeError(err_msg)

@cli.command("add-driver", short_help="Add driver")
@click.option(
    "--root-path",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--vendor-name", required=True)
@click.option("--board-name", required=True)
@click.option("--kernel-name", required=True)
@click.option("--module-name", required=True)
@click.option("--device-name")
@click.option("--driver-name", required=True)
@click.option("--runmode", required=True)
@click.option('--specific', is_flag=True)
def hdf_add_driver(**kwargs):
    root_path = kwargs.get('root_path')
    vendor_name = kwargs.get('vendor_name')
    board_name = kwargs.get('board_name')
    kernel_name = kwargs.get('kernel_name')
    module_name = kwargs.get('module_name')
    device_name = kwargs.get('device_name')
    driver_name = kwargs.get('driver_name')
    run_mode = kwargs.get('runmode')
    specific = kwargs.get('specific')

    try:
        driver_info: DriverInfo = DriverInfo(
            vendor_name, board_name, kernel_name, module_name, device_name, driver_name, run_mode)
        hdf = hdf_adapter.Hdf(root_path)
        if not specific:
            data = hdf.add_general_driver(driver_info)
        else:
            data = hdf.add_domain_driver(driver_info)

        click.echo(json.dumps({
            'success': "error" not in data,
            "data": data if "error" in data else json.loads(data.replace("\'", '\"'))
        }, indent=4))
        if "error" in data:
            TraceOperate(HdfTrace).operate("Hdf", "add", board_name, False)
        else:
            TraceOperate(HdfTrace).operate("Hdf", "add", board_name, True)
    except RuntimeError as e:
        err_msg = str(e) if str(e) else 'Failed to add driver'
        click.echo(json.dumps({
            'success': False,
            'data': err_msg
        }, indent=4))
        HDFRunTimeError(err_msg)


@cli.command("del-general-module", short_help="Delete general module")
@click.option(
    "--root-path",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--module-name", required=True)
def hdf_delete_module(root_path, module_name):
    try:
        data = hdf_adapter.Hdf(root_path).delete_module(module_name)
        click.echo(json.dumps({
            'success': "error" not in data,
            'data': data
        }, indent=4))
    except RuntimeError as e:
        err_msg = str(e) if str(e) else 'Failed to delete module'
        click.echo(json.dumps({
            'success': False,
            'data': err_msg
        }, indent=4))
        HDFRunTimeError(err_msg)


@cli.command("del-specific-driver", short_help="Delete specific module driver")
@click.option(
    "--root-path",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--board-name", required=True)
@click.option("--kernel-name", required=True)
@click.option("--module-name", required=True)
@click.option("--device-name", required=True)
@click.option("--driver-name", required=True)
def hdf_delete_module(**kwargs):
    root_path = kwargs.get('root_path')
    try:
        data = hdf_adapter.Hdf(root_path).delete_domain_driver(**kwargs)
        click.echo(json.dumps({
            'success': "error" not in data,
            'data': data
        }, indent=4))
    except RuntimeError as e:
        err_msg = str(e) if str(e) else 'Failed to delete specific module driver'
        click.echo(json.dumps({
            'success': False,
            'data': err_msg
        }, indent=4))
        HDFRunTimeError(err_msg)


@cli.command("current-product", short_help="Get current product info in the project")
@click.option(
    "--project-dir",
    "-d",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
@click.option("--product", required=True)
def hdf_current_product(project_dir, product):
    product_info = {"productName": product, "vendor": "", "board": "", "kernel": "", "type": "",
                    "isSupported": False}
    product_data = get_product_data(project_dir, product)
    if not product_data:
        click.echo(json.dumps(product_info))
        return

    product_info["board"] = product_data.get('name')
    if product_info["board"].startswith("ipcamera_"):
        product_info["board"] = product_info["board"].replace("ipcamera_", "", 1)
    product_info["vendor"] = product_data.get('company')
    product_info["kernel"] = product_data.get('kernel') if product_data.get('kernel') else 'linux'
    product_info["type"] = product_data.get('type')
    if product in SUPPORTED_PRODUCTS.keys():
        product_info["isSupported"] = True
    click.echo(json.dumps(product_info))


@cli.command("get-products", short_help="Get products in the project")
@click.option(
    "--project-dir",
    "-d",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
def hdf_get_products(project_dir):
    def is_supported_product(product, hdf_sem_version):
        if product not in SUPPORTED_PRODUCTS.keys():
            return False
        required_version = SUPPORTED_PRODUCTS.get(product, {}).get('min_required_ver', '0.0.0')
        return hdf_sem_version >= semantic_version.Version(required_version)

    try:
        hdf_sem_version = semantic_version.Version(hdf_adapter.Hdf(project_dir).get_version())
    except (RuntimeError, ValueError):
        hdf_sem_version = semantic_version.Version('0.0.0')

    result = {"products": [], "default": ""}

    features = get_features(project_dir)
    if not features.get('validity', {}).get('valid', False):
        click.echo(json.dumps(result))
        return
    try:
        product_name_list = ProjectRPC.get_env_products([project_dir])
        for product in product_name_list:
            if is_supported_product(product, hdf_sem_version):
                result["products"].append(product)

        if result["products"]:
            result["default"] = result["products"][-1]
        TraceOperate(HdfTrace).operate("Hdf", "index")
        click.echo(json.dumps(result))
    except Exception:
        InvalidConfError(json.dumps(result))


@cli.command("get-module-devices", short_help="Get the device list of specific modules")
@click.option(
    "--root-path",
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
def hdf_get_module_devices(root_path):
    devices = {}
    adapter = hdf_adapter.Hdf(root_path)
    for domain in SUPPORTED_DOMAIN_MODULES:
        try:
            data = adapter.get_model_device_list(domain)
            if "error" not in data:
                devices.update({domain: json.loads(data.replace("\'", '\"'))})
        except RuntimeError:
            pass
    click.echo(json.dumps(dict(domains=SUPPORTED_DOMAIN_MODULES, devices=devices), indent=4))


@cli.command("get-features", short_help="Get the support features")
@click.option(
    "--root-path",
      default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
def hdf_get_features(root_path):
    click.echo(json.dumps(get_features(root_path), indent=4))


def get_features(root_path):
    features = {
        'validity': {'valid': True},
        'supportDomain': False,
    }
    hdf = hdf_adapter.Hdf(root_path)
    if hdf.server_path_version == hdf_adapter.HdfPathVersion.VERSION_INVALID:
        features.update({
            'validity': {'valid': False, 'reason': 'hdfNotFound'}
        })
        return features
    version = hdf.get_version()
    try:
        specver = semantic_version.Version(version)
        if specver >= semantic_version.Version('0.2.0'):
            features.update({'supportDomain': True, 'validity': {'valid': True}})
    except (RuntimeError, ValueError):
        features.update({'supportDomain': False})
        if hdf.server_path_version == hdf_adapter.HdfPathVersion.VERSION_2:
            # 3.2 beta1 ~ 3.2 beta3, hdf has many bugs
            features.update({
                'validity': {'valid': False, 'reason': 'hdfServerBugs'}
            })
        else:
            features.update({'validity': {'valid': True}})
    return features


def get_product_data(project_dir, product):
    hdf_tool_path = hdf_adapter.Hdf(project_dir).server_path
    product_name = product.split('@')[0] if '@' in product else product
    if not (os.path.isfile(hdf_tool_path) and product_name):
        return {}
    hb = hb_adapter.Hb(project_dir)
    products = hb.list_products_detail()
    for vendor in products.get('products', []):
        for p in vendor.get('product', []):
            if p.get('name') == product_name:
                return p
    return {}


def get_general_driver_list(root_path, product_name, hdf):
    general_list = hdf.get_general_driver_list()
    general_list = general_list.replace("\'", '\"')
    general_driver_json = json.loads(general_list)
    driver_list = []
    for item in general_driver_json:
        mod = list(item.keys())[0]
        info = item.get(mod, {})
        if not info:
            continue
        hcs = info.get('devices_info.hcs', '')
        file_parts = hcs.split('/')
        item_product_name = file_parts[2] if len(file_parts) > 1 else ''
        if product_name != item_product_name:
            continue
        drivers_files = [info.get('driver_file_path')] if info.get('driver_file_path') else []
        dotconfig = info.get(f'{mod}_dot_configs', [])
        driver_info = dict(
            module=mod,
            type='general',
            configs=dict(
                buildgn=get_realpath(root_path, info.get('BUILD.gn', '')),
                makefile=get_realpath(root_path, info.get('Makefile', '')),
                kconfig=get_realpath(root_path, info.get('Kconfig', '')),
                hcs=get_realpath(root_path, hcs),
                dotconfig=get_valid_file_list(root_path, dotconfig),
            ),
            drivers={
                mod: {
                    mod: get_valid_file_list(root_path, drivers_files)
                }
            }
        )
        driver_list.append(driver_info)
    return driver_list


def get_domain_driver_list(root_path, product_name, hdf):
    driver_list = []
    suffix = ''
    for product, info in SUPPORTED_PRODUCTS.items():
        if product.split('@')[0] == product_name:
            # key for L2 product only supports kernel runmode
            suffix = '_kernel' if info.get('os_type', '') == 'standard' else ''
            break
    for mod in SUPPORTED_DOMAIN_MODULES:
        domain_list = hdf.get_domain_driver_list(mod)
        domain_driver_json = json.loads(domain_list)
        info = domain_driver_json.get(f'{product_name}{suffix}', {})
        if not info:
            continue
        module_config = info.get('module_level_config', {})
        dotconfig = module_config.get(f'{mod}_dot_configs', [])
        driver_info = dict(
            module=mod,
            type='specific',
            configs=dict(
                buildgn=get_realpath(root_path, module_config.get('BUILD.gn', '')),
                makefile=get_realpath(root_path, module_config.get('Makefile', '')),
                kconfig=get_realpath(root_path, module_config.get('Kconfig', '')),
                hcs=get_realpath(root_path, module_config.get('devices_info.hcs', '')),
                dotconfig=get_valid_file_list(root_path, dotconfig),
            ),
            drivers=get_valid_domain_drivers(root_path, info.get('driver_file_list', {}))
        )
        driver_list.append(driver_info)
    return driver_list


def handle_hispark_taurus_product(product_name):
    if product_name in ['ipcamera_hispark_taurus', 'ipcamera_hispark_taurus_linux']:
        product_name = product_name.replace('ipcamera_', '')
    return product_name


def get_realpath(root_path, file_path):
    if not os.path.isabs(file_path):
        file_path = os.path.realpath(os.path.join(root_path, file_path))
    return file_path if os.path.isfile(file_path) else ''


def get_valid_file_list(root_path, file_list):
    return list(filter(None, [get_realpath(root_path, file) for file in file_list]))


def get_valid_domain_drivers(root_path, drivers):
    for mod, mod_info in drivers.items():
        for device, srcs in mod_info.items():
            drivers.get(mod).update(
                {f'{device}': get_valid_file_list(root_path, srcs)})
    return drivers

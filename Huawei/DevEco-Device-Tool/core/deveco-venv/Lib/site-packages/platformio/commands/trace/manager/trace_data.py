import os
from os.path import join, isfile
from platformio.helpers import get_config_json_path
from platformio import fs
from platformio.compat import dump_json_to_unicode
from platformio.commands.trace.manager.trace_help import TraceHelper

IDLE_TYPE = 4
NO_IDLE_TYPE = 2
IDLE_CORE = "IdleCore000"


class TraceDataManager():
    def __init__(self):
        self.storageColor = {'taskColorMap': {
                                'baseColorId': 0,
                                'baseColorCount': 1},
                             'eventColorMap':{
                                 'baseColor': "#008000"}
                             }

        self.storageColor_tmp = {'taskColorMap': {
                                    'baseColorId': 0,
                                    'baseColorCount': 1},
                                'eventColorMap':{
                                    'baseColor': "#008000"}
                                }

        self.path = join(get_config_json_path(), "color.json")

    def get_color_config(self):
        if isfile(self.path):
            try:
                file_data = fs.load_json(self.path)
                self.storageColor = file_data
                self.storageColor_tmp = file_data
            except Exception:  # pylint: disable=broad-except
                os.remove(self.path)

    def save_color_config(self):
        if self.storageColor != self.storageColor_tmp:
            flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
            with os.fdopen(os.open(self.path, flags, 0o640), "w") as fp:
                fp.write(dump_json_to_unicode(self.storageColor))

    def convert_timeline_row_data(self, items): # pylint: disable=too-many-locals
        if not items or len(items) == 0:
            return {}
        task_datas = []
        xData = []
        timeline_datas = []
        taskId = 0
        hasIdle = False
        minTime = 0
        maxTime = 0

        self.get_color_config()

        th = TraceHelper(tcm=self.storageColor['taskColorMap'])
        for item in items:
            isExists = False
            for i, v in enumerate(task_datas):
                is_task_exists = all([
                    v['taskname'] == item['taskname'],
                    v['addr'] == item['ActorAddr'] or (item['taskname'] == IDLE_CORE and hasIdle)
                ])
                if is_task_exists:
                    isExists = True
                    taskId = i
            if not isExists:
                task_data = self.assemble_task_data(item)
                task_datas.append(task_data)

                taskId = len(task_datas) - 1
                colors = th.get_task_color(IDLE_TYPE if item['taskname'] == IDLE_CORE else NO_IDLE_TYPE, \
                                                item['ActorAddr'] + item['taskname'])
                reItem = {
                    'content': item['taskname'], 'colors': colors,
                    'type': item['type'], 'show': True,
                    'addr': item['ActorAddr']
                }
                xData.append(reItem)

                if item['taskname'] == IDLE_CORE and not hasIdle:
                    hasIdle = True

            if item['starttime'] != -1 and  item['endtime'] != -1:
                timeline_data = self.assemble_timeline_data(taskId, item)
                timeline_datas.append(timeline_data)
                if minTime == 0 or timeline_data['value'][1] < float(minTime) * 1000000:
                    minTime = item['starttime']
                if maxTime == 0 or timeline_data['value'][2] > float(maxTime) * 1000000:
                    maxTime = item['endtime']

        self.save_color_config()

        all_result = {
            'xData': xData,
            'timeLineData': timeline_datas,
            'minTime': minTime,
            'maxTime': maxTime
        }
        return all_result

    def assemble_task_data(self, item): # pylint: disable=no-self-use
        task_data = {
            'id' : 0,
            'type': item['type'],
            'taskname': item['taskname'],
            'addr': item['ActorAddr']
        }
        return task_data

    def assemble_timeline_data(self, taskId, item): # pylint: disable=no-self-use
        timeline_data = {'value' : [] }
        timeline_data['value'].append(taskId)
        timeline_data['value'].append(int(float(item['starttime']) * 1000000))
        timeline_data['value'].append(int(float(item['endtime']) * 1000000))
        timeline_data['value'].append(int(float(item['endtime']) - float(item['starttime'])))
        timeline_data['value'].append(int(item['cpuid']))
        timeline_data['value'].append(item['type'])
        timeline_data['value'].append(item['timestamp'])
        return timeline_data

    def convert_timeline_events_data(self, items):
        if not items or len(items) == 0:
            return {}
        isStart = True
        event_childrens = []
        event_datas = []
        taskname = ""
        root = 0

        self.get_color_config()

        th = TraceHelper(ecm=self.storageColor['eventColorMap'])
        for item in items:
            if item['EventText'] and item['Actor'] != "Interrupt":
                colors = th.get_event_color(NO_IDLE_TYPE, item['code'])
                if isStart:
                    children_item = self.assemble_children_item(item, colors)
                    event_childrens.append(children_item)

                    root = int(float(item['timestamp']) * 1000000)
                    event_item = self.assemble_event_item(event_childrens, root, item['Actor'])
                    event_datas.append(event_item)

                    isStart = False
                elif taskname == item['Actor']:
                    children_item = self.assemble_children_item(item, colors)
                    event_childrens.append(children_item)
                    root = int(float(item['timestamp']) * 1000000)
                else:
                    event_childrens = []
                    children_item = self.assemble_children_item(item, colors)
                    event_childrens.append(children_item)

                    event_item = self.assemble_event_item(event_childrens, root, item['Actor'])
                    event_datas.append(event_item)
                    root = int(float(item['timestamp']) * 1000000)

        self.save_color_config()

        return event_datas

    def assemble_children_item(self, item, colors): # pylint: disable=no-self-use
        children_item = {
            'name': item['EventText'],
            'collapsed': True,
            'label': { 'borderColor': colors }
        }
        return children_item

    def assemble_event_item(self, childrens, root, name): # pylint: disable=no-self-use
        event_item = {
            'name': "",
            'children': childrens,
            'starttime': root,
            'actor': name
        }
        return event_item

    def convert_event_table_data(self, items):
        trace_event_data = []

        self.get_color_config()

        th = TraceHelper(tcm=self.storageColor['taskColorMap'], ecm=self.storageColor['eventColorMap'])
        for item in items:
            colors = th.get_task_color(IDLE_TYPE if item['Actor'] == IDLE_CORE else NO_IDLE_TYPE,
                                       item['ActorAddr'] + item['Actor'])
            event_item = {
                'Timestamp': item['timestamp'],
                'Actor': item['Actor'],
                'EventText': item['EventText'],
                'actorType': "color",
                'actorColor': colors,
                'eventTextType': "color",
                'eventType': item['eventType'],
                'eventColor': th.get_event_color(NO_IDLE_TYPE, item['code']),
                'ActorAddr': item['ActorAddr'],
                'ActorPrio': item['ActorPrio'],
                'eventCount': item['eventCount'],
                'cpuId': item['cpuid'],
                'identity': item['identity']
            }
            trace_event_data.append(event_item)

        self.save_color_config()

        return trace_event_data

    def assemble_cpu_item(self, item, colors): # pylint: disable=no-self-use
        reItem = {
            'id': item['id'],
            'content': item['taskname'],
            'colors': colors,
            'type': item['type'],
            'show': False,
            'addr': item['addr']
        }
        return reItem

    def convert_cpu_usage_data(self, items, task_datas): # pylint: disable=too-many-locals
        if not items or len(items) == 0:
            return {}

        xData = []
        cpu_data = []
        time_data = []

        self.get_color_config()

        th = TraceHelper(tcm=self.storageColor['taskColorMap'])
        for item in items:
            time_data.append(item['timestamp'])

        if task_datas and len(task_datas) > 0:
            datas = {"xData": xData, "cpu_data": cpu_data}
            self.get_cpu_usage_data(task_datas, th, items, datas)

        self.save_color_config()

        all_result = {
            'xData': xData,
            'cpuData': cpu_data,
            'timeData': time_data
        }
        return all_result

    def get_cpu_usage_data(self, task_datas, th, items, datas):
        xData = datas.get("xData")
        cpu_data = datas.get("cpu_data")
        hasIdle = False
        for task_item in task_datas:
            cpu_data_tmp = []
            range_data_item = { 'taskname': "", 'cpuload': [] }
            if hasIdle and task_item['taskname'] == IDLE_CORE:
                continue
            colors = th.get_task_color(IDLE_TYPE if task_item['taskname'] == IDLE_CORE else NO_IDLE_TYPE,
                                       task_item['addr'] + task_item['taskname'])
            reItem = self.assemble_cpu_item(task_item, colors)
            addr_and_task = f"{task_item['addr']}:{task_item['taskname']}"
            for item in items:
                if item.get(addr_and_task):
                    cpu_data_tmp.append([item['timestamp'], item[addr_and_task]])
                    reItem['show'] = True
                else:
                    cpu_data_tmp.append([item['timestamp'], "0"])

            if reItem['show']:
                range_data_item['cpuload'] = cpu_data_tmp
                range_data_item['taskname'] = str(len(xData) + 1)
                cpu_data.append(range_data_item)
                xData.append(reItem)
                if not hasIdle and task_item['taskname'] == IDLE_CORE:
                    hasIdle = True

    def convert_cpu_count_data(self, items, task_datas): # pylint: disable=too-many-locals
        if not items or len(items) == 0:
            return {}

        xData = []
        cpu_data = []
        time_data = []

        self.get_color_config()

        th = TraceHelper(tcm=self.storageColor['taskColorMap'])
        for item in items:
            time_data.append(item['timestamp'])

        if task_datas and len(task_datas) > 0:
            datas = {"xData": xData, "cpu_data": cpu_data}
            self.get_cpu_count_data(task_datas, th, items, datas)

        self.save_color_config()

        all_result = {
            'xData': xData,
            'cpuData': cpu_data,
            'timeData': time_data
        }
        return all_result

    def get_cpu_count_data(self, task_datas, th, items, datas):
        xData = datas.get("xData")
        cpu_data = datas.get("cpu_data")
        hasIdle = False
        for task_item in task_datas:
            if hasIdle and task_item['taskname'] == IDLE_CORE:
                continue
            colors = th.get_task_color(IDLE_TYPE if task_item['taskname'] == IDLE_CORE else NO_IDLE_TYPE,
                                       task_item['addr'] + task_item['taskname'])
            reItem = self.assemble_cpu_item(task_item, colors)
            addr_and_task = f"{task_item['addr']}:{task_item['taskname']}"
            cpu_data_tmp = 0
            range_data_item = { 'taskname': "", 'cpuload': 0 }
            for item in items:
                if item.get(addr_and_task):
                    cpu_data_tmp += float(item[addr_and_task])
                    reItem['show'] = True

            range_data_item['cpuload'] = cpu_data_tmp
            if range_data_item['cpuload'] != 0:
                range_data_item['taskname'] = str(len(xData) + 1)
                cpu_data.append(range_data_item)
                xData.append(reItem)
                if not hasIdle and task_item['taskname'] == IDLE_CORE:
                    hasIdle = True

    def _mem_handle(self, item, para_list, task_item, reItem):
        last_mem_heap = para_list[0]
        addr_and_task = para_list[1]
        mem_data_tmp = para_list[2]
        if addr_and_task not in last_mem_heap:
            last_mem_heap[addr_and_task] = 0
        if item['taskname'] != addr_and_task:
            mem_data_tmp.append([item['timestamp'], last_mem_heap[addr_and_task]])
        else:
            heap_usage = int(item['heap_usage']) if int(item['heap_usage']) > 0 else 0
            if item['heap_free']:
                last_mem_heap[addr_and_task] = heap_usage
            else:
                last_mem_heap[addr_and_task] += heap_usage
            mem_data_tmp.append([item['timestamp'], last_mem_heap[addr_and_task]])
            if last_mem_heap[addr_and_task] != 0 or task_item['taskname'] == "System":
                reItem['show'] = True

    def convert_mem_row_data(self, items, task_datas): # pylint: disable=too-many-locals, too-many-branches
        if not items or len(items) == 0:
            return {}

        xData = []
        mem_data = []
        time_data = []
        hasIdle = False

        self.get_color_config()

        th = TraceHelper(tcm=self.storageColor['taskColorMap'])
        for item in items:
            time_data.append(item['timestamp'])

        if task_datas and len(task_datas) > 0:
            system_task = {
                'id': 0,
                'taskname': "System",
                'type': 0,
                'addr': "0xffffffff"
            }
            task_datas.append(system_task)
            for task_item in task_datas:
                mem_data_tmp = []
                range_data_item = { 'taskname': "", 'memHeap': [] }
                if hasIdle and task_item['taskname'] == IDLE_CORE:
                    continue
                colors = th.get_task_color(IDLE_TYPE if task_item['taskname'] == IDLE_CORE else NO_IDLE_TYPE, \
                                            task_item['addr'] + task_item['taskname'])
                reItem = self.assemble_cpu_item(task_item, colors)
                last_mem_heap = {}
                addr_and_task = f"{task_item['addr']}:{task_item['taskname']}"
                for item in items:
                    para_list = [last_mem_heap, addr_and_task, mem_data_tmp]
                    self._mem_handle(item, para_list, task_item, reItem)
                if reItem['show']:
                    range_data_item['memHeap'] = mem_data_tmp
                    range_data_item['taskname'] = str(len(xData) + 1)
                    mem_data.append(range_data_item)
                    xData.append(reItem)
                if reItem['show'] and not hasIdle and task_item['taskname'] == IDLE_CORE:
                    hasIdle = True

        self.save_color_config()

        all_result = {
            'xData': xData,
            'memData': mem_data,
            'timeData': time_data
        }
        return all_result

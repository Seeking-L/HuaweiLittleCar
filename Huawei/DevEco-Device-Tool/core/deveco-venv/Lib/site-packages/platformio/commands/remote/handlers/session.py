import os
import shutil
import pathlib
import hashlib
import tempfile
import platformio.util
import platformio.rpc.exception
from platformio.rpc.server import Handler


class Session(Handler):

    def __init__(self, connection, manager, logger):
        super().__init__(connection=connection, manager=manager, logger=logger)
        self.__local_project_path = None
        self.__remote_project_path = None
        self.__remote_system = None

    def on_close_connection(self):
        self.close()

    def is_relative_to(self, path):
        try:
            path.relative_to(self.__remote_project_path)
            return True
        except ValueError:
            return False

    @Handler.method()
    def open(self, params):
        # store remote-system
        self.__remote_system = params['system'].lower() if 'system' in params else None
        # store local and remote project paths
        if 'project_path' in params:
            self.__remote_project_path = self.__make_path(params['project_path'], self.__remote_system)
            pp = str(self.__remote_project_path)
            if self.__remote_system.lower() == 'windows':
                pp = pp.lower()
            self.__local_project_path = os.path.join(tempfile.gettempdir(),
                                                     'deveco-operation-server-' +
                                                     hashlib.sha256(pp.encode('utf8', errors='ignore')).hexdigest())
        else:
            self.__remote_project_path = None
            self.__local_project_path = tempfile.mkdtemp(prefix='deveco-operation-server-')

        if not os.path.exists(self.__session_lock_file()):
            os.makedirs(os.path.dirname(self.__session_lock_file()), exist_ok=True)
            open(self.__session_lock_file(), 'wt').close()
        self.logger.info(f'open session: local=[{platformio.util.get_systype()}] {self.__local_project_path} <--> '
                         f'remote=[{self.__remote_system}] {self.__remote_project_path}')
        return True

    @Handler.method()
    def close(self):
        if self.__local_project_path:
            self.logger.info(f'close session: {self.__local_project_path}')
            if os.path.isfile(self.__session_lock_file()):
                os.unlink(self.__session_lock_file())
            ses_dir = os.path.dirname(self.__session_lock_file())
            if not os.path.isdir(ses_dir) or not os.listdir(ses_dir):
                self.logger.info(f'no more connected clients to project: {self.__local_project_path} - remove folder')
                shutil.rmtree(self.__local_project_path, ignore_errors=True)
        self.__local_project_path = None
        self.__remote_project_path = None
        self.__remote_system = None
        return True

    def remote_to_local_path_file(self, remote):
        if self.__local_project_path is None or self.__remote_system is None or self.__remote_project_path is None:
            raise Exception('Working session is not open for current connection')
        remote = self.__make_path(remote, self.__remote_system)
        pf = str(remote)
        if self.__remote_system.lower() == "windows":
            pf = pf.lower()
            file_name = pathlib.PureWindowsPath(pf).name
        else:
            file_name = pathlib.PurePosixPath(pf).name
        if self.is_relative_to(remote):
            rel_path = remote.relative_to(self.__remote_project_path)
        else:
            rel_path = os.path.join("globals", hashlib.sha256(pf.encode('utf8', errors='ignore')).hexdigest(),
                                    file_name)
        # noinspection PyTypeChecker
        return str(pathlib.PurePath(self.__local_project_path) / pathlib.PurePath(rel_path))

    def remote_to_local_path_command(self, remote):
        if self.__local_project_path is None or self.__remote_system is None or self.__remote_project_path is None:
            raise Exception('Working session is not open for current connection')
        remote = self.__make_path(remote, self.__remote_system)
        rel_path = remote.relative_to(self.__remote_project_path)
        # noinspection PyTypeChecker
        return str(pathlib.PurePath(self.__local_project_path) / pathlib.PurePath(rel_path))

    def local_path(self):
        if self.__local_project_path is None:
            raise Exception('Working session is not open for current connection')
        return str(pathlib.PurePath(self.__local_project_path))

    def get_remote_rel_path(self, remote):
        if self.__local_project_path is None or self.__remote_system is None or self.__remote_project_path is None:
            raise Exception('Working session is not open for current connection')
        remote = self.__make_path(remote, self.__remote_system)
        rel_path = None
        if not self.is_relative_to(remote):
            return None
        rel_path = remote.relative_to(self.__remote_project_path)
        return str(self.__make_path(rel_path, self.__remote_system))

    @staticmethod
    def __make_path(path, os_system):
        if path is not None and os_system is not None:
            return pathlib.PureWindowsPath(path) if os_system.lower() == 'windows' else pathlib.PurePosixPath(path)
        raise Exception(f'Both path and system should be set for session. Currently: path={path}, system={os_system}')

    def __session_lock_file(self):
        return os.path.join(self.__local_project_path, '.sessions', self.connection.connection_id)

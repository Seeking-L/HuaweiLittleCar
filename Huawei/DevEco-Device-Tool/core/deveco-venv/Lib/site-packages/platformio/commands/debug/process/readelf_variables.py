# ---------------------------------------------------------------------------
# scripts/readelf.py
#
# A clone of 'readelf' in Python, based on the pyelftools library
#
# Eli Bendersky (eliben@gmail.com)
# This code is in the public domain
# ----------------------------------------------------------------------------
import json
import tempfile
from elftools import __version__
from elftools.elf.elffile import ELFFile
from elftools.elf.dynamic import DynamicSection
from elftools.elf.sections import (
    SymbolTableSection, SymbolTableIndexSection
)
from elftools.elf.gnuversions import (
    GNUVerSymSection, GNUVerDefSection,
    GNUVerNeedSection,
)
from elftools.elf.constants import SHN_INDICES

from elftools.elf.descriptions import (
    describe_symbol_type, describe_symbol_bind,
    describe_symbol_visibility, describe_symbol_shndx
)


class ReadelfVariable(object):
    """ display_* methods are used to emit output into the output stream
    """

    def __init__(self, file, output):
        """ file:
                stream object with the ELF file to read

            output:
                output stream to write to
                output stream to write to
        """
        self.elffile = ELFFile(file)
        self.output = output

        # Lazily initialized if a debug dump is requested
        self._dwarfinfo = None

        self._versioninfo = None

        self._shndx_sections = None

    def display_symbol_tables(self):
        """ Display the symbol tables contained in the file
        """
        self._init_versioninfo()

        symbol_tables = [(idx, s) for idx, s in enumerate(self.elffile.iter_sections())
                         if isinstance(s, SymbolTableSection)]

        if not symbol_tables and self.elffile.num_sections() == 0:
            self._emitline('')
            self._emitline('Dynamic symbol information is not available for'
                           ' displaying symbols.')

        for section_index, section in symbol_tables:
            if not isinstance(section, SymbolTableSection):
                continue

            if section['sh_entsize'] == 0:
                self._emitline("\nSymbol table '%s' has a \
                    sh_entsize of zero!" % (section.name))
                continue

            self._emitline("\nSymbol table '%s' contains %s entries:" % (
                section.name, section.num_symbols()))

            if self.elffile.elfclass == 32:
                self._emitline('   Num:    Value  Size Type    \
                    Bind   Vis      Ndx Name')
            else:  # 64
                self._emitline('   Num:    Value          \
                    Size Type    Bind   Vis      Ndx Name')

            for nsym, symbol in enumerate(section.iter_symbols()):
                version_info = ''
                # readelf doesn't display version info for Solaris versioning
                if (section['sh_type'] == 'SHT_DYNSYM' and
                        self._versioninfo['type'] == 'GNU'):
                    version_info = self._hidden_versioninfo(nsym, symbol)
                # symbol names are truncated to 25 chars, similarly to readelf
                self._emitline('%6d: %s %s %-7s %-6s %-7s %4s %.25s%s' % (
                    nsym,
                    self._format_hex(
                        symbol['st_value'], fullhex=True, lead0x=False),
                    "%5d" % symbol['st_size'] if symbol['st_size']
                    < 100000 else hex(symbol['st_size']),
                    describe_symbol_type(symbol['st_info']['type']),
                    describe_symbol_bind(symbol['st_info']['bind']),
                    describe_symbol_visibility(symbol['st_other']
                                               ['visibility']),
                    describe_symbol_shndx(self._get_symbol_shndx(symbol,
                                                                 nsym,
                                                                 section_index)
                                          ),
                    symbol.name,
                    version_info))

    def _hidden_versioninfo(self, nsym, symbol):
        version_info = ''
        version = self._symbol_version(nsym)
        if (version['name'] != symbol.name and
            version['index'] not in ('VER_NDX_LOCAL',
                                     'VER_NDX_GLOBAL')):
            version_info = '@@%(name)s' % version
            if version['filename']:
                # external symbol
                version_info = '@%(name)s (%(index)i)' % version
            else:
                # internal symbol
                if version['hidden']:
                    version_info = '@%(name)s' % version
                else:
                    version_info = '@@%(name)s' % version
        return version_info

    def _init_versioninfo(self):
        """ Search and initialize informations about version related sections
            and the kind of versioning used (GNU or Solaris).
        """
        if self._versioninfo is not None:
            return

        self._versioninfo = {'versym': None, 'verdef': None,
                             'verneed': None, 'type': None}

        for section in self.elffile.iter_sections():
            if isinstance(section, GNUVerSymSection):
                self._versioninfo['versym'] = section
            elif isinstance(section, GNUVerDefSection):
                self._versioninfo['verdef'] = section
            elif isinstance(section, GNUVerNeedSection):
                self._versioninfo['verneed'] = section
            elif isinstance(section, DynamicSection):
                self._init_versioninfo_branch(section)

        if not self._versioninfo['type'] and (
                self._versioninfo['verneed'] or self._versioninfo['verdef']):
            self._versioninfo['type'] = 'Solaris'

    def _init_versioninfo_branch(self, section):
        for tag in section.iter_tags():
            if tag['d_tag'] == 'DT_VERSYM':
                self._versioninfo['type'] = 'GNU'
                break

    def _emitline(self, s=''):
        """ Emit an object to output, followed by a newline
        """
        self.output.write(str(s).rstrip() + '\n')

    def _symbol_version(self, nsym):
        """ Return a dict containing information on the
                   or None if no version information is available
        """
        self._init_versioninfo()

        symbol_version = dict.fromkeys(('index', 'name', 'filename', 'hidden'))

        if (not self._versioninfo['versym'] or
                nsym >= self._versioninfo['versym'].num_symbols()):
            return None

        symbol = self._versioninfo['versym'].get_symbol(nsym)
        index = symbol.entry['ndx']
        if index not in ('VER_NDX_LOCAL', 'VER_NDX_GLOBAL'):
            index = int(index)

            if self._versioninfo['type'] == 'GNU':
                # In GNU versioning mode, the highest bit is used to
                # store whether the symbol is hidden or not
                if index & 0x8000:
                    index &= ~0x8000
                    symbol_version['hidden'] = True

            if (self._versioninfo['verdef'] and
                    index <= self._versioninfo['verdef'].num_versions()):
                _, verdaux_iter = \
                    self._versioninfo['verdef'].get_version(index)
                symbol_version['name'] = next(verdaux_iter).name
            else:
                verneed, vernaux = \
                    self._versioninfo['verneed'].get_version(index)
                symbol_version['name'] = vernaux.name
                symbol_version['filename'] = verneed.name

        symbol_version['index'] = index
        return symbol_version

    def _format_hex(self, addr, fieldsize=None, fullhex=False, lead0x=True):
        """ Format an address into a hexadecimal string.

            fieldsize:
                Size of the hexadecimal field (with leading zeros to fit the
                address into. For example with fieldsize=8, the format will
                be %08x
                If None, the minimal required field size will be used.

            fullhex:
                If True, override fieldsize to set it to the maximal size
                needed for the elfclass

            lead0x:
                If True, leading 0x is added

            alternate:
                If True, override lead0x to emulate the alternate
                hexadecimal form specified in format string with the #
                character: only non-zero values are prefixed with 0x.
                This form is used by readelf.

            alternate = False
            if alternate:
                if addr == 0:
                    lead0x = False
                else:
                    lead0x = True
                    fieldsize -= 2
        """
        s = '0x' if lead0x else ''
        if fullhex:
            fieldsize = 8 if self.elffile.elfclass == 32 else 16
        if fieldsize is None:
            field = '%x'
        else:
            field = '%' + '0%sx' % fieldsize
        return s + field % addr

    def _get_symbol_shndx(self, symbol, symbol_index, symtab_index):
        """ Get the index into the section header table for the "symbol"
            at "symbol_index" located in the symbol table with section index
            "symtab_index".
        """
        symbol_shndx = symbol['st_shndx']
        if symbol_shndx != SHN_INDICES.SHN_XINDEX:
            return symbol_shndx

        # Check for or lazily construct index section mapping (symbol table
        # index -> corresponding symbol table index section object)
        if self._shndx_sections is None:
            self._shndx_sections = {sec.symboltable: sec for sec in self.elffile.iter_sections()
                                    if isinstance(sec, SymbolTableIndexSection)}
        return self._shndx_sections[symtab_index].\
            get_section_index(symbol_index)


SCRIPT_DESCRIPTION = \
    'Display information about the contents of ELF format files'
VERSION_STRING = '%%(prog)s: based on pyelftools %s' % __version__


def display_variables_to_json(elf_path):
    """read elf to json"""
    all_variables_json = []

    with tempfile.NamedTemporaryFile('w+', delete=True) as tmp_path:
        with open(elf_path, 'rb') as elf:
            read = ReadelfVariable(elf, tmp_path)
            read.display_symbol_tables()

        tmp_path.seek(0)
        lines = tmp_path.readlines()

        all_variables_data = []
        key_num = 0
        for line_data in lines:
            line_data = line_data.strip()
            line_data = line_data.split()
            if line_data[3:4] == ['OBJECT'] and line_data[4:5] == ['GLOBAL']:
                variable_data = {}
                key_num = key_num + 1
                variable_data["key"] = key_num
                variable_data["name"] = line_data[7]
                variable_data["category"] = "general"
                variable_data["address"] = line_data[1]
                variable_data["type"] = line_data[3]
                variable_data["size"] = line_data[2]
                variable_data["scope"] = line_data[4]
                all_variables_data.append(variable_data)
        all_variables_json = json.dumps(all_variables_data)
    return all_variables_json

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
Description: 
Create: 2022-06-20
"""
import os
import time
import typing as t

from click._termui_impl import ProgressBar
from click.globals import resolve_color_default
from platformio.commands.exception import DownloadImageSourceError,OversizeError
from platformio.helpers import get_config_json_path
from platformio.commands.dotting.helpers import TraceOperate, ProjectManager
from platformio.util import read_url_json





# =======================================================================
# Configuration of source code download.

class SourceDownloadConfig(object):
    # Error MSG
    SPACE_INSUFFICIENT_MSG = 'The disk space is insufficient. Please select another download directory.'
    DOWNLOAD_DIR_NOT_EXIST_MSG = 'The directory is unavailable. Please select another available directory..'
    # Conversion Unit
    KILO_BYTE = 1024
    SHA_FILE_SIZE = "65 Byte"
    # Store path is ~/.deveco-device-tool/openharmony-source.
    # The download is complete at a time and is reused for all-life.
    SOURCE_CACHE_STORE_DIRECTORY = get_config_json_path() + os.sep + 'openharmony-source'
    REDUNDANT_FOLDER_LAYERS = 'OpenHarmony'


# =======================================================================
# Use the Decorator to dot the download code.

def download_trace(func):
    def inner(*args, **kwargs):
        FAQ_FOR_DOWNLOAD_ERR = read_url_json().get('device_harmonyos_faq', '')
        start_time = time.time()
        is_succeeded, error_causes, version_name = func(*args, **kwargs)
        duration = time.time() - start_time
        TraceOperate(ProjectManager).operate("Project", "create_project_by_source", (duration, version_name,
                                                                                     is_succeeded, error_causes))
        if not is_succeeded:
            raise DownloadImageSourceError(error_causes, FAQ_FOR_DOWNLOAD_ERR)

    return inner


# =======================================================================
# The progressbar function is reconstructed and the download speed is displayed.


def deveco_progressbar(
        length: t.Optional[int] = None,
        label: t.Optional[str] = None,
        show_speed: bool = False,
        bar_template: str = "%(label)s  [%(bar)s]  %(info)s",
        color: t.Optional[bool] = None
):
    return DevEcoProgressBar(
        length=length,
        label=label,
        show_speed=show_speed,
        bar_template=bar_template,
        empty_char="-",
        color=resolve_color_default(color),
    )


class DevEcoProgressBar(ProgressBar):
    KILO_BYTE = 1024
    _1M = 1024 * 1024
    _1G = 1024 * _1M
    _1T = 1024 * _1G

    def __init__(self,
                 iterable: t.Optional[t.Iterable[t.TypeVar("V")]] = None,
                 length: t.Optional[int] = None,
                 fill_char: str = "#",
                 empty_char: str = " ",
                 bar_template: str = "%(bar)s",
                 info_sep: str = "  ",
                 show_eta: bool = True,
                 show_percent: t.Optional[bool] = None,
                 show_pos: bool = False,
                 item_show_func: t.Optional[t.Callable[[t.Optional[t.TypeVar("V")]], t.Optional[str]]] = None,
                 label: t.Optional[str] = None,
                 file: t.Optional[t.TextIO] = None,
                 color: t.Optional[bool] = None,
                 width: int = 36,
                 show_speed: bool = False,
                 speed: int = 0
                 ):
        super(DevEcoProgressBar, self).__init__(
            iterable,
            length,
            fill_char,
            empty_char,
            bar_template,
            info_sep,
            show_eta,
            show_percent,
            show_pos,
            item_show_func,
            label,
            file,
            color,
            width
        )
        self.speed = speed
        self.show_speed = show_speed

    def format_speed(self) -> str:
        if 0 <= self.speed < self._1M:
            speed_info = '%.2f KB/s' % (self.speed / self.KILO_BYTE)
        elif self._1M <= self.speed <= self._1G:
            speed_info = '%.2f MB/s' % (self.speed / self._1M)
        elif self._1G <= self.speed <= self._1T:
            speed_info = '%.2f GB/s' % (self.speed / self._1G)
        else:
            speed_info = '%.2f TB/s' % (self.speed / self._1T)
        return speed_info

    def format_progress_line(self) -> str:
        show_percent = self.show_percent

        info_bits = []
        if self.length is not None and show_percent is None:
            show_percent = not self.show_pos

        if self.show_pos:
            info_bits.append(self.format_pos())
        if show_percent:
            info_bits.append(self.format_pct())
        if self.show_eta and self.eta_known and not self.finished:
            info_bits.append(self.format_eta())
        if self.show_speed:
            info_bits.append(self.format_speed())
        if self.item_show_func is not None:
            item_info = self.item_show_func(self.current_item)
            if item_info is not None:
                info_bits.append(item_info)
        return (
                self.bar_template
                % {
                    "label": self.label,
                    "bar": self.format_bar(),
                    "info": self.info_sep.join(info_bits),
                }
        ).rstrip()

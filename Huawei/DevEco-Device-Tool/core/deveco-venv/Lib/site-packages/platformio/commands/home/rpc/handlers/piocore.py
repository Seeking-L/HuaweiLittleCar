# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import json
import time
import asyncio
import threading
import subprocess
import platformio.helpers
import platformio.rpc.server
from platformio.proc import kill_process_tree_by_pid


class CoreRPC(platformio.rpc.server.Handler):

    def __init__(self, connection, manager, logger):
        super().__init__(connection=connection, manager=manager, logger=logger)
        self.__procedures = {}
        self.__connected = True
        asyncio.get_event_loop().create_task(self.__execution_status_watcher())

    def on_close_connection(self):
        super().on_close_connection()
        self.__connected = False
        to_kill = self.__procedures
        self.__procedures = {}
        for k, v in to_kill.items():
            self.__kill_proc(k, v)

    @platformio.rpc.server.Handler.method()
    def call(self, params, request_id, result_decorator=None):
        args = [str(x) for x in params[0]]
        options = params[1] if len(params) > 1 else {}
        cwd = options.get("cwd", os.getcwd())
        stream_id = options.get("stream_output", None)
        kill_child = options.get('stream_kill_child', False)
        cmd = [platformio.helpers.get_executable_path()] + [str(x) for x in args]

        self.logger.info(f'starting process "{request_id}" with command "{" ".join(cmd)}"')
        process = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        stdout_data = bytearray()
        stderr_data = bytearray()
        stdout_thread = threading.Thread(target=self.__stream_reader, args=(process.stdout, stdout_data, request_id))
        stderr_thread = threading.Thread(target=self.__stream_reader, args=(process.stderr, stderr_data, request_id))
        self.__procedures[request_id] = {
            'process': process,
            'cmd': cmd,
            'exit_code': None,
            'stdout': {'data': stdout_data, 'thread': stdout_thread},
            'stderr': {'data': stderr_data, 'thread': stderr_thread},
            'last_access': time.time(),
            'stream_id': stream_id,
            'kill_child': kill_child,
            'result_decorator': result_decorator if callable(result_decorator) else lambda x, y: (x, y),
        }
        stdout_thread.start()
        stderr_thread.start()
        return platformio.rpc.server.AsyncResponse()

    @platformio.rpc.server.Handler.method()
    def get_stream(self, params):
        for _, v in self.__procedures.items():
            if v['stream_id'] == params[0]:
                v['last_access'] = time.time()
                return {'id': params[0],
                        'status': 'closed' if v['exit_code'] is not None else 'active',
                        'last_access': v['last_access'],
                        'data': self.__collect_proc_out(v)}

        return None

    @platformio.rpc.server.Handler.method()
    def kill_stream(self, params):
        for k, v in self.__procedures.items():
            if v['stream_id'] == params[0]:
                self.__kill_proc(k, v)
                return True
        return False

    async def __execution_status_watcher(self):
        while self.__connected:  # pylint: disable=too-many-nested-blocks
            # cleanup finished procedures
            old = time.time() - 60
            check_id = lambda v: v['exit_code'] is None or \
                (v['stream_id'] and not (v['stream_id'].startswith("trace-stream-id") or \
                    v['stream_id'].startswith("profiling-stream-id")) and v['last_access'] > old)
            self.__procedures = {k: v for k, v in self.__procedures.items() if check_id(v)}
            # update status
            for k, v in self.__procedures.items():
                if v['exit_code'] is None:
                    await self.handle_status_watcher(v, k)

            await asyncio.sleep(0.5)

    async def handle_status_watcher(self, v, k):
        v['exit_code'] = v['process'].poll()
        if v['exit_code'] is not None:
            try:
                self.logger.info(f'exit process "{k}" with code {v["exit_code"]}')
                text = self.__collect_proc_out(v)
                v['exit_code'], text = v['result_decorator'](v['exit_code'], text)
                if v['exit_code'] != 0:
                    await self.send_async_error(error=text, request_id=k)
                elif '--json-output' in v['cmd']:
                    parsed = json.loads(text) if text else []
                    await self.send_async_response(result=parsed, request_id=k)
                else:
                    await self.send_async_response(result=text, request_id=k)

            except Exception as e:  # pylint: disable=broad-except
                self.logger.warning('send async error')
                await self.send_async_error(error=str(e), request_id=k)

    def __stream_reader(self, s, q, execution_id):
        while execution_id in self.__procedures:
            b = s.read(1)
            if not b:
                break
            q.extend(b)

    @staticmethod
    def __collect_proc_out(proc):
        text = ''
        if proc['stream_id']:
            text += ' '.join(proc['cmd']) + '\n'
        text += f"{proc['stdout']['data'].decode(errors='ignore')}\n\n{proc['stderr']['data'].decode(errors='ignore')}"
        return text.strip()

    def __kill_proc(self, request_id, proc):
        if proc['exit_code'] is None:
            self.logger.info(f'kill process "{request_id}"')
            if proc['kill_child']:
                kill_process_tree_by_pid(proc['process'].pid)
            else:
                proc['process'].terminate()
            proc['stdout']['thread'].join()
            proc['stderr']['thread'].join()
            proc['stdout']['data'] += b'\nCanceled by user\n'

# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
Description:
Create: 2022-03-17
"""

import os
import re
import click
import json
import subprocess
from platformio.commands.exception import (CommandError, RunComponentToolError, ComponentBaseNotFound)
from platformio.proc import AsyncPipeBase
from platformio.commands.dotting.helpers import TraceOperate, ComponentTrace


BASE_PRODUCTS_INFO = {
    'standard': ['system_arm64_default', 'system_arm_default', 'ohos-arm64']
}


def get_component_tools(project_dir):
    component_tools_path = os.path.join(project_dir, 'build', 'tools', 'component_tools')
    tool_gen_kcfg_path = os.path.join(component_tools_path, 'generate_kconfig.py')
    tool_parse_kcfg_path = os.path.join(component_tools_path, 'parse_kconf.py')
    return {
        'gen_kcfg': {
            'path': tool_gen_kcfg_path,
            'valid': os.path.isfile(tool_gen_kcfg_path),
        },
        'parse_kcfg': {
            'path': tool_parse_kcfg_path,
            'valid': os.path.isfile(tool_parse_kcfg_path),
        },
        'gen_tools_path': component_tools_path,
        'deps_tools_path': os.path.join(project_dir, 'build', 'tools', 'module_dependence')
    }


def check_base_products(project_dir):
    for _, base_products in BASE_PRODUCTS_INFO.items():
        for base_product in base_products:
            if os.path.isfile(
                os.path.join(project_dir, 'productdefine', 'common', 'products', f'{base_product}.json')):
                return True
    return False


def get_config_board(base_product_path):
    try:
        with open(base_product_path, 'r', encoding="UTF-8") as f:
            config = json.loads(f.read())
            board = config.get('board', '')
    except (json.JSONDecodeError, FileNotFoundError):
        board = ''
    return board


def get_base_product(project_dir, os_type):
    products_path = os.path.join(project_dir, 'productdefine', 'common', 'products')
    for product in BASE_PRODUCTS_INFO.get(os_type, []):
        base_product_path = os.path.join(products_path, f'{product}.json')
        if not os.path.isfile(base_product_path):
            continue
        board = get_config_board(base_product_path)
        if board:
            return dict(base_product=product, out_path=os.path.join('out', board), product_path=base_product_path)
    raise ComponentBaseNotFound()


def dot_trace_gen_cfg(event, succeed):
    TraceOperate(ComponentTrace).operate("Component", "gen_product_cfg", event, succeed)


def run_command(cmds, **kwargs):
    kwargs.update({'check': True})
    try:
        cp = subprocess.run(cmds, **kwargs)
    except subprocess.SubprocessError as e:
        raise RunComponentToolError(cmds[0], e) from e
    except FileNotFoundError as e:
        raise CommandError(e) from e
    return cp


def ask_for_gen_deps_files(project_dir, relative_out_path):
    to_generate = True
    relative_path = os.path.join(relative_out_path, 'deps_files')
    abs_path = os.path.join(project_dir, relative_path)
    if os.path.isdir(abs_path) and os.listdir(abs_path):
        confirm_msg = f'Folder {relative_path} has been generated already. Do you want to regenerate it? Default: N'
        to_generate = click.confirm(click.style(confirm_msg, fg='blue'))
    return to_generate


class MenuAsyncPipe(AsyncPipeBase):
    def __init__(self):
        self._config_path = '.config'
        super(MenuAsyncPipe, self).__init__()

    def do_reading(self):
        line_bytes = bytearray()
        for byte in iter(lambda: self._pipe_reader.read(1), bytes()):
            click.echo(byte, nl=False)
            line_bytes += byte
            if byte == b'\n':
                self._parse_config_path(line_bytes)
                line_bytes = bytearray()

        self._pipe_reader.close()

    def _parse_config_path(self, line_bytes):
        str_output = line_bytes.decode(errors='backslashreplace')
        pattern = r"No changes to save \(for '(.+)'\)"
        match_path_list = re.findall(pattern, str_output)
        if match_path_list:
            self._config_path = match_path_list[0]

    @property
    def config_path(self):
        return self._config_path

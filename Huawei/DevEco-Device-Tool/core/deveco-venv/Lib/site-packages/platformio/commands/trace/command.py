# pylint: disable=import-error
import json
import os
import sys
from os import environ
import click
from serial import Serial
import pexpect
from platformio.util import serialspawn
from liteos_optimize_adapter import TraceOptimize
from platformio.compat import dump_json_to_unicode
from platformio.project.helpers import get_project_cache_dir
from platformio.commands.trace.manager.trace_database import TraceDatabaseManager
from platformio.commands.trace.manager.trace_data import TraceDataManager
from platformio.rpc.helpers import execute_remote_command
from platformio.commands.exception import TraceCommandError

DATAPATH = os.path.join(get_project_cache_dir(), 'traceData', 'trace_event_lite.db')
TIMELINEDATARANGE = 1000


@click.group(short_help="Trace support")
def cli():
    pass


@cli.command("setMask", short_help="Set trace event mask")
@click.option("--port", "-p", help="Port, a number or a device name", required=True)
@click.option("--baud", "-b", help="Set baud rate, default=115200", default='115200')
@click.option("--mask", "-m", help="Set mask", default='0x60')
@click.option("--symbol", "-s", help="System running symbol", default='OHOS\\s*#')
@click.option("--force-local", is_flag=True, default=None)
def trace_set_mask(port, baud, mask, symbol, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        status = handle_set_mask(port, baud, symbol, mask)
        return click.echo(status)

    except Exception:
        raise TraceCommandError('Serial error')


def handle_set_mask(port, baud, symbol, mask):
    with Serial(port, baud) as serial_port:
        with serialspawn(serial_port) as serial_cli:
            serial_cli.sendline('cd /bin')
            try:
                serial_cli.expect(symbol)
            except pexpect.exceptions.TIMEOUT:
                return json.dumps({"status": -1})

            serial_cli.sendline('ls trace')
            try:
                serial_cli.expect('/bin/trace')
            except pexpect.exceptions.TIMEOUT:
                return json.dumps({"status": -2})

            serial_cli.sendline(f'./trace mask {mask}')

    return json.dumps({"status": 0})


@cli.command("start", short_help="trace start")
@click.option("--port", "-p", help="Port, a number or a device name", required=True)
@click.option("--baud", "-b", help="Set baud rate, default=115200", default='115200')
@click.option("--force-local", is_flag=True, default=None)
def trace_start(port, baud, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])
        return

    try:
        trace_optimize = TraceOptimize()
        click.echo('trace analysis start')
        trace_optimize.start(port, baud, DATAPATH)
    except Exception as e:
        raise click.exceptions.ClickException('Trace analysis error') from e


@cli.command("stop", short_help="trace stop")
@click.option("--port", "-p", help="Port, a number or a device name", required=True)
@click.option("--baud", "-b", help="Set baud rate, default=115200", default='115200')
@click.option("--force-local", is_flag=True, default=None)
def trace_stop(port, baud, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])
        return

    try:
        trace_optimize = TraceOptimize()
        trace_optimize.stop(port, baud)
    except Exception as e:
        raise click.exceptions.ClickException('Trace stop error') from e


@cli.command("getTimelineData", short_help="get timeline data")
@click.option("--start-row", "-s", help="start row", default='0')
@click.option("--end-row", "-e", help="end row", default='0')
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_timeline(start_row, end_row, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        parts = db.get_data_by_index('Timeline', int(start_row), int(end_row))
        cpuid = db.get_data_by_index('CpuId', 0, 32)
        all_data = db.get_table_size('Timeline')

        tm = TraceDataManager()
        trace_timeline_data = tm.convert_timeline_row_data(parts['items'])

    except Exception:
        raise TraceCommandError('Get timeline data failed')

    finally:
        db.close_database()

    if not trace_timeline_data:
        trace_timeline_data = {'xData': [], 'timeLineData': [], 'minTime': 0, 'maxTime': 0}
        max_times_tamp = all_data['max_timestamp']
    else:
        max_times_tamp = str(max(float(all_data['max_timestamp']), float(trace_timeline_data['maxTime'])))

    timeline_data = {
        'traceTimelineData': trace_timeline_data,
        'dataCount': all_data['count'],
        'maxTimestamp': max_times_tamp,
        'minTimestamp': all_data['min_timestamp'],
        'cpuidDatas': cpuid['items']
    }
    if json_output:
        return click.echo(dump_json_to_unicode(timeline_data))

    return click.echo(timeline_data)


@cli.command("getTimelineDataByTime", short_help="get timeline data by time")
@click.option("--start-time", "-s", help="start time", default='0')
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_timeline_time(start_time, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        row = db.get_current_row_no('Timeline', float(start_time))
        cpuid = db.get_data_by_index('CpuId', 0, 32)
        all_data = db.get_table_size('Timeline')

        startIndex = max((row['rowid'] - TIMELINEDATARANGE / 2), 0)
        endIndex = startIndex + TIMELINEDATARANGE
        parts = db.get_data_by_index('Timeline', startIndex, endIndex)

        tm = TraceDataManager()
        trace_timeline_data = tm.convert_timeline_row_data(parts['items'])

    except Exception as e:
        raise TraceCommandError('Get timeline data by tiem failed')

    finally:
        db.close_database()

    if not trace_timeline_data:
        trace_timeline_data = {'xData': [], 'timeLineData': [], 'minTime': 0, 'maxTime': 0}
        max_times_tamp = all_data['max_timestamp']
    else:
        max_times_tamp = str(max(float(all_data['max_timestamp']), float(trace_timeline_data['maxTime'])))

    timeline_data = {
        'traceTimelineData': trace_timeline_data,
        'dataCount': all_data['count'],
        'maxTimestamp': max_times_tamp,
        'minTimestamp': all_data['min_timestamp'],
        'cpuidDatas': cpuid['items']
    }
    if json_output:
        return click.echo(dump_json_to_unicode(timeline_data))

    return click.echo(timeline_data)


@cli.command("getEventData", short_help="get event data")
@click.option("--start-time", "-s", help="start time", default='0')
@click.option("--end-time", "-e", help="end time", default='0')
@click.option("--cpu-id", "-c", help="CPU id")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_event(start_time, end_time, cpu_id, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        condition = None
        if cpu_id:
            cpu_id = cpu_id.replace("'", '')
            condition = dict(cond="cpuid=?", parames=[cpu_id])
        parts = db.get_data_by_time('TraceLiteEvent', float(start_time), float(end_time), condition)

        tm = TraceDataManager()
        event_data = tm.convert_timeline_events_data(parts['items'])

    except Exception as e:
        raise TraceCommandError('Get event data failed')

    finally:
        db.close_database()

    if not event_data:
        event_data = {}

    trace_event_data = {
        'eventData': event_data
    }

    if json_output:
        return click.echo(dump_json_to_unicode(trace_event_data))

    return click.echo(trace_event_data)


@cli.command("getTraceLiteEventData", short_help="get tracelite event data")
@click.option("--start-row", "-s", help="start row", default='0')
@click.option("--end-row", "-e", help="end row", default='0')
@click.option("--condition", "-c", help="condition")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_tracelite_event(start_row, end_row, condition, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        cone_dict = None
        if condition:
            cond = ''
            items = condition.split(',')
            for _ in items:
                cond = cond + 'eventType not like ? and '
            cone_dict = dict(cond=cond[:-4], parames=items)       
        parts = db.get_data_by_index('TraceLiteEvent', int(start_row), int(end_row), cone_dict)
        all_data = db.get_table_size('TraceLiteEvent')

        tm = TraceDataManager()
        trace_event_data = tm.convert_event_table_data(parts['items'])

    except Exception as e:
        raise TraceCommandError('Get traceLiteEvent data failed')

    finally:
        db.close_database()

    tracelite_event_date = {
        'traceEventData': trace_event_data,
        'dataCount': all_data['count']
    }
    if json_output:
        return click.echo(dump_json_to_unicode(tracelite_event_date))

    return click.echo(tracelite_event_date)


@cli.command("getCpuUsageData", short_help="get cpu usage data")
@click.option("--start-row", "-s", help="start row", default='0')
@click.option("--end-row", "-e", help="end row", default='0')
@click.option("--cpu-id", "-c", help="CPU id")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_cpu_usage(start_row, end_row, cpu_id, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        condition = None
        if cpu_id:
            cpu_id = cpu_id.replace("'", '')
            condition = dict(cond="cpuid=?", parames=[cpu_id])
        parts = db.get_data_by_index('CpuUsage', int(start_row), int(end_row), condition)
        cpuid = db.get_data_by_index('CpuId', 0, 32)
        task_datas = db.get_data_by_index('TaskList', 0, 0)
        all_data = db.get_table_size('CpuUsage', condition)

        tm = TraceDataManager()
        trace_cpu_data = tm.convert_cpu_usage_data(parts['items'], task_datas['items'])

    except Exception as e:
        raise TraceCommandError('Get cpuUsage data failed')

    finally:
        db.close_database()

    if not trace_cpu_data:
        trace_cpu_data = {'xData': [], 'cpuData': [], 'minTime': 0, 'timeData': 0}

    cpu_usage_data = {
        'traceCPUDataByCpuid': trace_cpu_data,
        'dataCount': all_data['count'],
        'cpuidDatas': cpuid['items']
    }
    if json_output:
        return click.echo(dump_json_to_unicode(cpu_usage_data))

    return click.echo(cpu_usage_data)


@cli.command("getCpuCountData", short_help="get cpu count data")
@click.option("--start-row", "-s", help="start row", default='0')
@click.option("--end-row", "-e", help="end row", default='0')
@click.option("--cpu-id", "-c", help="CPU id")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_cpu_count(start_row, end_row, cpu_id, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        condition = None
        if cpu_id:
            cpu_id = cpu_id.replace("'", '')
            condition = dict(cond="cpuid=?", parames=[cpu_id])
        parts = db.get_data_by_index('CpuUsage', int(start_row), int(end_row), condition)
        cpuid = db.get_data_by_index('CpuId', 0, 32)
        task_datas = db.get_data_by_index('TaskList', 0, 0)
        all_data = db.get_table_size('CpuUsage', condition)

        tm = TraceDataManager()
        trace_cpu_data = tm.convert_cpu_count_data(parts['items'], task_datas['items'])

    except Exception as e:
        raise TraceCommandError('Get cpuCount data failed')

    finally:
        db.close_database()

    if not trace_cpu_data:
        trace_cpu_data = {'xData': [], 'cpuData': [], 'minTime': 0, 'timeData': 0}

    cpu_count_data = {
        'traceCPUCountData': trace_cpu_data,
        'dataCount': all_data['count'],
        'cpuidDatas': cpuid['items']
    }
    if json_output:
        return click.echo(dump_json_to_unicode(cpu_count_data))

    return click.echo(cpu_count_data)


@cli.command("getMemData", short_help="get Memory data")
@click.option("--start-row", "-s", help="start row", default='0')
@click.option("--end-row", "-e", help="end row", default='0')
@click.option("--mem-pool", "-m", help="MemPool")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def get_mem_data(start_row, end_row, mem_pool, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    try:
        db = TraceDatabaseManager()
        db.reset_database(DATAPATH)
        mem_pool_datas = []
        pool_data = db.get_data_by_index('MemPool', 0, 32)
        condition = None
        if pool_data['items']:
            mem_pool_datas = pool_data['items']
            parames = [mem_pool] if mem_pool else [pool_data['items'][0]]
            condition = dict(cond="pool=? or pool=?", parames=parames + [''])

        parts = db.get_data_by_index('MemoryUsage', int(start_row), int(end_row), condition)
        task_datas = db.get_data_by_index('TaskList', 0, 0)
        all_data = db.get_table_size('MemoryUsage', condition)

        tm = TraceDataManager()
        trace_mem_data = tm.convert_mem_row_data(parts['items'], task_datas['items'])

    except Exception as e:
        raise TraceCommandError('Get mem data failed')

    finally:
        db.close_database()

    if not trace_mem_data:
        trace_mem_data = {'xData': [], 'memData': [], 'timeData': []}

    mem_datas = {
        'traceMEMData': trace_mem_data,
        'dataCount': all_data['count'],
        'memPoolDatas': mem_pool_datas
    }
    if json_output:
        return click.echo(dump_json_to_unicode(mem_datas))

    return click.echo(mem_datas)

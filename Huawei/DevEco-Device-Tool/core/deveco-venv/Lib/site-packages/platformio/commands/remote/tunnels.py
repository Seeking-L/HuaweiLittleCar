import socket
import select
import threading
import socketserver
import platformio.logger
from platformio.helpers import get_logger_config
logger = platformio.logger.Logger(**get_logger_config(), level='error')


class BaseTunnel:
    def __init__(self, transport, local_port, remote_port):
        self._transport = transport
        self._remote_port = remote_port
        self._local_port = local_port

    @property
    def remote_port(self):
        return self._remote_port

    @property
    def local_port(self):
        return self._local_port

    def start(self):
        pass

    def handle_connection(self, client_socket, client_address):
        pass

    @staticmethod
    def forward_socket_data(sock1, sock2):
        while True:
            r, _, _ = select.select([sock1, sock2], [], [])
            if sock1 in r:
                data = sock1.recv(1024)
                if len(data) == 0:
                    break
                sock2.send(data)
            if sock2 in r:
                data = sock2.recv(1024)
                if len(data) == 0:
                    break
                sock1.send(data)
        sock2.close()
        sock1.close()


# -------------------------------------------------------------------------------------------------
# Forward Tunnel
class ThreadingServer(socketserver.ThreadingTCPServer):
    daemon_threads = True
    allow_reuse_address = True

    def __init__(self, server_address, handler):
        super().__init__(server_address, socketserver.BaseRequestHandler)
        self.__handler = handler

    def finish_request(self, request, client_address):
        super().finish_request(request, client_address)
        self.__handler(request, client_address)


class Tunnel(BaseTunnel):
    def __init__(self, transport, local_port, remote_port):
        super().__init__(transport, local_port, remote_port)
        self.__server = ThreadingServer(("", self._local_port), handler=self.handle_connection)

    def start(self):
        logger.info(f'Start port forwarding: remote:{self._remote_port} <--SSH-- local:{self._local_port}')
        thr = threading.Thread(target=self.__server.serve_forever)
        thr.setDaemon(True)
        thr.start()

    def handle_connection(self, client_socket, client_address):
        try:
            ssh_channel = self._transport.open_channel("direct-tcpip", ('127.0.0.1', self._remote_port), client_address)
        except Exception as e:  # pylint: disable=broad-except
            logger.warning(f'Port forwarding request failed {client_address}: open channel error')
            return

        logger.debug(f'Port forwarding open: remote:{self._remote_port}({client_address[1]}) <--SSH-- '
                     f'local:{self._local_port}')
        self.forward_socket_data(client_socket, ssh_channel)
        logger.debug(f'Port forwarding close: remote:{self._remote_port}({client_address[1]}) <--SSH-- '
                     f'local:{self._local_port}')


# -------------------------------------------------------------------------------------------------
# Revers Tunnel
class RTunnel(BaseTunnel):
    __instances = []

    def __init__(self, transport, local_port, remote_port):
        super().__init__(transport, local_port, remote_port)
        RTunnel.__instances.append(self)

    def __del__(self):
        RTunnel.__instances.remove(self)

    @staticmethod
    def __on_connected(channel, _, server):
        for t in RTunnel.__instances:
            if t.remote_port == server[1]:
                thr = threading.Thread(target=t.handle_connection, args=(channel, ('127.0.0.1', t.local_port)))
                thr.setDaemon(True)
                thr.start()

    def start(self):
        logger.info(f'Start revers port forwarding: remote:{self._remote_port} --SSH--> local:{self._local_port}')
        self._transport.request_port_forward('127.0.0.1', self._remote_port, RTunnel.__on_connected)

    def handle_connection(self, client_socket, client_address):
        logger.debug(f'Revers port forwarding request: remote:{self._remote_port} --SSH--> local:{self._local_port}')
        server_socket = socket.socket()
        try:
            server_socket.connect(client_address)
        except Exception as e:  # pylint: disable=broad-except
            logger.warning(f'Revers port forwarding request failed {client_address}: connect error')
            return

        logger.debug(f'Revers port forwarding open: remote:{self._remote_port}({client_address[1]}) --SSH--> '
                     f'local:{self._local_port}')
        self.forward_socket_data(server_socket, client_socket)
        logger.debug(f'Revers port forwarding close: remote:{self._remote_port}({client_address[1]}) --SSH--> '
                     f'local:{self._local_port}')


# -------------------------------------------------------------------------------------------------
# Manager
class TunnelManager:

    def __init__(self, transport):
        self.__transport = transport
        self.__transport.logger.setLevel('CRITICAL')
        self.__tunnels = []

    def add_tunnel(self, local_port, remote_port):
        self.__tunnels.append(Tunnel(self.__transport, int(local_port), int(remote_port)))

    def add_reverse_tunnel(self, local_port, remote_port):
        self.__tunnels.append(RTunnel(self.__transport, int(local_port), int(remote_port)))

    def start(self):
        for t in self.__tunnels:
            t.start()

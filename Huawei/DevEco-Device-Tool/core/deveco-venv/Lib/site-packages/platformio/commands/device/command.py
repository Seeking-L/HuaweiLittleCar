# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
from fnmatch import fnmatch
import socket

import psutil
from os import environ
# noinspection PyPackageRequirements
import click
from serial.tools import miniterm

from platformio import exception, fs, util, serial_miniterm
from platformio.commands.device import helpers as device_helpers
from platformio.compat import dump_json_to_unicode
from platformio.managers.platform import PlatformFactory
from platformio.project.exception import NotPlatformIOProjectError
from platformio.commands.exception import PlatformioLowLevelError
from platformio.rpc.helpers import execute_remote_command


@click.group(short_help="Monitor device or list existing")
def cli():
    pass


@cli.command("list", short_help="List devices")
@click.option("--serial", is_flag=True, help="List serial ports, default")
@click.option("--logical", is_flag=True, help="List logical devices")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
# pylint: disable=too-many-branches
def device_list(serial, logical, json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    if not logical:
        serial = True
    data = {}
    if serial:
        data["serial"] = util.get_serial_ports()
    if logical:
        data["logical"] = util.get_logical_devices()

    single_key = list(data)[0] if len(list(data)) == 1 else None

    if json_output:
        return click.echo(
            dump_json_to_unicode(data[single_key] if single_key else data).encode("unicode-escape")
        )

    titles = {
        "serial": "Serial Ports",
        "logical": "Logical Devices",
        "mdns": "Multicast DNS Services",
    }

    for key, value in data.items():
        if not single_key:
            click.secho(titles[key], bold=True)
            click.echo("=" * len(titles[key]))

        if key == "serial":
            for item in value:
                click.secho(item["port"], fg="cyan")
                click.echo("-" * len(item["port"]))
                click.echo("Hardware ID: %s" % item["hwid"])
                click.echo("Description: %s" % item["description"])
                click.echo("")

        if key == "logical":
            for item in value:
                click.secho(item["path"], fg="cyan")
                click.echo("-" * len(item["path"]))
                click.echo("Name: %s" % item["name"])
                click.echo("")

        if key == "mdns":
            handle_mdns_key(value)

        if single_key:
            click.echo("")

    return True


def handle_mdns_key(value):
    for item in value:
        click.secho(item["name"], fg="cyan")
        click.echo("-" * len(item["name"]))
        click.echo("Type: %s" % item["type"])
        click.echo("IP: %s" % item["ip"])
        click.echo("Port: %s" % item["port"])
        if item["properties"]:
            click.echo(
                "Properties: %s"
                % (
                    "; ".join(
                        [
                            "%s=%s" % (k, v)
                            for k, v in item["properties"].items()
                        ]
                    )
                )
            )
        click.echo("")


@cli.command("monitor", short_help="Monitor device (Serial)")
@click.option("--port", "-p", help="Port, a number or a device name")
@click.option("--baud", "-b", type=int, help="Set baud rate, default=9600")
@click.option("--parity", default="N", type=click.Choice(["N", "E", "O", "S", "M"]), help="Set parity, default=N")
@click.option("--rtscts", is_flag=True, help="Enable RTS/CTS flow control, default=Off")
@click.option("--xonxoff", is_flag=True, help="Enable software flow control, default=Off")
@click.option("--rts", default=None, type=click.IntRange(0, 1), help="Set initial RTS line state")
@click.option("--dtr", default=None, type=click.IntRange(0, 1), help="Set initial DTR line state")
@click.option("--echo", is_flag=True, help="Enable local echo, default=Off")
@click.option("--encoding", default="UTF-8",
              help="Set the encoding for the serial port (e.g. hexlify, Latin1, UTF-8), default: UTF-8")
@click.option("--filter", "-f", multiple=True, help="Add filters/text transformations")
@click.option("--eol", type=click.Choice(["CR", "LF", "CRLF"]), help="End of line mode, default=CRLF")
@click.option("--raw", 'transformation', flag_value='raw', help="Do not apply any encodings/transformations")
@click.option("--no-raw", 'transformation', flag_value='no-raw',
              help="Apply implementation defined encodings/transformations")
@click.option("--exit-char", type=int, default=3,
              help="ASCII code of special character that is used to exit the application, default=3 (Ctrl+C)")
@click.option("--menu-char", type=int, default=20,
              help="ASCII code of special character that is used to control miniterm (menu), default=20 (DEC)")
@click.option("-d", "--project-dir", default=os.getcwd,
              type=click.Path(exists=True, file_okay=False, dir_okay=True, resolve_path=True))
@click.option("-e", "--environment", help="Load configuration from `deveco.ini` and specified environment")
@click.option("--force-local", is_flag=True, default=None)
def device_monitor(**kwargs):  # pylint: disable=too-many-branches,too-many-statements
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if kwargs.get('force_local') is None \
                    else kwargs.get('force_local')
    if not force_local:
        execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'],
                                      project_dir=kwargs.get("project_dir"),
                                      files=[os.path.join('.deveco', 'deveco.ini')] if 'project_dir' in kwargs else [])
        return

    kwargs.pop('force_local')
    # load default monitor filters
    filters_dir = os.path.join(fs.get_source_dir(), "commands", "device", "filters")
    for name in os.listdir(filters_dir):
        if not name.endswith(".py"):
            continue
        device_helpers.load_monitor_filter(os.path.join(filters_dir, name))

    project_options, kwargs = get_project_options(kwargs)

    platform = None
    if "platform" in project_options:
        with fs.cd(kwargs["project_dir"]):
            platform = PlatformFactory.newPlatform(project_options["platform"])
            device_helpers.register_platform_filters(
                platform, kwargs["project_dir"], kwargs["environment"]
            )

    update_kwargs(kwargs, project_options, platform)

    # override system argv with patched options
    sys.argv = ["monitor"] + device_helpers.options_to_argv(
        kwargs,
        project_options,
        ignore=("port", "baud", "rts", "dtr", "environment", "project_dir"),
    )

    try:
        serial_miniterm.main(
            default_port=kwargs["port"],
            default_baudrate=kwargs["baud"] or 9600,
            default_rts=kwargs["rts"],
            default_dtr=kwargs["dtr"],
        )
    except Exception as e:
        raise exception.MinitermException(e)


def get_project_options(kwargs):
    project_options = {}
    try:
        with fs.cd(kwargs["project_dir"]):
            project_options = device_helpers.get_project_options(kwargs["environment"])
        kwargs = device_helpers.apply_project_monitor_options(kwargs, project_options)
    except (NotADirectoryError, FileNotFoundError) as e:  # kwargs["project_dir"] is file or not exist
        NotPlatformIOProjectError(e)
    except (ValueError, KeyError, IndexError) as e:
        PlatformioLowLevelError(e)
    return project_options, kwargs


def update_kwargs_from_board(kwargs, platform, project_options):
    if platform and project_options and "board" in project_options:
        board = platform.get_boards(project_options["board"])
        if board and "monitor" in board.manifest:
            if not kwargs["baud"] and "speed" in board.manifest["monitor"]:
                kwargs["baud"] = int(board.manifest["monitor"]["speed"])
            if not kwargs["transformation"] and "raw" in board.manifest["monitor"]:
                kwargs["raw"] = board.manifest["monitor"]["raw"]
            if not kwargs["eol"] and "eol" in board.manifest["monitor"]:
                kwargs["eol"] = board.manifest["monitor"]["eol"]
            if not kwargs["port"] and "port" in board.manifest["monitor"]:
                kwargs["port"] = board.manifest["monitor"]["port"]


def update_kwargs(kwargs, project_options, platform):
    if not kwargs["port"]:
        kwargs["port"] = project_options.get('monitor_port', None)
    if not kwargs["port"]:
        kwargs["port"] = project_options.get('upload_port', None)

    update_kwargs_from_board(kwargs, platform, project_options)

    if not kwargs["eol"]:
        kwargs["eol"] = "CRLF"

    raw = kwargs.pop("transformation", None)
    if raw == 'raw':
        kwargs["raw"] = True

    if not kwargs["port"]:
        ports = util.get_serial_ports(filter_hwid=True)
        if len(ports) == 1:
            kwargs["port"] = ports[0]["port"]
        elif "platform" in project_options and "board" in project_options:
            board_hwids = device_helpers.get_board_hwids(
                kwargs["project_dir"], platform, project_options["board"],
            )
            handle_device_port(ports, board_hwids, kwargs)

    elif kwargs["port"] and ({"*", "?", "[", "]"} & set(kwargs["port"])):
        for item in util.get_serial_ports():
            if fnmatch(item["port"], kwargs["port"]):
                kwargs["port"] = item["port"]
                break


def handle_device_port(ports, board_hwids, kwargs):
    for item in ports:
        for hwid in board_hwids:
            hwid_str = ("%s:%s" % (hwid[0], hwid[1])).replace("0x", "")
            if hwid_str in item["hwid"]:
                kwargs["port"] = item["port"]
                break
        if kwargs["port"]:
            break


@cli.command("network-list")
@click.option("--json-output", is_flag=True)
@click.option("--force-local", is_flag=True, default=None)
def network_list(json_output, force_local):
    force_local = not environ.get('DEVECO_REMOTE_SERVER_PORT', False) if force_local is None else force_local
    if not force_local:
        return execute_remote_command(command=['hos'] + sys.argv[1:] + ['--force-local'], project_dir=None, files=[])

    netcard_info = []
    info = psutil.net_if_addrs()
    for v in info.values():
        for item in v:
            handle_net_msg(item, netcard_info)
    if json_output:
        return click.echo(dump_json_to_unicode(netcard_info))
    for item in netcard_info:
        click.secho('net_server_ip=', fg="green", nl=False)
        click.echo(item["hostip"], nl=False)
        click.secho('------net_client_mask=', fg="green", nl=False)
        click.echo(item["netmask"])
    return True


def handle_net_msg(item, netcard_info):
    link_local_subnet = "169.254."
    if item.family == socket.AF_INET and not item.address == "127.0.0.1":
        if not item.address.startswith(link_local_subnet):
            netmsg = {"hostip": item.address, "netmask": item.netmask}
            netcard_info.append(netmsg)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Copyright (c) Huawei Technologies Co., Ltd. 2021-2022 All rights reserved.

    CLI for OpenHarmony sources download using repo

    Date: 2022/5/19

"""

import os
import re
import click
import shutil
import subprocess
from os.path import (join, isfile, splitext, dirname, realpath)
from platformio.project.config import ProjectConfig
from platformio.proc import ByteBufferedAsyncPipe
from platformio.commands.dotting.helpers import TraceOperate, RepoTrace
from platformio.exception import ToolNotFound, InvalidRepoUrl
from platformio.commands.exception import RepoDownloadError
from platformio import util


class ClickByteOut(ByteBufferedAsyncPipe):
    def __init__(self):
        self.__str = []
        super().__init__(self.lambdaLine)

    def lambdaLine(self, line):
        click.echo(line, nl=False)
        self.__str.append(line)

    def str(self):
        return ''.join(self.__str)


@click.group(short_help="Repo tool")
def cli():
    pass


@cli.command('download', short_help="Repo download sources")
@click.option(
    '-d',
    '--project-dir',
    default=os.getcwd,
    type=click.Path(
        exists=True, file_okay=False, dir_okay=True, writable=True, resolve_path=True
    ),
)
def repo_download(project_dir):
    if not shutil.which('repo'):
        raise ToolNotFound('repo')
    if not shutil.which('curl'):
        raise ToolNotFound('curl')

    config = ProjectConfig.get_instance(
        join(project_dir, '.deveco', 'deveco.ini')
    )
    download_url = config.get('env', 'download_url', '')
    profile = config.get('env', 'download_profile', '')
    init_args = list(filter(None, download_url.split(' ')))
    if not init_args:
        raise InvalidRepoUrl()
 
    protocol = 'https' if 'https' in download_url else 'ssh'
    try:
        cp = subprocess.run(init_args)
        TraceOperate(RepoTrace).operate(
            'Repo', 'download', protocol, 'init', cp.returncode == 0)
        if cp.returncode != 0:
            raise RepoDownloadError(f'repo init failed. return code: {cp.returncode}')

        _prev_repo_sync(project_dir, profile)

        sync_args = ['repo', 'sync', '-c']
        cp = subprocess.run(sync_args)
        TraceOperate(RepoTrace).operate(
            'Repo', 'download', protocol, 'sync', cp.returncode == 0)
        if cp.returncode != 0:
            raise RepoDownloadError(f'repo sync failed. return code: {cp.returncode}')

        forall_args = ['repo', 'forall', '-c', 'git lfs pull']
        cp = subprocess.run(forall_args)
        TraceOperate(RepoTrace).operate(
            'Repo', 'download', protocol, 'git_lfs_pull', cp.returncode == 0)
        if cp.returncode != 0:
            raise RepoDownloadError(f'repo forall failed. return code: {cp.returncode}')
    except (KeyboardInterrupt, Exception) as e:
        _print_result_footer('failed')
        raise e

    _print_result_footer('succeed')


def _prev_repo_sync(project_dir, profile):
    if not profile:
        return
    src_default = join(project_dir, '.deveco', 'profile', 'default.xml')
    src_manifest = join(project_dir, '.deveco', 'profile', 'manifest.xml')
    des_default = join(project_dir, '.repo', 'manifests', 'default.xml')
    os.makedirs(dirname(des_default), exist_ok=True)
    if isfile(src_manifest):
        shutil.copyfile(src_manifest, des_default)
    elif isfile(src_default):
        shutil.copyfile(src_default, des_default)
    src_manifest = join(project_dir, '.deveco', 'profile', f'{splitext(profile)[0]}.xml')
    des_manifest = join(project_dir, '.repo', 'manifests', f'{splitext(profile)[0]}.xml')
    if isfile(src_manifest):
        shutil.copyfile(src_manifest, des_manifest)


def _get_base_info(bundle_data):
    bundle_data = bundle_data or {}
    product_company = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('productCompany', '')
    product_name = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('productName', '')
    board_company = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('boardCompany', '')
    board_name = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('boardName', '')
    ohos_version = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('ohosVersion', '')
    kernel = bundle_data.get('chipDefinition', {}).get('baseInfo', {}).get('kernel', '')
    match = re.match(r'.*-v?(\d+)\.', ohos_version)
    ohos_version = f'{match[1]}.x' if match else '1.x'
    return dict(
        product_company=product_company,
        product_name=product_name,
        board_company=board_company,
        board_name=board_name,
        ohos_version=ohos_version,
        kernel=kernel
    )


def _print_result_footer(result):
    result_map = {
        'failed': ('FAILED', 'red'),
        'succeed': ('SUCCESS', 'green'),
    }
    click.echo()
    util.print_labeled_bar('{}'.format(
        click.style(result_map.get(result)[0], fg=result_map.get(result)[1], bold=True)
    ))

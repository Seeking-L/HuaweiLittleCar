# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import platformio.compat
import platformio.proc
import platformio.util
import platformio.commands.debug.process.base
import platformio.commands.debug.exception
import platformio.commands.debug.initcfgs


class DebugServer(platformio.commands.debug.process.base.BaseProcess):
    def __init__(self, project_dir, env, variables, debug_options):
        super().__init__(project_dir=project_dir, env=env, variables=variables)
        self.debug_options = debug_options

    def run(self):
        self.generate_pio_init()
        self.debug_options = self.apply_variables(self.debug_options)
        server, server_executable = self._prepare_server_exec()
        env = self._prepare_server_path(server)
        if not server or not server_executable or not env:
            return -1

        if server.get("softreset_arguments"):
            args = [server_executable] + server["softreset_arguments"]
            self.echo('Execute softreset:', fg='cyan')
            self.echo(' '.join(args), fg='cyan')
            platformio.proc.exec_command(args,
                                         env=env, cwd=server["cwd"], stdin=None, stdout=None, stderr=None)

        self.debug_options["server"]["arguments"].extend(self.debug_options.get("extend_server_args", []))

        self.echo('Starting server:', fg='cyan')
        self.echo(' '.join([server_executable] + server["arguments"]), fg='cyan')
        result = platformio.proc.exec_command([server_executable] + server["arguments"],
                                              env=env, cwd=server["cwd"], stdin=None, stdout=None, stderr=None)
        return result['returncode']

    def _prepare_server_exec(self):
        server = self.debug_options.get("server", {})
        server_executable = server.get("executable")
        if not server or not server_executable:
            return None, None

        if server.get("cwd"):
            server_executable = os.path.join(server["cwd"], server_executable)

        sys_type = platformio.util.get_systype()
        if "windows" in sys_type and \
                not server_executable.endswith(".exe") and os.path.isfile(server_executable + ".exe"):
            server_executable = server_executable + ".exe"
        if not os.path.isfile(server_executable):
            server_executable = platformio.proc.where_is_program(server_executable)
        if not os.path.isfile(server_executable):
            raise platformio.commands.debug.exception.DebugInvalidOptionsError(
                f"Could not launch Debug Server '{server_executable}'. "
                f"Please check that it is installed and is included in a system PATH\n\n")
        return server, server_executable

    @staticmethod
    def _prepare_server_path(server):
        sys_type = platformio.util.get_systype()
        env = os.environ.copy()
        server_cwd = server and server.get("cwd")
        # prepend server "lib" folder to LD path
        if "windows" not in sys_type and server_cwd and os.path.isdir(os.path.join(server["cwd"], "lib")):
            ld_key = "DYLD_LIBRARY_PATH" if "darwin" in sys_type else "LD_LIBRARY_PATH"
            env[ld_key] = os.path.join(server["cwd"], "lib")
            if os.environ.get(ld_key):
                env[ld_key] = "%s:%s" % (env[ld_key], os.environ.get(ld_key))
        # prepend BIN to PATH
        if server_cwd and os.path.isdir(os.path.join(server["cwd"], "bin")):
            env["PATH"] = "%s%s%s" % (
                os.path.join(server["cwd"], "bin"),
                os.pathsep,
                os.environ.get("PATH", os.environ.get("Path", "")),
            )
        return env

    def get_launch_commands(self):
        # default GDB launch init commands depending on debug tool
        launch_commands = platformio.commands.debug.initcfgs.get_gdb_launchinit_config(self.debug_options).split("\n")
        if self.debug_options["init_launch_cmds"]:
            launch_commands = self.debug_options["init_launch_cmds"]
        launch_commands.extend(self.debug_options["extra_cmds"])

        if not any("define pio_reset_run_target" in cmd for cmd in launch_commands):
            launch_commands = [
                "define pio_reset_run_target",
                "   echo Warning! Undefined pio_reset_run_target command\\n",
                "   monitor reset",
                "end",
            ] + launch_commands

        if not any("define pio_reset_halt_target" in cmd for cmd in launch_commands):
            launch_commands = [
                "define pio_reset_halt_target",
                "   echo Warning! Undefined pio_reset_halt_target command\\n",
                "   monitor reset halt",
                "end",
            ] + launch_commands

        if not any("define pio_restart_target" in cmd for cmd in launch_commands):
            launch_commands += [
                "define pio_restart_target",
                "   pio_reset_halt_target",
                "end",
            ]

        launch_commands = [
            "echo debug_tool = %s\\n" % self.debug_options["tool"],
            "echo Initializing remote target...\\n",
        ] + launch_commands + [
            "echo Initialization completed\\n",
        ]
        return launch_commands

    def generate_pio_init(self):
        launch_commands = self.get_launch_commands()

        # default GDB attach init commands depending on debug tool
        attach_commands = platformio.commands.debug.initcfgs.get_gdb_attachinit_config(self.debug_options).split("\n")
        if self.debug_options["init_attach_cmds"]:
            attach_commands = self.debug_options["init_attach_cmds"]
        attach_commands.extend(self.debug_options["extra_cmds"])

        if not any("define pio_reset_run_target" in cmd for cmd in attach_commands):
            attach_commands = [
                "define pio_reset_run_target",
                "   echo Warning! Undefined pio_reset_run_target command\\n",
                "   monitor reset",
                "end",
            ] + attach_commands

        if not any("define pio_reset_halt_target" in cmd for cmd in attach_commands):
            attach_commands = [
                "define pio_reset_halt_target",
                "   echo Warning! Undefined pio_reset_halt_target command\\n",
                "   monitor reset halt",
                "end",
            ] + attach_commands

        if not any("define pio_restart_target" in cmd for cmd in attach_commands):
            attach_commands += [
                "define pio_restart_target",
                "   pio_reset_halt_target",
                "end",
            ]

        attach_commands = [
            "echo debug_tool = %s\\n" % self.debug_options["tool"],
            "echo Initializing remote target...\\n",
        ] + attach_commands + [
            "echo Initialization completed\\n",
        ]

        flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        os.fdopen(
            os.open(os.path.join(self.cache_dir, '.launchinit'), flags, 0o640),
            'w').write(
            "\n".join(self.apply_variables(launch_commands, variables={
                "DEBUG_PORT": "$CLIENT_PORT"})))
        os.fdopen(
            os.open(os.path.join(self.cache_dir, '.attachinit'), flags, 0o640),
            'w').write(
            "\n".join(self.apply_variables(attach_commands, variables={
                "DEBUG_PORT": "$CLIENT_PORT"})))

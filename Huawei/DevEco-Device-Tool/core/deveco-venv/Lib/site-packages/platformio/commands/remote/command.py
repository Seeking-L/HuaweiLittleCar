import os
import time
import select
import socket
import getpass
import asyncio
import paramiko
import sanic
import click
import platformio.helpers
import platformio.rpc.server
import platformio.logger
import platformio.commands.remote.tunnels
import platformio.commands.remote.handlers.session
import platformio.commands.remote.handlers.file_transfer
import platformio.commands.remote.handlers.execution
from platformio.commands.dotting.helpers import TraceOperate, RemoteTrace
from platformio.security.security import encrypt_msg, decrypt_msg
# noinspection PyPackageRequirements
from platformio.helpers import get_logger_config

@click.group(short_help="Deveco remote functions")
def cli():
    pass


@cli.command("connect", short_help="Connect to remote machine")
@click.option("--address", required=True, help='Address of remote SSH server')
@click.option("--port", default=22, help='Port for SSH connection. default = 22')
@click.option("--user", required=True, help='User for SSH connection')
@click.option("--password", default=None, help='Password for SSH connection. '
                                               'If is not set will be collected from DEVECO_SSH_PASSWORD env variable. '
                                               'If neither --password nor --key are set, stdin will be used.')
@click.option("--key", default=None, help='Key for SSH connection')
@click.option("--forward-tunnel", multiple=True, help='Add port forwarding in format local-port:remote-port')
@click.option("--reverse-tunnel", multiple=True, help='Add revers port forwarding in format local-port:remote-port')
@click.option("--start-server", default=False, is_flag=True, help='Start deveco operation server on remote machine')
@click.option("--server-port", default=None, help='Deveco operation server port')
# pylint: too-many-locals, too-many-branches ,too-many-statements
def connect(**kwargs):
    address = kwargs.get("address")
    port = kwargs.get("port")
    user = kwargs.get("user")
    password = kwargs.get("password")
    key = kwargs.get("key")
    forward_tunnel = kwargs.get("forward_tunnel")
    reverse_tunnel = kwargs.get("reverse_tunnel")
    start_server = kwargs.get("start_server")
    server_port = kwargs.get("server_port")

    # connect to remote machine
    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    if key is None and password is None:
        password = os.environ.get('DEVECO_SSH_PASSWORD', None)
        password = getpass.getpass() if password is None else password
        password = decrypt_msg(password)
    try:
        client.connect(hostname=address, port=port, username=user, key_filename=key, password=password,
                        allow_agent=False, look_for_keys=False,
                        disabled_algorithms=dict(keys=['ssh-rsa', 'ssh-dss'],
                                                 macs=["hmac-md5", "hmac-md5-96", "hmac-sha1-96", "hmac-sha1"]))
        click.secho(f'Connection to {address}:{port} established')
    except paramiko.ssh_exception.AuthenticationException as e:
        click.secho(f'Failed to authenticate on {address}:{port}')
        TraceOperate(RemoteTrace).operate('Remote', 'connect', False)
        raise click.exceptions.Exit(13) from e

    password = None
    # make port forwarding
    tunnels = []
    for x, revers in [(forward_tunnel, False), (reverse_tunnel, True)]:
        for t in x:
            tunnels.append({'revers': revers, 'ports': t.split(':', 1) if ':' in t else [t, t]})
    tunnel_manager = platformio.commands.remote.tunnels.TunnelManager(client.get_transport())
    for t in tunnels:
        if not t['revers']:
            tunnel_manager.add_tunnel(t['ports'][0], t['ports'][1])
        else:
            tunnel_manager.add_reverse_tunnel(t['ports'][0], t['ports'][1])
    tunnel_manager.start()
    click.secho('Tunnel manager start')

    # start server
    if start_server:
        channel_start_server(client, server_port)
    elif tunnels:
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            TraceOperate(RemoteTrace).operate('Remote', 'connect', False)
            click.secho('Aborted by user')

    click.secho('Close SSH client')
    client.close()


def channel_start_server(client, server_port):
    _, out, _ = client.exec_command('uname')
    remote_os = 'linux' if out.channel.recv_exit_status() == 0 and 'linux' in out.readline().lower() else 'windows'
    executable = platformio.helpers.get_remote_executable_path(remote_os)

    command = [executable, 'remote', 'operation-server']
    if server_port:
        command.extend(['--port', str(server_port)])

    # Start server
    click.secho('Starting remote operation server')
    click.secho(' '.join(command), fg='cyan')
    channel = client.get_transport().open_session()
    channel: paramiko.channel.Channel
    channel.get_pty()
    channel.exec_command(' '.join(command))
    read_channel_data(channel)
    channel.close()


def read_channel_data(channel):
    try:
        while not channel.exit_status_ready():
            r, _, _ = select.select([channel], [], [], 0.1)
            if channel in r:
                data = channel.recv(1024)
                click.secho(data.decode(), nl=False)
    except KeyboardInterrupt:
        TraceOperate(RemoteTrace).operate('Remote', 'connect', False)
        click.secho('Aborted by user')


@cli.command("operation-server", short_help="DevEco Remote operation server")
@click.option("--port", type=int, default=8100, help="HTTP port, default=8100")
@click.option("--auto-stop", is_flag=True, help="Stop server on last connection closed")
@click.option("--verbose", is_flag=True, help="Verbose mode")
def operation_server(port, auto_stop, verbose):
    host = '127.0.0.1'
    startup_time = time.time()
    server = sanic.Sanic('DevEco_remote_operation_server', configure_logging=False)
    logger = platformio.logger.Logger(**get_logger_config(), level='debug' if verbose else 'warning')

    # websocket-rpc
    handlers = platformio.rpc.server.HandlerManager(logger=logger)
    handlers.add_handler_class('session', platformio.commands.remote.handlers.session.Session)
    handlers.add_handler_class('file_transfer', platformio.commands.remote.handlers.file_transfer.FileTransfer)
    handlers.add_handler_class('execution', platformio.commands.remote.handlers.execution.Execution)
    rpc = platformio.rpc.server.RpcProtocol(handler_manager=handlers,
                                            auto_stop_delay=0 if auto_stop else None,
                                            logger=logger)
    server.add_websocket_route(uri='/wsrpc', handler=rpc.on_connected)

    async def notify_server_started():
        for _ in range(3):
            await asyncio.sleep(0.1)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(0.1)
            if s.connect_ex((host, port)) == 0:
                s.detach()
                click.secho(f'DevEco_remote_operation_server started on {host}:{port}')
                TraceOperate(RemoteTrace).operate('Remote', 'connect', True, time.time()-startup_time)
                break
        else:
            asyncio.get_event_loop().stop()
            rpc.exit_code = -1
            raise Exception(f'Server is not connectable on {host}:{port}')

    def _exception_handler(loop, context):
        click.secho(f'{context["exception"]}', fg='red')
        rpc.exit_code = context["exception"].errno if hasattr(context["exception"], 'errno') else -1
        loop.stop()

    server.add_task(notify_server_started())
    loop = asyncio.get_event_loop()
    # start
    asy_task = asyncio.ensure_future(server.create_server(host=host, port=port, return_asyncio_server=True))
    asy_server = loop.run_until_complete(asy_task)
    loop.run_until_complete(asy_server.startup())
    loop.run_until_complete(asy_server.before_start())
    loop.run_until_complete(asy_server.after_start())
    try:
        loop.set_exception_handler(_exception_handler)
        loop.run_forever()
    finally:
        rpc.close()
        loop.stop()
    TraceOperate(RemoteTrace).operate('Remote', 'connect', False)
    click.secho('DevEco_remote_operation_server stopped')
    if rpc.exit_code != 0:
        raise click.exceptions.Exit(rpc.exit_code)

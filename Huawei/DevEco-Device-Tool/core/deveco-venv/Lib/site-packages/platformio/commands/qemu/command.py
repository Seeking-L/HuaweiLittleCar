#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Copyright (c) Huawei Technologies Co., Ltd. 2021-2022 All rights reserved.

    CLI for OpenHarmony image download

    Date: 2022/4/24

"""

# pylint: disable=too-many-arguments

import os
import stat
import click
import requests
import io
import hashlib
import subprocess
from platformio.compat import dump_json_to_unicode
from platformio.unpacker import FileUnpacker
from platformio.util import get_systype
from platformio import fs, proc
from platformio.rpc.helpers import execute_remote_command
from platformio.helpers import get_executable_path, get_config_json_path
from platformio import proc
from platformio import exception
from platformio.util import read_url_json


LINUX_EMULATOR = "tools/qemu/qemu-linux-arm"
url = read_url_json().get('repo_getsdk_url', '')
ostype = "windows" if "windows" in get_systype() else "linux"
PROXY_URL = os.getenv("HTTP_PROXY", os.getenv("HTTPS_PROXY"))
PROXIES = {'http': PROXY_URL, 'https': PROXY_URL} if PROXY_URL else None


def _echo_stdout_line(line):
    click.secho(line, fg=None, nl=False)


def _echo_stderr_line(line):
    click.secho(line, fg="red", nl=False)


@click.group(short_help="Device Emulator helper")
def cli():
    pass


@cli.command("check_qemu_version", short_help="check Device Emulator version.")
@click.option("-p", "--emulator_path", required=True, help='Device Emulator relative path.')
@click.option("--is-remote", is_flag=True, help='is remote')
def check_emulator_version(emulator_path: str, is_remote: bool):
    """
    :emulator_path: Device Emulator relative path.
    :return: Device Emulator is exits and Device Emulator version
    """
    if is_remote:
        command = [get_executable_path(), "qemu", "check_qemu_version", "-p", emulator_path]
        return execute_remote_command(command, '', [])
    else:
        emulator_name = "qemu-windows-arm.exe" if "windows" in get_systype() else "qemu-linux-arm"
        emulator_abs_path = os.path.normpath(os.path.join(get_config_json_path(), emulator_path, emulator_name))
        result = {}
        if os.path.isfile(emulator_abs_path):
            result["exit"] = True
            cmd = [emulator_abs_path, "-version"]
            versionOut = proc.exec_command(cmd)
            if versionOut["returncode"] == 0:
                localVersion = versionOut["out"].split("\n")[0].split(" ").pop().replace("\r", "")
                result["localVersion"] = localVersion
        else:
            result["exit"] = False
            result["localVersion"] = ""
        # Latest version
        try:
            requestData = {"name": "emulator", "osType": ostype, "supportVersion": "1"}
            response = requests.post(url, data=requestData, proxies=PROXIES, verify=False, timeout=(5, 10))
            if response.status_code == 200:
                latestVersion = response.json().get("version")
                result["latestVersion"] = latestVersion
            else:
                result["latestVersion"] = ""
            result["code"] = True
            result['dist'] = emulator_abs_path
            return click.echo(dump_json_to_unicode(result))
        except requests.exceptions.ProxyError:
            return click.echo(dump_json_to_unicode({'code': False, 'msg': "request error:ProxyError"}))
        except requests.exceptions.ConnectionError:
            return click.echo(dump_json_to_unicode({'code': False, 'msg': "request error:ConnectionError"}))


@cli.command("get_latest_qemu", short_help="Get the latest version of the emulator")
@click.option("-d", "--dist", required=True, help='Emulator download path')
@click.option("--is-remote", is_flag=True, help='is remote')
def get_latest_emulator(dist: str, is_remote: bool):
    if is_remote:
        command = [get_executable_path(), "qemu", "get_latest_qemu", "-d", dist]
        return execute_remote_command(command, '', [])
    else:
        dist = os.path.normpath(os.path.join(get_config_json_path(), dist))
        if not os.path.isdir(dist):
            os.makedirs(dist)
        return handle_download_emulator(dist)


def handle_download_emulator(dist):
    try:
        requestData = {"name": "emulator", "osType": ostype, "supportVersion": "1"}
        response = requests.post(url, data=requestData, proxies=PROXIES, timeout=(5, 10), verify=False)
        responseOut = response.json().get("archive")
        latestUrl = responseOut.get("url")
        checksum = responseOut.get("checksum")
        fileName = os.path.basename(latestUrl)
        s = requests.Session()
        s.trust_env = False
        resp = s.get(latestUrl, timeout=3, proxies=PROXIES, stream=True, verify=False)
        itercontent = resp.iter_content(chunk_size=io.DEFAULT_BUFFER_SIZE)
        flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
        with os.fdopen(os.open(os.path.join(dist, fileName), flags, 0o640), "wb") as fp:
            for chunk in itercontent:
                fp.write(chunk)
        with open(os.path.join(dist, fileName), 'rb') as src_file:
            sha256 = hashlib.sha256()
            sha256.update(src_file.read())
            cal_value = sha256.hexdigest()
        if not cal_value == checksum:
            return click.echo(dump_json_to_unicode({'code': False, 'msg': "certificateError"}))
        with FileUnpacker(os.path.join(dist, fileName)) as f:
            f.unpack(dest_dir=dist, silent=True)
        return click.echo(dump_json_to_unicode({'code': True, 'msg': "emulatorDownloaded"}))
    except requests.exceptions.ProxyError:
        return click.echo(dump_json_to_unicode({'code': False, 'msg': "proxyError"}))
    except requests.exceptions.ConnectionError:
        return click.echo(dump_json_to_unicode({'code': False, 'msg': "connectionError"}))


def generate_init(project_dir, env, gdb_port):
    emulator_init = f"""
define pio_reset_halt_target
    monitor system_reset
end
define pio_reset_run_target
    monitor system_reset
end
target extended-remote :{gdb_port}"""

    launch_emulator = emulator_init + """
load
pio_reset_halt_target
tbreak main"""

    attach_emulator = emulator_init + """
tbreak main"""

    flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
    modes = stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH
    cache_dir = os.path.join(project_dir, '.deveco', '.debug-cache', env)
    os.makedirs(cache_dir, exist_ok=True)
    os.fdopen(
        os.open(os.path.join(cache_dir, '.launchinit'), flags, modes),
        'w').write(launch_emulator)
    os.fdopen(
        os.open(os.path.join(cache_dir, '.attachinit'), flags, modes),
        'w').write(attach_emulator)


def start_emulator(command):
    """ubuntu, command to start the Device Emulator
    """
    stdout = proc.LineBufferedAsyncPipe(line_callback=_echo_stdout_line)
    stderr = proc.LineBufferedAsyncPipe(line_callback=_echo_stderr_line)
    p = subprocess.Popen(command,
                         stdout=stdout, stderr=stderr, encoding="utf-8")
    rc = 1
    try:
        _, err = p.communicate(timeout=900)
        rc = p.returncode
    except KeyboardInterrupt as e:
        raise exception.AbortedByUser('Keyboard Interrupt') from e
    except subprocess.TimeoutExpired as e:
        raise exception.RunEmulatorTimeoutExpired() from e
    finally:
        stdout.close()
        stderr.close()
    if rc != 0:
        raise exception.RunEmulatorError()
    return rc


@cli.command("run")
@click.option("-d", "--project-dir", required=True, help="the project path")
@click.option("-i", "--image", required=True, multiple=True, help="the emulator image")
@click.option("--is-remote", is_flag=True, help='is remote')
@click.option("--environment", required=False, help='load configuration from `deveco.ini` and specified environment')
@click.option("--client-port", required=False, help='debug client port')
@click.option("--gdb-port", required=False, help='debug gdb port')
def run_emulator(**kwargs):  # pylint: disable=too-many-statements
    """
    Start the Device Emulator
    """
    project_dir = kwargs.get('project_dir')
    image = kwargs.get('image')
    is_remote = kwargs.get('is_remote')
    environment = kwargs.get('environment')
    client_port = kwargs.get('client_port')
    gdb_port = kwargs.get('gdb_port')

    command = [get_executable_path(), 'run', '--target', 'run']
    if client_port:
        if client_port == '*' or int(client_port) < 1220 or int(client_port) >= 1240:
            click.secho(f'client-port is {client_port}, it should be in 1220 ~ 1240! '
                        f'Please go to remote configuration and set valid debug port!', fg='red')
            return
        command.extend(['--client-port', client_port])
        generate_init(project_dir, environment, gdb_port)
    files = list(map(lambda x: os.path.join(project_dir, x), image))
    if not all([os.path.exists(f) for f in files]):
        click.echo("compile the image first.")
        return
    files.append(os.path.join(project_dir, '.deveco', "deveco.ini"))
    if is_remote:
        # on windows
        execute_remote_command(command=command, project_dir=project_dir, files=files)
        return
    else:
        command = [os.path.normpath(os.path.join(get_config_json_path(), LINUX_EMULATOR)),
                   '-machine', 'virt', '-img-path', project_dir]
        if client_port:
            command.extend(['--client-port', client_port])
            generate_init(project_dir, environment, gdb_port)
        start_emulator(command)

import os
import sys
import argparse

import serial
from serial.tools import miniterm


class ConsoleStdin(miniterm.ConsoleBase):
    """OS abstraction for console (input/output codec, no echo)"""

    def __init__(self):
        super().__init__()

    def getkey(self):
        return sys.stdin.read(1)


class SerialMiniterm(miniterm.Miniterm):

    def __init__(self, serial_instance, echo=False, eol='crlf', filters=()):
        self.console = miniterm.Console() if os.isatty(sys.stdin.fileno()) else ConsoleStdin()
        self.serial = serial_instance
        self.echo = echo
        self.raw = False
        self.input_encoding = 'UTF-8'
        self.output_encoding = 'UTF-8'
        self.eol = eol
        self.filters = filters
        self.update_transformations()
        self.exit_character = miniterm.unichr(0x1d)  # GS/CTRL+]
        self.menu_character = miniterm.unichr(0x14)  # Menu: CTRL+T
        self.alive = None
        self._reader_alive = None
        self.receiver_thread = None
        self.rx_decoder = None
        self.tx_decoder = None


def add_port_settings_group(group, default_rts, default_dtr):
    group.add_argument(
        '--parity',
        choices=['N', 'E', 'O', 'S', 'M'],
        type=lambda c: c.upper(),
        help='set parity, one of {N E O S M}, default: N',
        default='N')

    group.add_argument(
        '--rtscts',
        action='store_true',
        help='enable RTS/CTS flow control (default off)',
        default=False)

    group.add_argument(
        '--xonxoff',
        action='store_true',
        help='enable software flow control (default off)',
        default=False)

    group.add_argument(
        '--rts',
        type=int,
        help='set initial RTS line state (possible values: 0, 1)',
        default=default_rts)

    group.add_argument(
        '--dtr',
        type=int,
        help='set initial DTR line state (possible values: 0, 1)',
        default=default_dtr)

    group.add_argument(
        '--non-exclusive',
        dest='exclusive',
        action='store_false',
        help='disable locking for native ports',
        default=True)

    group.add_argument(
        '--ask',
        action='store_true',
        help='ask again for port when open fails',
        default=False)


def add_data_handling_group(group):
    group.add_argument(
        '-e', '--echo',
        action='store_true',
        help='enable local echo (default off)',
        default=False)

    group.add_argument(
        '--encoding',
        dest='serial_port_encoding',
        metavar='CODEC',
        help='set the encoding for the serial port (e.g. hexlify, Latin1, UTF-8), default: %(default)s',
        default='UTF-8')

    group.add_argument(
        '-f', '--filter',
        action='append',
        metavar='NAME',
        help='add text transformation',
        default=[])

    group.add_argument(
        '--eol',
        choices=['CR', 'LF', 'CRLF'],
        type=lambda c: c.upper(),
        help='end of line mode',
        default='CRLF')

    group.add_argument(
        '--raw',
        action='store_true',
        help='Do no apply any encodings/transformations',
        default=False)


def add_hotkeys_group(group):
    group.add_argument(
        '--exit-char',
        type=int,
        metavar='NUM',
        help='Unicode of special character that is used to exit the application, default: %(default)s',
        default=0x1d)  # GS/CTRL+]

    group.add_argument(
        '--menu-char',
        type=int,
        metavar='NUM',
        help='Unicode code of special character that is used to control miniterm (menu), default: %(default)s',
        default=0x14)  # Menu: CTRL+T


def add_diagnostics_group(group):
    group.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='suppress non-error messages',
        default=False)

    group.add_argument(
        '--develop',
        action='store_true',
        help='show Python traceback on error',
        default=False)


def set_parser(default_port, default_baudrate, default_rts, default_dtr):
    parser = argparse.ArgumentParser(
        description='Miniterm - A simple terminal program for the serial port.')

    parser.add_argument(
        'port',
        nargs='?',
        help='serial port name ("-" to show port list)',
        default=default_port)

    parser.add_argument(
        'baudrate',
        nargs='?',
        type=int,
        help='set baud rate, default: %(default)s',
        default=default_baudrate)

    group = parser.add_argument_group('port settings')
    add_port_settings_group(group, default_rts, default_dtr)

    group = parser.add_argument_group('data handling')
    add_data_handling_group(group)

    group = parser.add_argument_group('hotkeys')
    add_hotkeys_group(group)

    group = parser.add_argument_group('diagnostics')
    add_diagnostics_group(group)

    return parser

def show_help(args):
    if 'help' in args.filter:
        sys.stderr.write('Available filters:\n')
        sys.stderr.write('\n'.join(
            '{:<10} = {.__doc__}'.format(k, v)
            for k, v in sorted(miniterm.TRANSFORMATIONS.items())))
        sys.stderr.write('\n')
        sys.exit(1)


def set_args_port(args, parser):
    try:
        args.port = miniterm.ask_for_port()
    except KeyboardInterrupt:
        sys.stderr.write('\n')
        parser.error('user aborted and port is not given')
    else:
        if not args.port:
            parser.error('port is not given')

def open_serial_instance(args):
    serial_instance = serial.serial_for_url(
        args.port,
        args.baudrate,
        parity=args.parity,
        rtscts=args.rtscts,
        xonxoff=args.xonxoff,
        do_not_open=True)

    if not hasattr(serial_instance, 'cancel_read'):
        # enable timeout for alive flag polling if cancel_read is not available
        serial_instance.timeout = 1

    if args.dtr is not None:
        if not args.quiet:
            sys.stderr.write('--- forcing DTR {}\n'.format('active' if args.dtr else 'inactive'))
        serial_instance.dtr = args.dtr
    if args.rts is not None:
        if not args.quiet:
            sys.stderr.write('--- forcing RTS {}\n'.format('active' if args.rts else 'inactive'))
        serial_instance.rts = args.rts

    if isinstance(serial_instance, serial.Serial):
        serial_instance.exclusive = args.exclusive

    serial_instance.open()

    return serial_instance


def show_quiet(serial_miniterm):
    sys.stderr.write('--- Miniterm on {p.name}  {p.baudrate},{p.bytesize},{p.parity},{p.stopbits} ---\n'.format(
            p=serial_miniterm.serial))
    sys.stderr.write('--- Quit: {} | Menu: {} | Help: {} followed by {} ---\n'.format(
        miniterm.key_description(serial_miniterm.exit_character),
        miniterm.key_description(serial_miniterm.menu_character),
        miniterm.key_description(serial_miniterm.menu_character),
        miniterm.key_description('\x08')))
    sys.stderr.flush()


def main(default_port=None, default_baudrate=9600, default_rts=None, default_dtr=None):

    parser = set_parser(default_port, default_baudrate, default_rts, default_dtr)
    args = parser.parse_args()

    if args.menu_char == args.exit_char:
        parser.error('--exit-char can not be the same as --menu-char')

    if args.filter:
        show_help(args)
        filters = args.filter
    else:
        filters = ['default']

    while True:
        if not args.port:
            sys.stderr.write('\33[31m invalid serial port: empty\33[0m\n')
            sys.exit(1)
        try:
            serial_instance = open_serial_instance(args)
        except serial.SerialException as e:
            sys.stderr.write(f'\33[31m could not open port: {args.port} \33[0m\n')
            if args.develop:
                raise
            if not args.ask:
                sys.exit(1)
            else:
                args.port = '-'
        else:
            break

    serial_miniterm = SerialMiniterm(
        serial_instance,
        echo=args.echo,
        eol=args.eol.lower(),
        filters=filters)
    serial_miniterm.exit_character = miniterm.unichr(args.exit_char)
    serial_miniterm.menu_character = miniterm.unichr(args.menu_char)
    serial_miniterm.raw = args.raw
    serial_miniterm.set_rx_encoding(args.serial_port_encoding)
    serial_miniterm.set_tx_encoding(args.serial_port_encoding)

    if not args.quiet:
        show_quiet(serial_miniterm)

    serial_miniterm.start()
    try:
        serial_miniterm.join(True)
    except KeyboardInterrupt:
        pass
    if not args.quiet:
        sys.stderr.write('\n--- exit ---\n')
    serial_miniterm.join()
    serial_miniterm.close()

if __name__ == '__main__':
    main()

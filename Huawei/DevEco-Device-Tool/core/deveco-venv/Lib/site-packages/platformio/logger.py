#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
Description: Logs are rotated every day. The maximum size is 10 MB and can be stored for a maximum of seven days.
Create: 2022-07-05
"""

import os
import re
import time
import logging
from stat import ST_MTIME
from logging.handlers import BaseRotatingHandler


class TimeMaxBytesRotatingFileHandler(BaseRotatingHandler):  # pylint: disable=R0902
    def __init__(self, filename, maxBytes, when='D', backup_count=5):  # pylint: disable=R0913
        super().__init__(filename, 'a', encoding="utf8")
        self.when = when.upper()
        self.backup_count = backup_count
        if self.when == 'M':
            self.interval = 60  # one minute
            self.suffix = "%Y-%m-%d_%H-%M"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}(\.\w+)?$"
        elif self.when == 'H':
            self.interval = 60 * 60  # one hour
            self.suffix = "%Y-%m-%d_%H"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}(\.\w+)?$"
        elif self.when == 'D':
            self.interval = 60 * 60 * 24  # one day
            self.suffix = "%Y-%m-%d"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}(\.\w+)?$"
        else:
            raise ValueError("Invalid rollover interval specified: %s" % self.when)

        self.extMatch = re.compile(self.extMatch, re.ASCII)
        self.abs_file_name = filename  # Absolute path of log files
        if os.path.exists(filename):
            t = os.stat(filename)[ST_MTIME]
        else:
            t = int(time.time())
        self.rollover_type = 0
        self.maxBytes = maxBytes
        self.dir_name, self.base_file = os.path.split(self.abs_file_name)
        self.rollover_at = self.compute_rollover(self.belong_rollover(t))
        self.belong_at = time.strftime(self.suffix, time.localtime(self.belong_rollover(t)))

    def compute_rollover(self, current_time):
        """next rotation time"""
        result = current_time + self.interval
        return result

    def belong_rollover(self, current_time):
        """
        log ownership time
        """
        ts = time.localtime(current_time)
        current_hour = ts[3]
        current_minute = ts[4]
        current_second = ts[5]
        if self.when == "M":
            result = current_time - current_second
        elif self.when == "H":
            result = current_time - current_minute * 60 - current_second
        else:
            result = current_time - current_hour * 60 ** 2 - current_minute * 60 - current_second
        return result

    def should_rollover(self, record):
        """
        Determine if rollover should occur.
        """
        t = int(time.time())
        flag = 0
        if self.stream is None:
            self.stream = self._open()
        if self.maxBytes > 0:
            msg = "%s\n" % self.format(record)
            self.stream.seek(0, 2)
            if self.stream.tell() + len(msg) >= self.maxBytes:
                flag = 1  # do max bytes rollover
        if t >= self.rollover_at:
            flag = 2  # do time rollover
        return flag

    def do_time_rollover(self):
        """
        Do a rollover, by Time
        """
        if self.stream:
            self.stream.close()
            self.stream = None
        modify_ts = os.stat(self.abs_file_name)[ST_MTIME]  # obtains the last modification time of the deveco.log file.
        belong_at = time.strftime(self.suffix, time.localtime(self.belong_rollover(modify_ts))) # calculate belong at
        dest_file = os.path.join(self.dir_name, belong_at + ".1-" + self.base_file)
        if os.path.exists(dest_file):
            for i in range(self.backup_count - 1, 0, -1):
                source_file = os.path.join(self.dir_name, self.belong_at + ".%d-" % i + self.base_file)
                dest_file = os.path.join(self.dir_name, self.belong_at + ".%d-" % (i + 1) + self.base_file)
                self.file_rollover(source_file, dest_file)
            self.rotate(self.abs_file_name, dest_file)
        if not os.path.exists(dest_file) and os.stat(self.abs_file_name).st_size > 0:
            self.rotate(self.abs_file_name, dest_file)
        self.stream = self._open()
        current_time = int(time.time())
        new_rollover_at = self.compute_rollover(current_time)
        while new_rollover_at <= current_time:
            new_rollover_at = new_rollover_at + self.interval
        self.rollover_at = self.belong_rollover(new_rollover_at)
        self.belong_at = time.strftime(self.suffix, time.localtime(current_time))

    def file_rollover(self, source_file, target_file):
        if os.path.exists(source_file):
            if os.path.exists(target_file):
                os.remove(target_file)
            os.rename(source_file, target_file)

    def do_max_bytes_rollover(self):
        """
        Do a rollover, by maxBytes
        """
        if self.stream:
            self.stream.close()
            self.stream = None
        if self.backup_count > 0:
            for i in range(self.backup_count - 1, 0, -1):
                source_file = os.path.join(self.dir_name, self.belong_at + ".%d-" % i + self.base_file)
                dest_file = os.path.join(self.dir_name, self.belong_at + ".%d-" % (i + 1) + self.base_file)
                self.file_rollover(source_file, dest_file)
            dest_file = os.path.join(self.dir_name, self.belong_at + ".%d-" % 1 + self.base_file)
            if os.path.exists(dest_file):
                os.remove(dest_file)
            self.rotate(self.abs_file_name, dest_file)
        self.stream = self._open()

    def get_files_to_delete(self):
        """
         Determine the files to delete when rolling over.
         by file modification time
        """
        file_names = os.listdir(self.dir_name)
        result = []
        suffix = "-" + self.base_file
        plen = len(suffix)
        for file_name in file_names:
            if file_name[-plen:] == suffix:
                prefix = file_name[:-plen]
                if self.extMatch.match(prefix):
                    file = os.path.join(self.dir_name, file_name)
                    result.append((file, os.stat(file)[ST_MTIME]))
        if len(result) < self.backup_count:
            result = []
        else:
            result.sort(key=lambda x: x[1])
            result = result[:len(result) - self.backup_count]
        return result

    def handler_record_path_name(self, record):
        """Processes the pathname in the record object."""
        try:
            attribute_value = record.__getattribute__("pathname")
            record.__setattr__("pathname", os.path.join("platformio",
                                                        os.path.normpath(attribute_value).split('platformio')[-1][1:]))
        except AttributeError:  # pylint: disable=try-except-raise
            pass
        except TypeError:
            pass
        return record

    def emit(self, record):
        """emit record to file"""
        try:
            self.rollover_type = self.should_rollover(record)
            if self.rollover_type:
                if self.rollover_type == 1:
                    self.do_max_bytes_rollover()
                else:
                    self.do_time_rollover()
                for f, _ in self.get_files_to_delete():
                    os.remove(f)
            self.handler_record_path_name(record)
            logging.FileHandler.emit(self, record)
        except Exception:  # pylint: disable=broad-except
            ...


class Logger(logging.Logger):  # pylint: disable=too-many-instance-attributes
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50
    NOTSET = 0
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, file, when, backup_count, folder, max_bytes, formatter, level=None):
        # pylint: disable=too-many-arguments
        """
        :level: Log output level.
        :file: Log Output File Name.
        :when: Log recording period.
        :backup_count: Number of Logs Retained.
        :formatter: Log Record Format.
        :folder: Directory for storing log records.
        :max_bytes: Max bytes stored in log file.
        """
        if isinstance(level, str):
            level = {'debug': self.DEBUG,
                     'info': self.INFO,
                     'warning': self.WARNING,
                     'error': self.ERROR,
                     'critical': self.CRITICAL}.get(level.lower(), self.NOTSET)
        if level not in [self.DEBUG, self.INFO, self.WARNING, self.ERROR, self.CRITICAL]:
            level = self.NOTSET
        self.name = ""
        self.__level = level
        self.file = file
        self.folder = folder
        self.when = when
        self.max_bytes = max_bytes
        self.formatter = formatter
        self.backup_count = backup_count
        super().__init__(self.name, self.__level)
        self._set_file_handler()

    def _set_file_handler(self):
        """Set file output"""
        if not os.path.exists(self.folder):
            os.makedirs(self.folder)
        file_handler = TimeMaxBytesRotatingFileHandler(
            os.path.join(self.folder, self.file),
            maxBytes=self.max_bytes,
            when=self.when,
            backup_count=self.backup_count
        )
        file_handler.setFormatter(logging.Formatter(self.formatter))
        self.addHandler(file_handler)

    def log(self, level=None, msg=None, *args, **kwargs):  # pylint: disable=keyword-arg-before-vararg
        """
        Log 'msg % args' with the integer severity 'level'.
        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.
        logger.log(level, "We have a %s", "mysterious problem", exc_info=1)
        """
        if isinstance(level, str):
            level = {'debug': self.DEBUG,
                     'info': self.INFO,
                     'warning': self.WARNING,
                     'error': self.ERROR,
                     'critical': self.CRITICAL}.get(level.lower(), self.NOTSET)
        if self.isEnabledFor(self.__level if not level else level):
            self._log(self.__level if not level else level, msg, args, **kwargs)

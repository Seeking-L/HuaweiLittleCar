# Copyright (c) 2014-present PlatformIO <contact@platformio.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
import platform
import re
import json
import math
import socket
import click
import time
import requests
import random
import errno
from glob import glob
from functools import wraps
from contextlib import contextmanager
from pexpect.spawnbase import SpawnBase
from pexpect.exceptions import ExceptionPexpect


from platformio import __version__, exception
from platformio.compat import PY2, WINDOWS
from platformio.helpers import get_installed_core_path, url_to_domain
from platformio.proc import exec_command  # pylint: disable=unused-import
from platformio.security.trust_domain import TrustDomain

# KEEP unused imports for backward compatibility with DevEco Core 3.0 API


class memoized(object):
    def __init__(self, expire=0):
        expire_str = str(expire)
        if expire_str.isdigit():
            expire_str = "%ss" % int((int(expire_str) / 1000))
        tdmap = {"s": 1, "m": 60, "h": 3600, "d": 86400}
        if not expire_str.endswith(tuple(tdmap)):
            raise ValueError(f"{expire_str} not endswith {tuple(tdmap)}")
        self.expire = int(tdmap[expire_str[-1]] * int(expire_str[:-1]))
        self.cache = {}

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            key = str(args) + str(kwargs)
            if key not in self.cache or (
                    self.expire > 0 and self.cache[key][0] < time.time() - self.expire
            ):
                self.cache[key] = (time.time(), func(*args, **kwargs))
            return self.cache[key][1]

        wrapper.reset = self._reset
        return wrapper

    def _reset(self):
        self.cache.clear()


class cached():
    def __load_content(self):
        try:
            if os.path.exists(self.file):
                return json.load(open(self.file, 'rt'))
        except json.decoder.JSONDecodeError:
            pass
        return {}

    def __save_content(self, content):
        json.dump(content, open(self.file, 'wt'), indent=4)

    def __init__(self, expire=0):
        self.expire = memoized(expire=expire).expire
        self.file = os.path.abspath(os.path.join(get_installed_core_path(),
                                                 '.cache',
                                                 '.call-cached'))
        os.makedirs(os.path.dirname(self.file), exist_ok=True)

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                cache = {k: v for k, v in self.__load_content().items() if v['expire'] > time.time()}
            except (KeyError, TypeError):
                cache = {}
            key = f'{func.__module__}.{func.__qualname__}(args = {args}, kwargs = {kwargs})'
            if key not in cache:
                cache[key] = {}
                cache[key]['expire'] = time.time() + self.expire
                st = time.time()
                cache[key]['return'] = func(*args, **kwargs)
                cache[key]['spend'] = time.time() - st
                cache[key]['calls'] = 0

            cache[key]['calls'] += 1
            self.__save_content(cache)
            return cache[key]['return']

        return wrapper


class throttle(object):
    def __init__(self, threshhold):
        self.threshhold = threshhold  # milliseconds
        self.last = 0

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            diff = int(round((time.time() - self.last) * 1000))
            if diff < self.threshhold:
                time.sleep((self.threshhold - diff) * 0.001)
            self.last = time.time()
            return func(*args, **kwargs)

        return wrapper


class serialspawn(SpawnBase):
    def __init__(self, serial_port, args=None, timeout=30, maxread=2000, searchwindowsize=None,
                 logfile=None, encoding=None, codec_errors='strict'):

        self.args = None
        self.command = None
        super().__init__(timeout, maxread, searchwindowsize, logfile,
                           encoding=encoding, codec_errors=codec_errors)
        self.serial = serial_port
        self.serial.timeout = timeout
        self.own_fd = False
        self.closed = self.serial.is_open
        self.name = '<serial port %s>' % self.serial.port

    def close(self):
        self.flush()
        self.closed = True

    def isalive(self):
        '''This checks if the file descriptor is still valid. If :func:`os.fstat`
        does not raise an exception then we assume it is alive. 
        '''

        return self.serial.is_open

    def terminate(self, force=False):  # pragma: no cover
        '''Deprecated and invalid. Just raises an exception.'''
        raise ExceptionPexpect('This method is not valid for file descriptors.')

    # These four methods are left around for backwards compatibility, but not
    # documented as part of fdpexpect. You're encouraged to use os.write
    # directly.
    def send(self, s):
        "Write to fd, return number of bytes written"
        s = self._coerce_send_string(s)
        self._log(s, 'send')

        b = self._encoder.encode(s, final=False)
        return self.serial.write(b)

    def sendline(self, s):
        "Write to fd with trailing newline, return number of bytes written"
        s = self._coerce_send_string(s)
        return self.send(s + self.linesep)

    def write(self, s):
        "Write to fd, return None"
        self.send(s)

    def writelines(self, sequence):
        "Call self.write() for each item in sequence"
        for s in sequence:
            self.write(s)

    def read_nonblocking(self, size=1, timeout=-1):
        """
        Read from the file descriptor and return the result as a string.

        :param int size: Read at most *size* bytes.
        :param int timeout: Wait timeout seconds for file descriptor to be
        ready to read. When -1 (default), use self.timeout. When 0, poll.
        :return: String containing the bytes read
        """
        to_read = min(self.serial.in_waiting, size)
        data = self.serial.read(to_read)
        s = self._decoder.decode(data, final=False)
        self._log(s, 'read')
        return s


def singleton(cls):
    _instances = {}

    def get_instance(*args, **kwargs):
        if cls not in _instances:
            _instances[cls] = cls(*args, **kwargs)
        return _instances[cls]

    return get_instance


@contextmanager
def capture_std_streams(stdout, stderr=None):
    _stdout = sys.stdout
    _stderr = sys.stderr
    sys.stdout = stdout
    sys.stderr = stderr or stdout
    yield
    sys.stdout = _stdout
    sys.stderr = _stderr


def get_systype():
    type_ = platform.system().lower()
    arch = platform.machine().lower()
    if type_ == "windows":
        arch = "amd64" if platform.architecture()[0] == "64bit" else "x86"
    return "%s_%s" % (type_, arch) if arch else type_


def pioversion_to_intstr():
    vermatch = re.match(r"^([\d\.]+)", __version__)
    if not vermatch:
        raise ValueError("Regularity verification failed.")
    return [int(i) for i in vermatch.group(1).split(".")[:3]]


def change_filemtime(path, mtime):
    os.utime(path, (mtime, mtime))


def get_serial_ports(filter_hwid=False):
    try:
        # pylint: disable=import-outside-toplevel
        from serial.tools.list_ports import comports
    except ImportError as e:
        raise exception.GetSerialPortsError(os.name) from e

    result = []
    for p, d, h in comports():
        if not p:
            continue
        if WINDOWS and PY2:
            try:
                # pylint: disable=undefined-variable
                d = unicode(d, errors="ignore")
            except TypeError:
                pass
        if not filter_hwid or "VID:PID" in h:
            result.append({"port": p, "description": d, "hwid": h})

    if filter_hwid:
        return result

    # fix for PySerial
    if not result and "darwin" in get_systype():
        for p in glob("/dev/tty.*"):
            result.append({"port": p, "description": "n/a", "hwid": "n/a"})
    return result


# Backward compatibility for DevEco Core <3.5
get_serialports = get_serial_ports


def get_logical_devices():
    items = []
    if WINDOWS:
        try:
            result = exec_command(
                ["wmic", "logicaldisk", "get", "name,VolumeName"]
            ).get("out", "")
            devicenamere = re.compile(r"^([A-Z]{1}\:)\s*(\S+)?")
            return device_result(result, devicenamere)
        except WindowsError:  # pylint: disable=undefined-variable
            pass
        # try "fsutil"
        result = exec_command(["fsutil", "fsinfo", "drives"]).get("out", "")
        for device in re.findall(r"[A-Z]:\\", result):
            items.append({"path": device, "name": None})
        return items

    result = exec_command(["df"]).get("out")
    devicenamere = re.compile(r"^/.+\d+\%\s+([a-z\d\-_/]+)$", flags=re.I)
    for line in result.split("\n"):
        match = devicenamere.match(line.strip())
        if not match:
            continue
        items.append({"path": match.group(1), "name": os.path.basename(match.group(1))})
    return items


def device_result(result, devicenamere):
    items = []
    for line in result.split("\n"):
        match = devicenamere.match(line.strip())
        if not match:
            continue
        items.append({"path": match.group(1) + "\\", "name": match.group(2)})
    return items


@memoized(expire="60s")
def _api_request_session():
    return requests.Session()


@throttle(500)
def _get_api_result(url, params=None, data=None, auth=None):  # pylint: disable=unused-argument
    raise exception.InvalidNetworkAccessException()


def get_api_result(url, params=None, data=None, auth=None, cache_valid=None):  # pylint: disable=unused-argument
    raise exception.InvalidNetworkAccessException()


def read_url_json():
    url_define_path = os.path.join(get_installed_core_path(), 'core', 'tool_utils', 'url_define.json')
    with open(url_define_path, 'rt') as json_file:
        try:
            data = json.load(json_file)
            return data
        except json.JSONDecodeError as e:
            raise Exception(f'{json_file} parsing error!') from e


@memoized(expire="5s")
def _internet_on():
    remote_host = read_url_json().get('remote_host', {})
    github_ip = remote_host.get('github_ip', '')
    gitlab_ip = remote_host.get('gitlab_ip', '')
    platformio_ip = remote_host.get('platformio', '')
    github_com = remote_host.get('github_com', '')
    platformio_org = remote_host.get('platformio_org', '')
    PING_REMOTE_HOSTS = [
        github_ip,  # Github.com
        gitlab_ip,  # Gitlab.com
        platformio_ip,  # platformio.org
        github_com,  # "github.com"
        platformio_org,  # "platformio.org"
    ]
    timeout = 2
    socket.setdefaulttimeout(timeout)
    for host in PING_REMOTE_HOSTS:
        try:
            if os.getenv("HTTP_PROXY", os.getenv("HTTPS_PROXY")):
                requests.get("http://%s" % host, allow_redirects=False, timeout=timeout)
            else:
                socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, 80))
            return True
        except OSError:
            pass
        except Exception:  # pylint: disable=W0703
            ...
    return False


def internet_on(raise_exception=False):  # pylint: disable=unused-argument
    result = _internet_on()
    if raise_exception and not result:
        raise exception.InternetIsOffline()
    return result


def pepver_to_semver(pepver):
    return re.sub(r"(\.\d+)\.?(dev|a|b|rc|post)", r"\1-\2.", pepver, 1)


def items_to_list(items):
    if isinstance(items, list):
        return items
    return [i.strip() for i in items.split(",") if i.strip()]


def items_in_list(needle, haystack):
    needle = items_to_list(needle)
    haystack = items_to_list(haystack)
    if "*" in needle or "*" in haystack:
        return True
    return set(needle) & set(haystack)


def parse_date(datestr):
    if "T" in datestr and "Z" in datestr:
        return time.strptime(datestr, "%Y-%m-%dT%H:%M:%SZ")
    return time.strptime(datestr)


def merge_dicts(d1, d2, path=None):
    if path is None:
        path = []
    for key in d2:
        if key in d1 and isinstance(d1[key], dict) and isinstance(d2[key], dict):
            merge_dicts(d1[key], d2[key], path + [str(key)])
        else:
            d1[key] = d2[key]
    return d1


def print_labeled_bar(label, is_error=False, fg=None):
    terminal_width, _ = click.get_terminal_size()
    width = len(click.unstyle(label))
    half_line = "=" * int((terminal_width - width - 2) / 2)
    click.secho("%s %s %s" % (half_line, label, half_line), fg=fg, err=is_error)


def humanize_duration_time(duration):
    if duration is None:
        return duration
    duration = duration * 1000
    tokens = []
    for multiplier in (3600000, 60000, 1000, 1):
        fraction = math.floor(duration / multiplier)
        tokens.append(int(round(duration) if multiplier == 1 else fraction))
        duration -= fraction * multiplier
    return "{:02d}:{:02d}:{:02d}.{:03d}".format(*tokens)


def humanize_file_size(size):
    for unit in ['B', 'KiB', 'MiB', 'GiB', 'TiB']:
        if abs(size) < 1024.0:
            return "%3.1f%s" % (size, unit)
        size /= 1024.0
    return "%.1f%s" % (size, 'PiB')


def get_real_path(path):
    if path.strip() == '':
        return path
    if platform.system() == "Linux":
        path = path.replace("\\", "/")
    return os.path.realpath(path)


def get_original_version(version):
    if version.count(".") != 2:
        return None
    _, raw = version.split(".")[:2]
    if int(raw) <= 99:
        return None
    if int(raw) <= 9999:
        return "%s.%s" % (raw[:-2], int(raw[-2:]))
    return "%s.%s.%s" % (raw[:-4], int(raw[-4:-2]), int(raw[-2:]))


def is_port_in_use(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(0.1)
        try:
            s.bind(("127.0.0.1", port))
        except socket.error as e:
            return e.errno == errno.EADDRINUSE
    return False


def get_free_port(port_range):
    ports = list(range(port_range[0], port_range[1]))
    random.shuffle(ports)
    for p in ports:
        if not is_port_in_use(p):
            return p
    raise Exception(f'There is no free port in range {port_range}')


def get_home_url(url):
    config_url = read_url_json().get('home_url_config', {}).get(url, '')
    home_url = config_url if config_url else url
    current_domain =  url_to_domain(home_url)
    if current_domain not in TrustDomain.TRUST_DOMAIN:
        raise ValueError(f"Invalid value: {home_url}")
    return home_url

const {
  dataApi: { DependencyApi, TaskApi },
  addonEvent,
  http
} = window.top.HPM_CLI_UI

const dependencyApi = new DependencyApi();
const taskApi = new TaskApi();
const Library = window.HPM_DEPENDENCIES_D3_Library;
var startFlag = true;
addonEvent.subscribe('addonLoaded', async (info) => {
  taskApi.$getTaskStatus().subscribe(
    res => {
      startFlag = !startFlag;
      if (res && res.data && res.data.data.dependencies === 'normal' && startFlag) {
        http.get(`/resource/${info.name}/ui/data.json`).then((result) => render(result))
      }
    }
  )
  await taskApi.runTask('dependencies');
}, true);

addonEvent.subscribe('themeChange', data => {
  document.getElementsByTagName('html')[0].className = data.isDarkMode ? 'dark-mode' : ''
}, true)

const render = ((data) => {
  const { DOM } = new Library();

  const width = 1366;
  const height = 500;

  const sankey = () => {
    const sankey = d3.sankey()
      .nodeId(d => d.name)
      .nodeAlign(d3["sankeyLeft"])
      .nodeWidth(15)
      .nodePadding(10)
      .extent([[1, 5], [width - 1, height - 5]]);
    const { nodes, links } = data;
    return sankey({
      nodes: nodes.map(d => Object.assign({}, d)),
      links: links.map(d => Object.assign({}, d))
    });
  }

  const genColor = d3.scaleOrdinal(d3.schemeCategory10);

  const color = (d) => {
    const publishAs = d.publishAs;
    let color = "#999";
    if (publishAs === "source") {
      color = "#51A8F9";
    } else if (publishAs === "binary") {
      color = "#71BF40";
    } else if (publishAs === "distribution") {
      color = "#EC5D57";
    } else if (publishAs === "code-segment") {
      color = "#F49013";
    }
    return color;
  }

  const svg = d3.create("svg")
    .attr("viewBox", [0, 0, width, height]);

  const { nodes, links } = sankey(data);
  svg.append("rect")
    .attr("width", "100%")
    .attr("height", "100%")
    .attr("fill", "white");
  svg.append("g")
    .attr("stroke", "#000")
    .selectAll("rect")
    .data(nodes)
    .join("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("height", d => d.y1 - d.y0)
    .attr("width", d => d.x1 - d.x0)
    .attr("fill", (d) => color(d))
    .attr("class", d => d.isOptional ? "optional" : "")
    .append("title")
    .text(d => "publishAs: " + d.publishAs + "\\n" + "isOptional: " + d.isOptional);

  const link = svg.append("g")
    .attr("fill", "none")
    .attr("stroke-opacity", 0.5)
    .selectAll("g")
    .data(links)
    .join("g")
    .style("mix-blend-mode", "multiply");

  const edgeColor = "path";

  if (edgeColor === "path") {
    const gradient = link.append("linearGradient")
      .attr("id", d => (d.uid = DOM.uid("link")).id)
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("x1", d => d.source.x1)
      .attr("x2", d => d.target.x0);

    gradient.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", d => color(d.source));

    gradient.append("stop")
      .attr("offset", "100%")
      .attr("stop-color", d => color(d.target));
  }

  link.append("path")
    .attr("d", d3.sankeyLinkHorizontal())
    .attr("stroke", d => edgeColor === "none" ? "#aaa"
      : edgeColor === "path" ? d.uid
        : edgeColor === "input" ? color(d.source)
          : color(d.target))
    .attr("stroke-width", d => Math.max(1, d.width));

  link.append("title")
    .text(d => d.source.name + " â†’ " + d.target.name);

  svg.append("g")
    .attr("font-family", "sans-serif")
    .attr("font-size", 10)
    .selectAll("text")
    .data(nodes)
    .join("text")
    .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
    .attr("y", d => (d.y1 + d.y0) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
    .text(d => d.name + " (" + d.version + ")");

  const svgNode = svg.node();

  const rootDom = document.getElementById("root");
  rootDom.appendChild(svgNode);
});
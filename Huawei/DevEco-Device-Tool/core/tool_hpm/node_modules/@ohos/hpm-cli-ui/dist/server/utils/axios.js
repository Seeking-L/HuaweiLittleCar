"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldProxy = shouldProxy;

var Axios = require('axios');

var url = require('url');

var https = require('https');

var HttpsProxyAgent = require('https-proxy-agent');

var _require = require('./utils'),
    getUuid = _require.getUuid;

var axios = Axios.create({
  proxy: false
});
axios.interceptors.request.use(function (config) {
  var proxySettings = getProxySettings(config.url);
  Object.keys(proxySettings).forEach(function (key) {
    config[key] = proxySettings[key];
  });

  if (config.method === 'get' && config.params) {
    var keys = Object.keys(config.params);
    config.url += '?';
    keys.forEach(function (key) {
      config.url += "".concat(key, "=").concat(encodeURIComponent(config.params[key]), "&");
    });
    config.params = {};
  }

  if (config.method.toLowerCase() !== 'get') {
    config.headers['x-replay-context'] = "".concat(new Date().getTime(), ":").concat(getUuid());
  }

  return config;
});
axios.interceptors.response.use(function (res) {
  var data = res.data;

  if (data.code && data.code !== 200 && data.code !== 302) {
    throw data;
  }

  return data;
});

function getProxySettings(visitingUrl) {
  // eslint-disable-next-line
  var visitingUrlParsed = url.parse(visitingUrl);
  var isStrictSsl = process.env.strictSsl === 'true';
  var noProxy = process.env.no_proxy || process.env.NO_PROXY;

  if (!shouldProxy(noProxy, visitingUrlParsed.hostname)) {
    return {
      httpsAgent: new https.Agent({
        rejectUnauthorized: isStrictSsl
      })
    };
  }

  if (!isStrictSsl) {
    process.removeAllListeners('warning');
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;
  }

  var httpsAgent;
  var httpAgent;
  var httpsProxy = process.env.https_proxy || process.env.HTTPS_PROXY;
  var httpProxy = process.env.http_proxy || process.env.HTTP_PROXY;

  if (httpsProxy) {
    var httpsProxyParsed = parseProxyUrl(decodeURIComponent(httpsProxy)); // eslint-disable-next-line

    var opts = url.parse(httpsProxyParsed.proxypath);

    if (httpsProxyParsed.auth) {
      opts.auth = httpsProxyParsed.auth;
    }

    httpsAgent = new HttpsProxyAgent(opts);
  }

  if (httpProxy) {
    var httpProxyParsed = parseProxyUrl(decodeURIComponent(httpProxy)); // eslint-disable-next-line

    var _opts = url.parse(httpProxyParsed.proxypath);

    _opts.protocol = 'http';

    if (httpProxyParsed.auth) {
      _opts.auth = httpProxyParsed.auth;
    }

    httpAgent = new HttpsProxyAgent(_opts);
  }

  return {
    httpsAgent: httpsAgent,
    httpAgent: httpAgent
  };
}

function parseProxyUrl(proxyUrl) {
  var withAuthParsed = /(https:\/\/|http:\/\/)([\s\S]+)@([\s\S]+)/g.exec(proxyUrl);
  var proxypath;
  var auth;

  if (withAuthParsed) {
    if (withAuthParsed.length !== 4) {
      console.log('request.proxyFormat');
    } else {
      auth = withAuthParsed[2];
      proxypath = "".concat(withAuthParsed[1]).concat(withAuthParsed[3]);
    }
  } else {
    proxypath = proxyUrl;
  }

  return {
    proxypath: proxypath,
    auth: auth
  };
}

function shouldProxy(noProxy, hostname) {
  if (!noProxy) {
    return true;
  }

  var noProxyArr = noProxy.split(',').map(function (s) {
    return s.trim();
  });
  var should = !noProxyArr.some(function (proxyElement) {
    if (!proxyElement) {
      return false;
    }

    if (proxyElement === '*') {
      return true;
    }

    if (proxyElement[0] === '.' && hostname.substr(hostname.length - proxyElement.length) === proxyElement) {
      return true;
    }

    if (proxyElement[0] === '*' && hostname.substr(hostname.length - proxyElement.length + 1) === proxyElement.substr(1)) {
      return true;
    }

    return hostname === proxyElement;
  });
  return should;
}

module.exports = axios; // export { axios };
// export default axios;
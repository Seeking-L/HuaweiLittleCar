"use strict";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var _require = require('../utils/constant'),
    TaskType = _require.TaskType;

var _require2 = require('../utils/utils'),
    getGlobalItem = _require2.getGlobalItem;

var Task = /*#__PURE__*/function () {
  function Task(json) {
    _classCallCheck(this, Task);

    this.fromJson(json);
  }

  _createClass(Task, [{
    key: "fromJson",
    value: function fromJson() {
      var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.name = json.name;
      this.value = json.value;
      this.description = json.description || '';
      this.type = json.type;
      this.options = json.options || null;
      this.args = json.args || null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        value: this.value,
        type: this.type,
        description: this.description,
        options: this.options,
        args: this.args
      };
    }
  }, {
    key: "getCmd",
    value: function getCmd() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      switch (this.type) {
        case TaskType.cmd:
        case TaskType.plugin:
          return "hpm ".concat(this.name, " ").concat(options);

        default:
          return "hpm run ".concat(this.name, " ").concat(options);
      }
    }
  }]);

  return Task;
}();

var _tasks = /*#__PURE__*/new WeakMap();

var TaskList = /*#__PURE__*/function () {
  function TaskList() {
    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TaskList);

    _classPrivateFieldInitSpec(this, _tasks, {
      writable: true,
      value: []
    });

    var _json$scripts = json.scripts,
        scripts = _json$scripts === void 0 ? {} : _json$scripts,
        publishAs = json.publishAs;
    var api = getGlobalItem('api');
    var pluginsCmd = api.getCmdPlugins();
    var defaultCmdTasks = api.getDefaultCmds(publishAs).map(function (task) {
      if (['dist', 'build'].includes(task.name)) {
        task.value = scripts[task.name];
      }

      task.type = TaskType.cmd;
      return task;
    });
    var pluginsTasks = Object.keys(pluginsCmd).filter(function (name) {
      return pluginsCmd[name].isUiTask;
    }).map(function (name) {
      var plugin = pluginsCmd[name];
      var _plugin$options = plugin.options,
          description = _plugin$options.description,
          options = _plugin$options.options,
          args = _plugin$options.args;
      return {
        name: name,
        value: "".concat(name),
        description: description,
        type: TaskType.plugin,
        options: options,
        args: args
      };
    });
    var bundleTasks = Object.keys(scripts).map(function (name) {
      return {
        name: name,
        value: scripts[name],
        type: TaskType.script
      };
    });
    var allTasks = defaultCmdTasks.concat(bundleTasks).concat(pluginsTasks);

    _classPrivateFieldSet(this, _tasks, allTasks.reduce(function (tasks, task, index) {
      if (allTasks.findIndex(function (_ref) {
        var name = _ref.name;
        return name === task.name;
      }) === index) {
        tasks.push(new Task(task));
      }

      return tasks;
    }, []));
  }

  _createClass(TaskList, [{
    key: "getTasks",
    value: function getTasks() {
      var repeatTask = _classPrivateFieldGet(this, _tasks).find(function (task, index, tasks) {
        return tasks.findIndex(function (taskTemp) {
          return taskTemp.name === task.name;
        }) !== index;
      });

      if (repeatTask) {
        throw new Error("same task name \"".concat(repeatTask.name, "\" is not allow, check plugins and bundle scripts"));
      }

      return _classPrivateFieldGet(this, _tasks);
    }
  }]);

  return TaskList;
}();

module.exports = {
  TaskList: TaskList
};
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('../utils/utils'),
    runCmd = _require.runCmd,
    taskStop = _require.taskStop;

var _require2 = require('events'),
    EventEmitter = _require2.EventEmitter;

var TaskService = /*#__PURE__*/function () {
  function TaskService() {
    var _this = this;

    _classCallCheck(this, TaskService);

    _defineProperty(this, "addStatusListener", function (wsContext) {
      _this.statusListener = function () {
        try {
          var data = {};
          Object.keys(_this.tasks).forEach(function (taskName) {
            data[taskName] = _this.tasks[taskName].status;
          });
          wsContext.send({
            data: data
          });
        } catch (err) {
          console.log('statusListenerError', err);
        }
      };

      _this.event.addListener('statusChange', _this.statusListener);
    });

    _defineProperty(this, "removeStatusListener", function () {
      if (_this.statusListener) {
        _this.event.removeListener('statusChange', _this.statusListener);
      } else {
        _this.event.removeAllListener('statusChange');
      }
    });

    _defineProperty(this, "addListener", function (taskName, wsContext) {
      var task = _this.getTask(taskName);

      task.wsContext = wsContext;

      if (!task.logs || !(task.logs instanceof Array)) {
        task.logs = [];
      }

      task.logs.forEach(function (log, index) {
        task.wsContext.send({
          data: {
            text: log,
            index: index
          }
        });
      });
    });

    _defineProperty(this, "run", function (name, options) {
      var task = _this.getTask(name);

      if (task) {
        if (task.status === 'running') {
          return Promise.reject(new Error("Task ".concat(name, " already running")));
        }

        task.logs = [];
        var cmd = task.task.getCmd(options);

        _this.addLogToTask(name, "HPM_UI: Start run \"".concat(cmd, "\""));

        return runCmd(cmd).then(function (taskProcess) {
          _this.addLogToTask(name, "pid: ".concat(taskProcess.pid));

          task.taskProcess = taskProcess;
          task.status = 'running';

          _this.event.emit('statusChange');

          var stdout = taskProcess.stdout,
              stderr = taskProcess.stderr;
          stdout.on('data', function (data) {
            _this.addLogToTask(name, data.toString());
          });
          stderr.on('data', function (data) {
            _this.addLogToTask(name, data.toString());
          });
          taskProcess.on('exit', function (code) {
            var task = _this.getTask(name);

            if (task.wsContext) {
              task.wsContext.done();
            }

            task.status = 'normal';

            _this.event.emit('statusChange');
          });
          taskProcess.on('close', function (code) {
            var task = _this.getTask(name);

            if (task.wsContext) {
              task.wsContext.done();
            }

            task.status = 'normal';

            _this.event.emit('statusChange');
          });
        }).catch(function (err) {
          var task = _this.getTask(name);

          if (task.wsContext) {
            task.wsContext.error(err);
          }

          throw err;
        });
      } else {
        return Promise.reject(new Error("no task match \"".concat(name, "\"")));
      }
    });

    this.init();
    this.event = new EventEmitter();
  }

  _createClass(TaskService, [{
    key: "init",
    value: function init() {
      this.tasks = {};
      this.defaultTaskInfo = {
        status: 'normal',
        logs: [],
        taskProcess: null,
        wsContext: null
      };
    }
  }, {
    key: "getTask",
    value: function getTask(name) {
      if (this.tasks[name]) {
        return this.tasks[name];
      } else {
        return this.defaultTaskInfo;
      }
    }
  }, {
    key: "addLogToTask",
    value: function addLogToTask(taskName, log) {
      var task = this.getTask(taskName);
      task.logs.push(log);

      if (task.wsContext) {
        task.wsContext.send({
          data: {
            text: log,
            index: task.logs.length - 1
          }
        });
      }
    }
  }, {
    key: "removeListener",
    value: function removeListener(taskName) {
      var task = this.getTask(taskName);
      task.wsContext = null;
    }
  }, {
    key: "setTasks",
    value: function setTasks(tasks) {
      var _this2 = this;

      tasks.forEach(function (task) {
        var pretask = _this2.tasks[task.name];

        if (!pretask) {
          _this2.tasks[task.name] = _objectSpread(_objectSpread({}, _this2.defaultTaskInfo), {}, {
            task: task
          });
        } else if (pretask.task.value !== task.value) {
          _this2.tasks[task.name] = _objectSpread(_objectSpread({}, _this2.defaultTaskInfo), {}, {
            task: task
          });
        }
      });
    }
  }, {
    key: "stop",
    value: function stop(name) {
      var task = this.getTask(name);

      if (task && task.taskProcess && !task.taskProcess.killed && task.status === 'running') {
        this.addLogToTask(name, "stop task \"".concat(name, "\" \n pid: ").concat(task.taskProcess.pid, "\uFF0C").concat(task.taskProcess.pid + 1));
        return taskStop(task.taskProcess.pid);
      }

      return Promise.resolve(0);
    }
  }, {
    key: "clearlog",
    value: function clearlog(name) {
      var task = this.getTask(name);

      if (task.logs) {
        task.logs = [];
      }
    }
  }, {
    key: "removeTask",
    value: function removeTask(name) {
      delete this.tasks[name];
    }
  }]);

  return TaskService;
}();

var taskService = new TaskService();
module.exports = taskService;
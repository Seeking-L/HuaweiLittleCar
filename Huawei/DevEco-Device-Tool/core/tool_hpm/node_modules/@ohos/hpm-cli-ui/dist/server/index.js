"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var appEvent = require('./event');

var path = require('path');

var Logger = require('./logger');

var _require = require('./utils/utils'),
    openBrowser = _require.openBrowser,
    normalizePort = _require.normalizePort,
    setGlobalItem = _require.setGlobalItem,
    printMessage = _require.printMessage,
    myHost = _require.myHost;

function startUp(hpmApi) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  setGlobalItem('api', hpmApi);
  setGlobalItem('cwd', process.cwd());

  var Wss = require('./socket/wss');

  var http = require('http');

  var createError = require('http-errors');

  var express = require('express');

  var cookieParser = require('cookie-parser');

  var logger = require('morgan');

  var config = require('./routes/config');

  var workspace = require('./routes/workspace');

  var tasks = require('./routes/tasks');

  var dependencies = require('./routes/dependencies');

  var plugins = require('./routes/plugins');

  var project = require('./routes/project');

  var template = require('./routes/template');

  var hpm = require('./routes/hpm');

  var search = require('./routes/search');

  var readme = require('./routes/readme');

  var custom = require('./routes/custom');

  var trace = require('./routes/trace');

  var port = normalizePort(process.env.PORT || (args.length > 0 ? args[0].port : undefined)) || 0;
  var app = express();

  try {
    /**
       * Module dependencies.
       */
    var _Logger = new Logger(),
        logStream = _Logger.logStream,
        requestErrorStream = _Logger.requestErrorStream;

    app.use(express.json());
    app.use(express.urlencoded({
      extended: false
    }));
    app.use(cookieParser());
    app.use('/api/config', config);
    app.use('/api/workspace', workspace);
    app.use('/api/tasks', tasks);
    app.use('/api/dependencies', dependencies);
    app.use('/api/plugins', plugins);
    app.use('/api/project', project);
    app.use('/api/template', template);
    app.use('/api/hpm', hpm);
    app.use('/api/search', search);
    app.use('/api/readme', readme);
    app.use('/api/custom', custom);
    app.use('/api/trace', trace);
    appEvent.on('routerRefresh', function (_ref) {
      var routes = _ref.routes,
          routePath = _ref.routePath,
          routeId = _ref.routeId;
      app._router.stack = app._router.stack.filter(function (item) {
        return item._routeId !== routeId;
      });
      app.use("/api".concat(routePath), routes);

      var stack = app._router.stack.filter(function (item) {
        return item._routeId !== routeId;
      });

      var firstRouterIndex = stack.findIndex(function (item) {
        return item.name === 'router';
      });
      var routerServers = stack.filter(function (item, index) {
        return index > firstRouterIndex && item.name === 'router';
      });
      var newStatic = routerServers[routerServers.length - 1];

      if (newStatic) {
        newStatic._routeId = routeId;
      }

      var otherServer = stack.filter(function (item, index) {
        return index === firstRouterIndex || item.name !== 'router';
      });
      otherServer.splice.apply(otherServer, [firstRouterIndex + 1, 0].concat(_toConsumableArray(routerServers)));
      app._router.stack = otherServer;
    });
    appEvent.on('routerUninstall', function (_ref2) {
      var _routeId = _ref2._routeId;
      var routeIds = [];

      if (Array.isArray(_routeId)) {
        routeIds = _toConsumableArray(_routeId);
      } else {
        routeIds.push(_routeId);
      }

      app._router.stack = app._router.stack.filter(function (item) {
        return !routeIds.includes(item._routeId);
      });
    }); //  注册插件上的路由

    var registerPluginRouter = require('./pluginRouter');

    registerPluginRouter();
    var staticPath = path.join(__dirname, '..');
    app.use(express.static(staticPath));
    /**
     * Create HTTP server.
     */
    // catch 404 and forward to error handler

    app.use(function (req, res, next) {
      next(createError(404));
    }); // error handler

    app.use(function (err, req, res, next) {
      // set locals, only providing error in development
      var message = err.message || err;
      res.locals.message = message;
      res.locals.error = err; // render the error page
      // res.status(err.status || 500);

      res.needLog = true;
      var errResult = {
        code: 500,
        message: message
      };
      logStream.write("\n[".concat(req.method, "] : ").concat(req.url, "\n").concat(JSON.stringify(errResult, null, 4), "\n"));
      res.send(errResult);
      next();
    });
    app.use(logger('combined', {
      skip: function skip(req, res) {
        return res.statusCode < 400 || !res.needLog;
      },
      stream: requestErrorStream
    }));
    var server = http.createServer(app);
    new Wss(server); // eslint-disable-line

    /**
     * Listen on provided port, on all network interfaces.
     */

    server.listen(port, function () {
      var usingPort = server.address().port;
      var ipAddr = myHost;
      var url = "http://localhost:".concat(usingPort);
      var urlIp = "http://".concat(ipAddr, ":").concat(usingPort);
      printMessage("Ready on:\n- Local:   ".concat(url, "\n- Network: ").concat(urlIp));

      if (!args[0].daemon) {
        openBrowser(url).catch(function () {
          printMessage("Failed to automatically open ".concat(url, ". Please manually open it."));
        });
      }
    });
    process.on('uncaughtException', onError);
  } catch (error) {
    console.error(error);
  }
  /**
   * Event listener for HTTP server "error" event
   */


  function onError(error) {
    if (error.syscall !== 'listen') {
      throw error;
    }

    var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port; // handle specific listen errors with friendly messages

    switch (error.code) {
      case 'EACCES':
        console.error();
        printMessage("".concat(bind, " requires elevated privileges"));
        process.exit(1);

      case 'EADDRINUSE':
        printMessage("".concat(bind, " is already in use"));
        process.exit(1);

      default:
        throw error;
    }
  }

  appEvent.on('assetAdd', function (_ref3) {
    var routePath = _ref3.routePath,
        staticPath = _ref3.staticPath,
        id = _ref3.id;
    app._router.stack = app._router.stack.filter(function (item) {
      return item._id !== id;
    });
    app.use(routePath, express.static(staticPath));

    var stack = app._router.stack.filter(function (item) {
      return item._id !== id;
    });

    var firstStaticIndex = stack.findIndex(function (item) {
      return item.name === 'serveStatic';
    });
    var staticServers = stack.filter(function (item, index) {
      return index > firstStaticIndex && item.name === 'serveStatic';
    });
    var newStatic = staticServers[staticServers.length - 1];

    if (newStatic) {
      newStatic._id = id;
    }

    var otherServer = stack.filter(function (item, index) {
      return item.name !== 'serveStatic' || index === firstStaticIndex;
    });
    otherServer.splice.apply(otherServer, [firstStaticIndex + 1, 0].concat(_toConsumableArray(staticServers)));
    app._router.stack = otherServer;
  });
  appEvent.on('assetAdds', function (_ref4) {
    var routeCwd = _ref4.routeCwd,
        staticCwd = _ref4.staticCwd,
        id = _ref4.id;
    app._router.stack = app._router.stack.filter(function (item) {
      return item._id !== id;
    });
    app.use(routeCwd, express.static(staticCwd));

    var stack = app._router.stack.filter(function (item) {
      return item._id !== id;
    });

    var firstStaticIndex = stack.findIndex(function (item) {
      return item.name === 'serveStatic';
    });
    var staticServers = stack.filter(function (item, index) {
      return index > firstStaticIndex && item.name === 'serveStatic';
    });
    var newStatic = staticServers[staticServers.length - 1];

    if (newStatic) {
      newStatic._id = id;
    }

    var otherServer = stack.filter(function (item, index) {
      return item.name !== 'serveStatic' || index === firstStaticIndex;
    });
    otherServer.splice.apply(otherServer, [firstStaticIndex + 1, 0].concat(_toConsumableArray(staticServers)));
    app._router.stack = otherServer;
  });
}

module.exports = startUp;
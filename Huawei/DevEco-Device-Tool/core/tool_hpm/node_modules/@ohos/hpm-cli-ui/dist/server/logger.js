"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');

var OS = require('os');

var fs = require('fs');

var _require = require('./utils/utils'),
    getFormattedDate = _require.getFormattedDate,
    getFileSize = _require.getFileSize;

var _require2 = require('./config.json'),
    MAX_LOG_SIZE = _require2.MAX_LOG_SIZE;

var Logger = /*#__PURE__*/_createClass(function Logger() {
  var logDirPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : path.join(OS.homedir(), '.hpm', 'log', 'ui');

  _classCallCheck(this, Logger);

  var logSize = getFileSize(logDirPath, Logger.clearNoSizeFile);
  var logStream = fs.createWriteStream(path.join(logDirPath, "log-".concat(getFormattedDate(new Date(), 'YYYY-MM-DD-hh-mm-ss'), ".log")), {
    flags: 'a'
  });
  var requestErrorStream = fs.createWriteStream(path.join(logDirPath, "error-request-".concat(getFormattedDate(new Date(), 'YYYY-MM-DD-hh-mm-ss'), ".log")), {
    flags: 'a'
  });
  fs.mkdirSync(logDirPath, {
    recursive: true
  });

  if (logSize > MAX_LOG_SIZE) {
    fs.rmdirSync(logDirPath, {
      recursive: true
    });
    fs.mkdirSync(logDirPath, {
      recursive: true
    });
  }

  var write = process.stdout.write.bind(process.stdout);

  process.stdout.write = function (chunk, encoding, callback) {
    write(chunk, encoding, callback);
    logStream.write(chunk, encoding, callback);
  };

  return {
    logStream: logStream,
    requestErrorStream: requestErrorStream
  };
});

Logger.clearNoSizeFile = function (filePath, stat) {
  if (stat.size === 0) {
    fs.unlinkSync(filePath, {
      force: true
    });
  }
};

module.exports = Logger;